% -*- mode: LaTeX; coding: utf-8 -*-
\def\indx#1{\mathfrak{#1}}
\def\l{\indx{l}}
\def\m{\indx{m}}
\def\n{\indx{n}}
\def\vctr#1{\mathbf{#1}}
\def\a{\vctr{a}}
\def\b{\vctr{b}}
\def\c{\vctr{c}}


\subsection{Индексы и вектора}
Под индексом понимается массив целых чисел (тип {\tt int}) длиной $D$, в
дальнейшем мы будем кратко обозначать их как $\m_D, \n_D, \l_D$ или $\m, \n,
\l$ если размерность очевидна. Под
вектором в декартовом пространстве размерности $D$ понимается массив объектов
(по умолчанию типа {\tt double}) длиной $D$, в
дальнейшем мы будем кратко обозначать их как $\a_D, \b_D, \c_D$ или $\a, \b,
\c$ если размерность очевидна. Индексы реализованы в виде
параметризованного класса {\tt indx<$D$>} в заголовочном файле {\tt
  <aivlib/indexD.hpp>}, вектора реализованы в виде
параметризованного класса {\tt vctr<$D$,class $T$=double>} в заголовочном файле {\tt
  <aivlib/vectorD.hpp>}.

Раньше для обеспечения эффективных вычислений с объектами--векторами приходилось
прибегать к различным ухищрениям для создания эффективного кода. Сейчас
благодаря серьезному прогрессу в создании оптимизирующих компиляторов эта
необходимость отпала~---~в случае параметризованных по размеру векторов
компилятор самостоятельно генерирует достаточно эффективный код.

\subsubsection{Конструкторы}
Для индексов и векторов реализованы следующие конструкторы: конструктор
принимающий один аргумент для инициазалиции всех компонент (по умолчанию
аргумент равен нулю); конструктор копирования; конструктор принимающий массив
значений для иницализации (см. таблицу \ref{vctr:construct:table}).

Для  {\tt Python} реализован конструктор, принимающий кортеж (или любой
объект допускающий индексирование по целым числам в диапазоне $[0,D-1]$) значений компонент (объектов, допускающих
приведение к типам {\tt int/float} в  {\tt Python}-не), но
пользоваться им в {\tt C++} неудобно. 
В {\tt C++} на основе {\tt variadic template} из {\tt C++0x} реализованы конструкторы с числом аргмеунтов $D$ принимнающие 
соотвествующие компоненты индекса/вектора. Если число аргментов не отвечает размерности $D$, при компиляции возникает ошибка 
<<{\tt incorrect parametrs count}>>.
 
В {\tt C++} и {\tt Python} реализованы  порождающие
функции {\tt Indx} и {\tt Vctr} для создания индексов и векторов с
произвольной размерностью, размерность определяется по количеству
аргументов. Для обратной совместимости со старыми версиями библиотеки поддерживаются
порождающие 
функции {\tt DIndx(D,args) } и {\tt  DVctr(D,args)}
аналогичные  {\tt Indx } и {\tt Vctr}, но требующие явного указания
размерности через аргумент {\tt D}. Например:
\begin{verbatim}
C++:
     vctr<3> a;    // вектор с D=3, заполненный нулями.
     vctr<5> b(1); // вектор с D=5, заполненный единицами.
     // вектора с D=7 и компонентами (1,2,3,4,5,6,7)
     vctr<7> c = Vctr(1,2,3,4,5,6,7);  
     vctr<7> e = DVctr(7, 1,2,3,4,5,6,7); 
     vctr<7> f(1,2,3,4,5,6,7); 

Python:
     a = vctr3()    # вектор с D=3, заполненный нулями.
     b = vctr5(1)   # вектор с D=5, заполненный единицами.
     # вектор с D=7 и компонентами (1,2,3,4,5,6,7)
     c = Vctr(1,2,3,4,5,6,7) 
     f = vctr7((1,2,3,4,5,6,7)) 
\end{verbatim}
Для использования в {\tt Python} должен быть собраны и проимпортированны
модули {\tt indx/vctr}$D$ соотвествующей размерности (сборка и импорт модуля {\tt vctr}$D$ автоматически приводит к 
сборке и импорту модуля {\tt indx}$D$), 
функции  {\tt Indx, Vctr} производят сборку и импорт автоматически.

\begin{table}
\footnotesize
\begin{tabular}{rclrcl}
%\hline
{\tt indx<D>(int n=0)} & $\to$ & $\l=(n,n,...)$ & {\tt vctr<D,T>(T v=0)}& $\to$ & $ \a=(v,v,...)$ \\
{\tt indx<D>(const indx<D> m)} & $\to$ & $\l=\m$ & {\tt vctr<D,T>(vctr<D,T> b)}& $\to$ & $ \a=\b$ \\
{\tt indx<D>(int *ptr)} & $\to$ & $l_i={\tt ptr[i]}$ & {\tt vctr<D,T>(T* ptr)} & $\to$ & $ a_i={\tt ptr[i]}$ \\
{\tt indx<D>(PyObject* t)} & $\to$ & $l_i={\tt t[i]}$ & {\tt vctr<D,T>(PyObject* t)} & $\to$ & $ a_i={\tt t[i]}$ \\
{\tt indx<D>(n$_0$, ..., n$_{D-1}$)} & $\to$ & $\l_D=(n_0, ..., n_{D-1})$ & 
{\tt vctr<D>(v$_0$, ..., v$_{D-1}$)} & $\to$ & $ \a_D=(v_0, ..., v_{D-1})$ \\
%\hline
{\tt Indx(n$_0$, ..., n$_{D-1}$)} & $\to$ & $\l_D=(n_0, ..., n_{D-1})$ & 
{\tt Vctr(v$_0$, ..., v$_{D-1}$)} & $\to$ & $ \a_D=(v_0, ..., v_{D-1})$ \\
{\tt DIndx(D, n$_0$, ..., n$_{D-1}$)} & $\to$ & $ \l_D=(n_0, ...,n_{D-1})$ & 
{\tt DVctr(D, v$_0$, ..., v$_{D-1}$)} & $\to$ & $ \a_D=(v_0, ..., v_{D-1})$ \\
%\hline
\end{tabular}
\caption{Конструкторы и порождающие функции для индексов и векторов}\label{vctr:construct:table}
\end{table}

\begin{table}
\begin{center}
\footnotesize
\begin{tabular}{|rcl|rcl|}
\hline
$\l=\m+\n$ &$\to$& $l_i=m_i+n_i$ & $\a=\b+\c$ &$\to$& $a_i=b_i+c_i$  \\
$\l=\m-\n$ &$\to$& $l_i=m_i-n_i$ & $\a=\b-\c$ &$\to$& $a_i=b_i-c_i$  \\
$\m+\!\!=\n$ &$\to$& $m_i=m_i+n_i$ & $\b+\!\!=\c$ &$\to$& $b_i=b_i+c_i$  \\
$\m-\!\!=\n$ &$\to$& $m_i=m_i-n_i$ & $\b-\!\!=\c$ &$\to$& $b_i=b_i-c_i$  \\
$ \l = \m+k$ &$\to$& $l_i = m_i+k$ & $\a=\b+v$ &$\to$& $a_i=b_i+v$ \\ 
$ \l = \m-k$ &$\to$& $l_i = m_i-k$ & $\a=\b-v$ &$\to$& $a_i=b_i-v$ \\ 
$ \m+\!\!=k$ &$\to$& $m_i = m_i+k$ & $\b+\!\!=v$ &$\to$& $b_i=b_i+v$  \\ 
$ \m-\!\!=k$ &$\to$& $m_i = m_i-k$ & $\b-\!\!=v$ &$\to$& $b_i=b_i-v$  \\ 
\hline
$\l=\m\ast k$ &$\to$& $l_i=m_i  k$ & $\a=\b\ast v$ &$\to$& $a_i=b_i  v$  \\
$\m\ast\!\!= k$ &$\to$& $m_i=m_i  k$ & $\b\ast\!\!= v$ &$\to$& $b_i=b_i  v$  \\
$\l= k \ast \m$ &$\to$& $l_i=k  m_i$ & $\a= v \ast \c$ &$\to$& $a_i= v  c_i$  \\
$\l=\m/ k$ &$\to$& $l_i=m_i/ k$ & $\a=\b/ v$ &$\to$& $a_i=b_i/ v$  \\
$\l/\!\!= k$ &$\to$& $l_i=l_i/ k$ & $\b/\!\!= v$ &$\to$& $b_i=b_i/ v$  \\
\hline
$\a = \m \ast \c$ &$\to$& $a_i=m_i  c_i$ & $\a = \b \ast \n$ &$\to$&
$a_i=b_i  n_i$ \\
&&& $\a \ast\!\!= \m$ &$\to$& $a_i=a_i  m_i$ \\
$\l = \m/\n$ &$\to$& $l_i=m_i/n_i$ & $\a = \b / \m$ &$\to$& $a_i=b_i/ m_i$ \\
$\m/\!\!=\n$ &$\to$& $m_i=m_i/n_i$ & $ \b /\!\!= \m$ &$\to$& $b_i=b_i/ m_i$ \\
&&& $\l=\b/\c$ &$\to$& $l_i={\tt
  floor}(b_i/c_i)$ \\
$\l = \m \,\,\widehat{}\,\, \n$ &$\to$& $l_i=m_in_i$ & $\a = \b \,\,\widehat{}\,\, \c$ &$\to$&
$a_i=b_ic_i$ \\
$\m \,\,\widehat{}= \n$ &$\to$& $m_i=m_in_i$ & $\b \,\,\widehat{}= \c$ &$\to$&
$b_i=b_ic_i$ \\
\hline
$\l = \m \% \n$ &$\to$& $l_i=m_i\% n_i$ & $\a_3 = \b_3 \% \c_3$ &$\to$&
$\a_3 = \b_3 \times \c_3$ \\
$\m \%\!\!= \n$ &$\to$& $m_i=m_i\% n_i$ & $\b_3 \%\!\!= \c_3$ &$\to$&
$\b_3 = \b_3 \times \c_3$ \\
&&&  $v = \b_2 \% \c_2$ &$\to$& $ v =  b_0c_1-b_1c_0$ \\
\hline
$k=\m\ast \n$ &$\to$& $k=\sum_i m_i  n_i$ & $v =\b\ast \c$ &$\to$& $v =
\sum_i b_i  c_i$  \\
$k={\tt (int)}\m$ &$\to$& $ k=\prod_i m_i $ & $v = \b \& \c$ &$\to$& $v=\prod_i(c_i-b_i)$\\
$k=\m.{\tt volume()}$ &$\to$& $ k=\prod_i m_i $ &&& \\
$\l=k\%\m$ && см. текст &&& \\
\hline
$ k = \m[i]$ &$\to$& $k = m_i$ & $ v = \b[i]$ &$\to$& $v = b_i$ \\
$ \l = -\m$ &$\to$& $l_i = -m_i$ & $ \a = -\b$ &$\to$& $a_i = -b_i$ \\
$ \l_{D_1} = \m_{D_2}$ &$\to$& $l_i = m_i,\quad i < {\rm min(D_1,D_2)}$ & $
\a_{D_1} = \b_{D_2}$ &$\to$& $a_i = b_i,\quad  i < {\rm min(D_1,D_2)}$\\
\hline
$ \l = \m \ll \n$ &$\to$& $l_i = {\rm min}(m_i,n_i)$ & $ \a = \b \ll \c$ &$\to$& $a_i = {\rm min}(b_i,c_i)$\\
$ \l = \m \gg \n$ &$\to$& $l_i = {\rm max}(m_i,n_i)$ & $ \a = \b \gg \c$ &$\to$& $a_i = {\rm max}(b_i,c_i)$\\
$ \m \ll= \n$ &$\to$& $m_i = {\rm min}(m_i,n_i)$ & $ \b \ll= \c$ &$\to$& $b_i = {\rm min}(b_i,c_i)$\\
$ \m \gg= \n$ &$\to$& $m_i = {\rm max}(m_i,n_i)$ & $ \b \gg= \c$ &$\to$& $b_i = {\rm max}(b_i,c_i)$\\
\hline
$ q = \m == \n$ &$\to$& $q = \prod_i (m_i=n_i)$  &  $ q = \b == \c$ &$\to$& $q = \prod_i (b_i=c_i)$  \\
$ q = \m \,!\!= \n$ &$\to$& $q = \sum_i (m_i\neq n_i)$  &  $ q = \b \,!\!= \c$ &$\to$&
$q = \sum_i (b_i\neq c_i)$  \\
$ q = \l < \m$ &$\to$& $q = \prod_i (l_i<m_i)$   &  $ q = \b < \c$ &$\to$& $q = \prod_i (b_i<c_i)$  \\
$ q = \l <= \m$ &$\to$& $q = \prod_i(l_i\leq m_i)$  &  $ q = \b <= \c$ &$\to$& $q = \prod_i(b_i\leq c_i)$  \\
$ q = \l > \m$ &$\to$& $q = \prod_i (l_i>m_i)$  &  $ q = \b > \c$ &$\to$& $q = \prod_i (b_i>c_i)$  \\
$ q = \l >= \m$ &$\to$& $q = \prod_i(l_i\geq m_i)$  &  $ q = \b >= \c$ &$\to$& $q = \prod_i(b_i\geq c_i)$  \\
$ q = \m {\tt \{CMP\}} k $ &$\to$& $q=\m.{\tt volume}() {\tt \{CMP\}} k $ &
$ q = \b$\tt\{CMP\} $v$ &$\to$& $q = \prod_i (b_i$\{CMP\}$v)$  \\
$ q = k {\tt \{CMP\}} \n $ &$\to$& $q= k{\tt \{CMP\}} \n.{\tt volume}() $ &
$ q = v$\tt\{CMP\} $\c$ &$\to$& $q = \prod_i (v$\{CMP\}$c_i)$  \\
\hline
$ \l_{D+1} = \m_D|k$ &$\to$& $l_i = m_i,\, l_D=k$  &  $ \a_{D+1} = \b_D|v$ &$\to$& $a_i = b_i,\, a_D=v$ \\
$ \l_{D+1} = k|\m_D$ &$\to$& $l_0=k,\, l_{i+1}=m_i$  &  $ \a_{D+1} = v|\b_D$ &$\to$& $a_0 = v,\, a_{i+1}=b_i$ \\
$ \l_{D+1} = (\m_D,k)$ &$\to$& $l_i = m_i,\, l_D=k$  &  $ \a_{D+1} = (\b_D,v)$ &$\to$& $a_i = b_i,\, a_D=v$ \\
$ \l_{D_1+D_2} = \m_{D_1}|\n_{D_2}$ &$\to$& $l_i = m_i,\, l_{i+D_1}=n_i$  &  
$ \a_{D_1+D_2} = \b_{D_1}|\c_{D_2}$ &$\to$& $a_i = b_i,\, a_{i+D_1}=c_i$ \\
$ \l_{D-1} = \m_D\,\,\widehat{}\,\,k$ &$\to$& $l_i = m_{i+(i>k)},\,i\neq k$  &  
$ \a_{D-1} = \b_D\,\,\widehat{}\,\,k$ &$\to$& $a_i = b_{i+(i>k)},\,i\neq k$  \\  
\hline
&&& $v=\b$.{\tt abs()} &$\to$& $v=\sqrt{\sum_i b_i^2}$\\
&&& $\a=\b$.{\tt pow($k$)} &$\to$& $a_i=b_i^k$\\
$q=\a$.{\tt is\_nan()} && см. текст & $q=\a$.{\tt is\_bad()} && см. текст \\
$\l$.{\tt c\_str(...)} && см. текст & $\a$.{\tt c\_str(...)} && см. текст \\
\hline
\end{tabular}
\end{center}
\caption{Oператоры и методы классов {\tt vctr<D>} и {\tt
    indx<D,T=double>}. Здесь $k$ целое число, $v$ значение типа{\tt~T}, $q$
  значение типа {\tt bool}, {\tt \{CMP\}} множество операторов сравнения \{$<, <=, >, >=,
  ==, \,!\!=$\}}\label{vctr:op:table}
\end{table}

\subsubsection{Арифметические операторы}
Для индексов и векторов в {\tt C++} и {\tt Python} традиционно перегружены операторы {\tt +, -, +=, -=} и
оператор доступа к элементу {\tt []}. Кроме того для индексов и векторов перегружены операторы
побитового сдвига $\ll, \gg$, $\ll=, \gg=$. Выражение $c=a\ll b$ интерпретируется
как покомпонетный результат вычисления выражения $c_i=\min(a_i,b_i)$. Такие операторы
позволяют эффективно определять границы области значений множества индекcов
или векторов. 

За счет конструкторов, для индексов/векторов перегружены операторы {\tt
  +, -, +=, -=} с целыми  числами/объектами из которых составлен вектор. Операторы интерпретируются как
добавление/вычитание одного и того же значения ко всем компонентам, при этом левым операндом обязательно должен быть индекс/вектор.

Для индексов и векторов перегружены оператор умножения как традиционное
скалярное произведение {\tt $a\ast
  b=\sum_{0}^{D-1} a_ib_i$}, и оператор покомпонентного умножения на число. 

Для индексов перегружены оператор {\tt '/'} как оператор покомпонентного деления индекса на индекс, и
оператор {\tt '\%'} как оператор покомпонентного остатка от деления индекса на индекс.

Для индексов перегружен оператор остатка от деления целого числа (порядкового номера
ячейки в многомерном массиве) на индекс
(размер массива), возвращающий индекс (координаты ячейки в массиве).

Для индексов реализована функция {\tt I.volume()$=\prod_{0}^{D-1} I_i$}

Для векторов реализован метод {\tt abs()} для вычисления
длины вектора. Для векторов с $D=2,3$ перегружен оператор \% как оператор
векторного умножения. 

Для вычисления адреса ячейки и координат узлов
равномерной прямоугольной сетки  пегружены операторы:
перемножение вектора на индекс~---
проводится покомпонетно и дает вектор; деление вектора на вектор~---
проводится покомпонентно и дает индекс (т.е. дробная часть результатов деления
отбрасывается). 

Для индексов и векторов нетрадиционно перегружен оператор $\widehat{~}$, 
реализующий покомпонентное перемножение
$$(a_0,...,a_{n-1})\widehat{~}(b_0,...,b_{n-1}) \to (a_0b_0,...,a_{n-1}b_{n-1}).$$

Для векоторов реализовано два метода покомпонентного возведения в степень:
\begin{verbatim}
		inline vctr pow(const int n) const;
		inline vctr pow(double n) const;
\end{verbatim}
Возведение в целочисленную степень использует покомпонентное умножение и факторизацию (предатсвление стпени в виде сумм степеней двойки),
что значительно уменьшает число умножений для больших степеней, поддерживаются случаи $n=0$ и $n<0$. 
Возведение в дробную степень использует покомпонентный вызов функции \verb'::pow(x, n)' 
из библиотеки \verb'math.h'.

\subsubsection{Операторы сравнения}
Сравнение векторов/векторов проводится нетрадиционным образом. Перегружены операторы
{\tt <, >, <=, >=, ==,
  !=}. Считается, что $\vec a<\vec b$ при
$a_i<b_i\quad \forall i$ и $\vec a \leq \vec b$ при
$a_i\leq b_i\quad \forall i$. Аналогично, $\vec a>\vec b$ при
$a_i>b_i\quad \forall i$ и $\vec a \geq \vec b$ при
$a_i\geq b_i\quad \forall i$. Такие операции сравнения позволяют эффективно
задавать прямоугольные области как множество индексов/векторов $\vec x$ удовлетворяющих
условию $\vec a < \vec x < \vec b$.

Для использования индексов и векторв в качестве ключей контейнера \verb'std::map' бибилиотеки \verb'STL' специализирована структура
\verb'std::less', сравнивающая индексы/вектора в обратном лексикографичеком порядке. Во избежании влияния ошибок округления,
структура \verb'std::less' для векторов использует структуры \verb'std::less' специализированные для типа компонент вектора. 
В частноссти, для  \verb'double' и \verb'float' в модуле \verb'vectorD.hpp' специализированны  структуры \verb'std::less',
не учитывающие при сравнении последние байт (для \verb'float') и два байта (для \verb'double') мантиссы.

Для индексов перегружены операторы сравнения {\tt <, >, <=, >=, ==,
  !=} с целыми числами как сравнение с результатом вычиления метода {\tt
  volume()} (произведение компонет индекса), что упрощает организацию обхода
области произвольной размерности. Аналогично в {\tt Python} реализован
оператор приведения индекса к целому.

За счет конструкторов, для векторов перегружены операторы сравнения с объектами из которых составлен вектор. Операторы интерпретируются как
сравнение с вектором, составленным из одинаковых компонент.


\subsubsection{Операторы для изменения размерности}
Для индексов и векторов нетрадиционно перегружен оператор $|$,
реализующий сшивку (слияние)
\begin{align}
&(a_0,...,a_{n-1})|x \to (a_0,...,a_{n-1},x), \notag\\
&x|(a_0,...,a_{n-1}) \to (x,a_0,...,a_{n-1}), \notag\\
&(a_0,...,a_{n-1})|(b_0,...,b_{m-1}) \to (a_0,...,a_{n-1},b_0,...,b_{m-1}). \notag
\end{align}

Для индексов и векторов нетрадиционно перегружен оператор $\widehat{~}$,
реализующий удаление заданной компоненты
$$(a_0,...,a_{n-1})\widehat{~}i \to (a_0,...,a_{i-1},a_{i+1},a_{n-1}). $$ 



\subsubsection{Другие методы}
Для индексов и векторов реализованы методы форматированного вывода
\begin{verbatim}
     const char* vctr::c_str( const char* separator=" ", // межкомпонентный разделитель
                              const char* format="%g"    // формат вывода компонент
                              ) const;
     const char* indx::c_str( const char* separator=" "  // межкомпонентный разделитель
                              const char* format="%i"    // формат вывода компонент
                              ) const;
\end{verbatim}
Содержимое объекта выводиться в глобальный кольцевой буфер модуля {\tt
  mystream} и может использоваться
непосредственно в качестве аргументов функций семейства {\tt printf}.
\begin{verbatim}
     indx<3> i; vctr<7> v;
     printf("i=(%s) v=(%s) # python-style\n", i.c_str(","), v.c_str(",") );
     printf("%s %s # datfile-style\n", i.c_str(), v.c_str() );
\end{verbatim}
Результат одного вызова метода {\tt c\_str}, хранящийся в кольцевом буфере, будет со
временем перекрыт результатами других выводов в кольцевой буфер, поэтому
результат должен быть использорван как можно раньше. В частности, код вида
\begin{verbatim}
     char* results[1000]; vctr<7> v[1000];
...
     for( int i=0; i<1000; i++ ) results[i] = v[i].c_str();
     for( int i=0; i<1000; i++ ) printf( "%s\n", results[i] );
\end{verbatim}
выведет на печать не тысячу векторов в столбик, а некоторую непредсказуемую
мешанину из цифр.

Для поддержки сериализации индексов и векторов реализованы функции {\tt
  \_\_getstate\_\_/\_\_С\_setstate\_\_} возвращающие/принимающие кортеж значений
компонент.
Кроме того для индексов и итераторов реализована функция {\tt
  \_\_contains\_\_}, проверяющая принадлежность аргумента к области.

Для векторов реализованы методы {\tt bool is\_nan()} (на основе макроса {\tt
  isnan}) и {\tt bool is\_bad()} (на основе макроса {\tt isnormal}
проверяющие корректность всех компонент. 

\subsubsection{Обход прямоугольных областей}
Ранее, для простейшего обхода прямоугольной области произвольной размерности с левым нижним углом в нуле и
правым верхнем углом с координатми {\tt N} (где {\tt N}~--- индекс размерности
{\tt D}), без посещения правой границы, предлагалось использовать оператор {\tt '\%'}:
\begin{verbatim}
     for( long i=0; i<N.volume(); i++ ){
        indx<D> I = i%N; // координаты точки с номером i
        ...
     }
\end{verbatim}
или (поскольку для индексов перегружены операторы сравнения с целым) эквивалентный код
\begin{verbatim}
     for( long i=0; i<N; i++ ){
        indx<D> I = i%N; // координаты точки с номером i
        ...
     }
\end{verbatim}
Аналогично, для простейшего обхода прямоугольной области произвольной размерности с
координатами левого
нижнего углома  {\tt A} и
правого верхнего угла {\tt В} (где {\tt A, B}~--- индексы размерности
{\tt D}) можно записать
\begin{verbatim}
     for( long i=0; i<B-A; i++ ){
        indx<D> I = A+i%(B-A); // координаты точки с номером i
        ...
     }
\end{verbatim}
Обратите внимание на тип счетчика~--- {\tt long i}. Для областей с числом
ячеек менее $2^{31}$ допустимо использование типа {\tt int}, но в
общем случае этого недостаточно. Кроме того, размер области по любой из
координат не может превышать $2^{31}$ ячеек~--- впрочем задачи, в которых
используются такие массивы являются на наш взгляд настолько экзотическими, что
переходить ради них от типа {\tt int} к типу {\tt long} для компонент индекса
представляется нерациональным.

Однако, такой подход неэффективен, поскольку оператор \verb'%' требует $D$ целочисленных делений и $D$ остатков от деления.
Начиная с 12-го релиза для обохода прямоугольных областей у индексов введены методы \verb'less', \verb'next' и \verb'z_next'.
