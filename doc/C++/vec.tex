% -*- mode: LaTeX; coding: utf-8 -*-
\def\Ind#1{\mathfrak{#1}}
\def\l{\Ind{l}}
\def\m{\Ind{m}}
\def\n{\Ind{n}}
\def\Vec#1{\mathbf{#1}}
\def\a{\Vec{a}}
\def\b{\Vec{b}}
\def\c{\Vec{c}}


\section{Вектора и индексы --- модуль {\tt vec}}
\subsection{Общие замечания}
 Под вектором в декартовом пространстве размерности $D$ понимается массив объектов
(по умолчанию типа {\tt double}) длиной $D$, в
дальнейшем мы будем кратко обозначать их как $\a_D, \b_D, \c_D$ или $\a, \b,
\c$ если размерность очевидна.
Вектора реализованы в виде
параметризованного класса 
\begin{verbatim}
	template <int D, typename T=double> class Vec;
\end{verbatim}
в заголовочном файле {\tt <aiwlib/vec>}.

Под индексом понимается массив целых чисел (тип {\tt int}) длиной $D$, в
дальнейшем мы будем кратко обозначать их как $\m_D, \n_D, \l_D$ или $\m, \n,
\l$ если размерность очевидна. Индексы реализованы в виде alias-а
\begin{verbatim}
	template<int D> using Ind = Vec<D, int>;
\end{verbatim}
в заголовочном файле {\tt <aiwlib/vec>}.

Кроме того доступен alias
\begin{verbatim}
	template<int D> using Vecf = Vec<D, float>;
\end{verbatim}

Таким образом индексы и вектора имеют практически одинаковые наборы операций, поскольку 
являются по сути одним и тем же параметризованным классом, и все сказанное для векторов справделиво и для индексов.
Для индексов дополнительно перегружены операции
\begin{verbatim}
	template<int D> inline Ind<D>& operator ++ (Ind<D> &I);
	template<int D> inline bool operator ^= (Ind<D> &pos, const Ind<D> &Up);
	template<int D> inline Ind<D> operator % (size_t x, const Ind<D> &p);
\end{verbatim}
применяющиеся для индексации и обхода $D$--мерной прямоугольной области.

Во всех бинарных операциях, при вызове конструкторов и операций копирования 
одномерный вектор трактуется как вектор произвольной размерности состоящий из одинаковых компонент.

Для инстацирования {\tt C++} векторов в {\tt Python} при импорте модуля {\tt vec.py} 
специальным образом подправляется таблица типов {\tt SWIG}, в результате явного инстацирования (при помощи директивы 
\verb'%template' в {\tt .i}--файле) не требуется. Модуль {\tt vec.py} предоставляет класс \verb'Vec',
экземпляры которого в зависимости от типа и количества компонент 
трактуются как экземпляры соответствующих классов {\tt Vec} в {\tt C++}.

\subsection{Конструкторы и порождающие функции}
Для индексов и векторов реализованы следующие конструкторы~--- конструктор
принимающий один аргумент для инициазалиции всех компонент, по умолчанию
аргумент равен нулю:
\begin{verbatim}
    explicit Vec(T val=0);
\end{verbatim}
конструктор копирования:
\begin{verbatim}
    template <class T2> Vec(const Vec<D, T2> &v);
\end{verbatim}
конструктор принимающий $D$ аргументов для иницализации:
\begin{verbatim}
    template <typename ... Args> explicit Vec(const Args&... xxx);
\end{verbatim}
конструктор принимающий одномерный вектор (трактуется как $D$--мерный вектор с одинаковыми компонентами):
\begin{verbatim}
    Vec(const Vec<1, T> &v);
\end{verbatim}

Кроме того реализованы порождающие функции
\begin{verbatim}
	template <typename T, typename ... Args> 
        inline Vec<1+sizeof...(Args), T> vec(T x, Args ... args);
	template <typename ... Args> inline Vecf<sizeof...(Args)> vecf(Args ... args);
	template<typename ... Args> inline Ind<sizeof...(Args)> ind(Args ... args);
\end{verbatim}

В  {\tt Python} для класса {\tt Vec} реализован конструктор, принимающий произвольное число аргументов (компонент) 
либо кортеж, список или вектор 
значений компонент (объектов, допускающих приведение к типам {\tt bool/int/long/float/complex}).
Тип вектора по умолчанию равен {\tt double} либо явно задается через именованный аргумент конструктора {\tt T}.
Размерность вектора определятся по числу компонент, либо явно задается через именованный аргумент конструктора {\tt D}.
Реализована порождающая функция {\tt vec}, возвращающая вектор с размерностью равной числу аргументов 
и типом определяемым на основе типа первого аргумента.

В  {\tt Python} классы {\tt Ind} и {\tt Vecf} определены как наследники класса {\tt Vec}; определены прождающие функции
{\tt ind} и {\tt vecf}.

Примеры использования (распространяются так же на классы {\tt Ind} и {\tt Vecf}):
\begin{verbatim}
C++:
     Vec<3> a;    // вектор с D=3, заполненный нулями.
     Vec<5> b(1.); // вектор с D=5, заполненный единицами.
     // вектора с D=7 и компонентами (1,2,3,4,5,6,7)
     Vec<7> c = Vctr(1,2,3,4,5,6,7);  
     Vec<7> e = vec(1,2,3,4,5,6,7); 
     Vec<7> f(1,2,3,4,5,6,7); 

Python:
     a = Vec(D=3)    # вектор с D=3, заполненный нулями.
     b = Vec(1, D=5)   # вектор с D=5, заполненный единицами.
     # вектор с D=7 и компонентами (1,2,3,4,5,6,7)
     c = Vec(1,2,3,4,5,6,7) 
     f = vec((1,2,3,4,5,6,7)) 
\end{verbatim}


\begin{table}
\begin{center}
\begin{tabular}{|rcl|rcl|}
\hline
$ \a = -\b$ &$\to$& $a_i = -b_i$ & $ \a = +\b$ &$\to$& $a_i = +b_i$ \\
$\a=\b+\c$ &$\to$& $a_i=b_i+c_i$  & $\b\,+\!\!=\c$ &$\to$& $b_i=b_i+c_i$  \\
$\a=\b-\c$ &$\to$& $a_i=b_i-c_i$  & $\b\,-\!\!=\c$ &$\to$& $b_i=b_i-c_i$  \\
$\a=\b\ast x$ &$\to$& $a_i=b_i  x$  & $\b\,\ast\!\!= x$ &$\to$& $b_i=b_i  x$  \\
$\a= x \ast \c$ &$\to$& $a_i= x  c_i$ &&&  \\
$\a=\b/ x$ &$\to$& $a_i=b_i/ x$ & $\b\,/\!\!= x$ &$\to$& $b_i=b_i/ x$  \\
$x = \b \ast \c$ &$\to$& $x = \sum_i b_i c_i$ &&&  \\
\hline
$\a=\b\&\c$ &$\to$& $a_i=b_i  c_i$  & $\b\,\&\!\!= \c$ &$\to$& $b_i=b_i  c_i$  \\
$\a=\b/\c$ &$\to$& $a_i=b_i/c_i$  & $\b\,/\!\!= \c$ &$\to$& $b_i=b_i/c_i$  \\
$\a= x/\c$ &$\to$& $a_i= x/c_i$ &&&  \\
\hline
$ \a = \b \ll \c$ &$\to$& $a_i = \min(b_i,c_i)$ & $ \b \ll= \c$ &$\to$& $b_i = \min(b_i,c_i)$\\
$ \a = \b \gg \c$ &$\to$& $a_i = \max(b_i,c_i)$ & $ \b \gg= \c$ &$\to$& $b_i = \max(b_i,c_i)$\\
\hline
$\a_3 = \b_3 \% \c_3$ &$\to$& $\a_3 = [\b_3 \times \c_3]$ &$\l=k\%\m$ && см. текст \\
$x = \b_2 \% \c_2$ &$\to$& $ x =  b_0c_1-b_1c_0$ & $\l\,\,\widehat{~}\!=\m$ && см. текст \\
&&& $++\m$ &$\to$& $++m_0$\\
\hline
$ q = \b == \c$ &$\to$& $q = (b_i=c_i \forall i)$  & $ q = \b \,!\!= \c$ &$\to$& $q = (\exists i) b_i\neq c_i$  \\
$ q = \b < \c$ &$\to$& $q = (b_i<c_i \forall i)$ & $ q = \b <= \c$ &$\to$& $q = (b_i\leq c_i \forall i)$ \\
$ q = \b > \c$ &$\to$& $q = (b_i>c_i \forall i)$ & $ q = \b >= \c$ &$\to$& $q = (b_i\geq c_i \forall i)$   \\
$ q = {\tt bool}(\b)$ &$\to$& $q = (\exists i) b_i\neq 0$  & $ q = !\b$ &$\to$& $q = (b_i=0 \forall i)$  \\
\hline
\end{tabular}
\end{center}
\caption{Арифметические операции и операции сравнения класса {\tt Vec<D,T>}}\label{vec:op:table}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{|rcl|rcl|}
\hline
$ x = \b[i]$ &$\to$& $x = b_i$  & $ \a[i] = x$ &$\to$& $a_i = x$ \\
$x = (\a_D){\tt.periodic}(i)$ &$\to$ & $x=\a_{(i\%D)}$ & $(\a_D){\tt.periodic}(i) = x$ &$\to$ & $\a_{(i\%D)} = x$ \\
\hline
$ \a_{D+1} = \b_D|x$ &$\to$& $a_i = b_i,\, a_D=x$ & $ \a_D = \b_E(\m_D)$ &$\to$& $a_i = b_{\m_i}$ \\
$ \a_{D+1} = x|\b_D$ &$\to$& $a_0 = x,\, a_{i+1}=b_i$ & $ \a_D = \b_E(k_1, ... k_D)$ &$\to$& $a_i = b_{k_i}$ \\
$ \a_{D_1+D_2} = \b_{D_1}|\c_{D_2}$ &$\to$& $a_i = b_i,\, a_{(i+D_1)}=c_i$ & $ \a = \b{\tt.circ}(k)$ &$\to$& $a_i=b_{((i+k)\%D)}$ \\
\hline
$x=\b$.{\tt abs()} &$\to$& $x=\sqrt{\sum_i b_i^2}$ & $\a=\b$.{\tt ceil()} &$\to$& $a_i={\tt ::\!\!ceil}(b_i)$ \\
$\a=\b$.{\tt fabs()} &$\to$& $a_i=|b_i|$ & $\a=\b$.{\tt floor()} &$\to$& $a_i={\tt ::\!\!floor}(b_i)$ \\
$\a=\b$.{\tt pow($k$)} &$\to$& $a_i=b_i^k$ & $\a=\b$.{\tt round()} &$\to$& $a_i={\tt ::\!\!round}(b_i)$  \\
$x=\b$.{\tt sum()} &$\to$& $x=\sum_i b_i$ & $\a=\b$.{\tt fmod($x$)} &$\to$& $a_i={\tt ::\!\!fmod}(b_i, x)$ \\
$x=\b$.{\tt prod()} &$\to$& $x=\prod_i b_i$ & $\a=\b$.{\tt fmod($\c$)} &$\to$& $a_i={\tt ::\!\!fmod}(b_i, c_i)$ \\
$x=\b$.{\tt min()} &$\to$& $x=\min b_i$ & $\m=\b$.{\tt nan()} &$\to$& $m_i={\tt::\!\!isnan}(b_i)$ \\
$x=\b$.{\tt max()} &$\to$& $x=\max b_i$ & $\m=\b$.{\tt inf()} &$\to$& $m_i={\tt::\!\!isinf}(b_i)$ \\
$k=\b$.{\tt imin()} &$\to$& $x=\arg\min_i b_i$ & $q=\b$.{\tt cknan()} &$\to$& $q=(\exists i){\tt::\!\!isnan}(b_i)$ \\
$k=\b$.{\tt imax()} &$\to$& $x=\arg\max_i b_i$ & $q=\b$.{\tt ckinf()} &$\to$& $q=(\exists i){\tt::\!\!isinf}(b_i)$ \\
\hline
\end{tabular}
\end{center}
\caption{Oперации и методы для доступа к элементу, изменения размерности и различные преобразования класса {\tt Vec<D,T>}
}\label{vec:func:table}
\end{table}

\subsection{Арифметические операции и операции сравнения}
Для всех арифметических операций, кроме операций вида {\tt OP=},  тип результата (тип скаляра или тип компонент вектора) 
определяется на основе оператора {\tt decltype} (в {\tt C++11}, в {\tt Python} такое поведение эмулируется).
Например при сложении 
\begin{verbatim}
   Vec<3, int>(1,2,3)+Vec<3>(1.5, 2.5, 3.5) ==> Vec<3, double>(2.5, 4.5, 6.5)
\end{verbatim}
Исключением из этого правила является лишь операция скалярного произведения индексов.

Все арифметические операции для векторов перегружены одинаково в {\tt C++} и {\tt Python}.

Во всех операциях, где это имеет смысл, вектор единичной размерности может трактоваться как $D$--мерный вектор 
составленный из одинаковых компонент.

Традиционно для векторов перегружены операции {\tt +, -, +=, -=}, 
операции умножения на скаляр ($\a*x$, $x*\a$ и $\a*\!\!=x$), операции деления вектора на скаляр ($\a/x$ и $\a/\!\!=x$),
операция доступа к элементу {\tt []}. 

Операция умножения {\tt *} вектора на вектор перегружена как скалярное произведение 
векторов\footnote{В отличии от системы {\tt Matlab} транспонирования вектора при этом не требуется}.
Для индексов операция скалярного умножения возвращает тип \verb'int64_t' во избежании переполнения \verb'int32_t'
при индексации многомерных массивов.

Операции $\a/\b$, $\a/\!\!=\b$, $\a\&\b$ и $\a\&\!\!=\b$ перегружены как покомпонетное деление и умножение векторов.

Перегружены операторы
побитового сдвига $\ll, \gg$, $\ll=, \gg=$. Выражение $c=a\ll b$ интерпретируется
как покомпонетный результат вычисления выражения $c_i=\min(a_i,b_i)$. Такие операторы
позволяют эффективно определять границы области значений множества векторов. 

Сравнение векторов проводится нетрадиционным образом. Перегружены операторы
{\tt <, >, <=, >=, ==,
  !=}. Считается, что $\a<\b$ при
$a_i<b_i\quad \forall i$ и $\a \leq \b$ при
$a_i\leq b_i\quad \forall i$. Аналогично, $\a>\b$ при
$a_i>b_i\quad \forall i$ и $\a \geq \b$ при
$a_i\geq b_i\quad \forall i$. Такие операции сравнения позволяют эффективно
задавать прямоугольные области как множество индексов/векторов $\Vec x$ удовлетворяющих
условию $\a < \Vec x < \b$.

Для использования векторов в качестве ключей контейнера \verb'std::map' библиотеки \verb'STL' специализирована структура
\verb'std::less', сравнивающая вектора в обратном лексикографическом порядке. Во избежании влияния ошибок округления,
структура \verb'std::less' для векторов использует структуры \verb'std::less' специализированные для типа компонент вектора. 
В частности, для  \verb'double' и \verb'float' в модуле \verb'vec' специализированны  структуры \verb'std::less',
не учитывающие при сравнении последний байт (для \verb'float') и последние два байта (для \verb'double') мантиссы.

Для использования векторов в качестве ключей словаря \verb'Python' реализован метод \verb'__hash__', 
возвращающий \verb'hash'--значение кортежа, составленного из компонент вектора.

Реализован оператор приведения вектора к типу \verb'bool' (возвращает истину если хотя бы одна компонента не равна нулю)
и оператор отрицания \verb'!' (возвращает истину если все компоненты равны нулю).

Для двумерных и трехмерных векторов перегружена операция \verb'%' как операция векторного умножения.

Для индексов перегружена операция 
\begin{verbatim}
    Ind<D> operator % (size_t x, const Ind<D> &m);
\end{verbatim}
возвращающая индекс~--- позицию $i$--го (по счету) элемента в $D$--мерной
области размера $\m$, первая компонента считается самой быстрой осью. Операция может использоваться для
организации обхода $D$--мерной области в одном цикле:
\begin{verbatim}
    Ind<D> m = ...;
    size_t sz = m.prod();
    for(size_t i=0; i<sz; ++i){
        Ind<D> pos = i%m;
        ...
    }
\end{verbatim}
Операция относительно дорогая и такой вариант не очень эффективен, но зато цикл может 
быть легко распараллелен средствами библиотеки \verb'OpenMP'.

Для эффективного обхода $D$--мерных областей в {\tt C++} у индексов перегружены операции префиксного инкремента
и $\,\widehat{~}\!\!=$:
\begin{verbatim}
	Ind<D>& operator ++ (Ind<D> &l);
	bool operator ^= (Ind<D> &l, const Ind<D> &m);
\end{verbatim}
Операция инкремента всегда увеличивает нулевую компоненту индекса. Операция 
$\l\,\widehat{~}\!\!=\m$ проверяет, не вышла ли нулевая компонента индекса $\l$ за размеры области $\m$ 
(правая граница не включается)~---
при необходимости компонента обнуляется, следующая компонента инкрементируется и проверяется ее выход за пределы области.
Оператор возвращает истину, если проверенный (и измененный при необходимости) индекс находится
внутри области, и ложь если индекс вышел за пределы области (стал равен $\m$). Обход области выглядит как
\begin{verbatim}
    Ind<D> m = ...;
    for(Ind<D> l=0; l^=m; ++l){ ... }
\end{verbatim}
Такой обход куда эффективнее, но не может быть легко распараллелен средствами библиотеки \verb'OpenMP'.

Арифметические операции и операции сравнения приведены в таблице~\ref{vec:op:table}.

\subsection{Oперации и методы для доступа к элементу, изменения размерности и различные преобразования}
Для доступа к элементу традиционно перегружена операция {\tt []},
в {\tt C++} при включенном режиме отладки (опция \verb'debug=on' при вызове \verb'make' либо опция \verb'-DEBUG' компилятора) 
проверяется корректность номера компоненты вектора. 
В {\tt Python} для операции {\tt []} традиционно 
реализовано взятие среза и адресация с конца при отрицательном значении аргумента. Кроме того, в {\tt C++} реализован метод
\begin{verbatim}
    T  periodic(int i) const;
    T& periodic(int i);
\end{verbatim}
использующий положительный отстаток от деления $i$ на размерность вектора. 

Метод
\begin{verbatim}
    Vec circ(int l) const;
\end{verbatim}
возвращает вектор с циклически переставленными на $l$ позиций компонентами.

Операция \verb'|' (побитовое или) обеспечивает <<склейку>> числа и вектора, вектора и числа или двух векторов.

Операция \verb'()' принимает номера компонент вектора (произвольное количество аргументов) либо индекс произвольной 
длины с номерами компонент вектора (в {\tt Python} так же список и кортеж), и возвращает вектор составленный из
указанных компонент.

Метод \verb'abs()' возвращает модуль (длину) вектора как корень из суммы квадратов компонент. 

Метод \verb'pow(n)' возвращает вектор покомпонентно возведенный в степень $n$. Предоставляется эффективная 
реализация для целочисленных степеней, как положительных так и отрицательных.

Методы \verb'fabs()', \verb'ceil()', \verb'floor()', \verb'round()' возвращают вектор
с результатами покомпонетного применения соответствующих функций библиотеки {\tt math.h}. 

Метод \verb'fmod(y)' принимает скаляр либо вектор и возвращает вектор с результатами покомпонетного применения 
функции \verb'::fmod(x, y)' библиотеки {\tt math.h}, тип результирующего вектора опеределяется на основе оператора
\verb'decltype' (в {\tt C++11}, в {\tt Python} такое поведение эмулируется). 

Методы \verb'sum()' и  \verb'prod()' возвращают скаляр~--- сумму и произведение компонент вектора. На случай расчета
размера больших $D$--мерных прямоугольных областей, во избежании переполнения \verb'int32_t', предоставляется метод
\begin{verbatim}
    template <typename T2> inline void prod(T2 &res) const;
\end{verbatim}

Методы \verb'min()' и \verb'max()' возвращают значение минимальной и максимальной компоненты вектора.
Методы \verb'imin()' и \verb'imax()' возвращают номер минимальной и максимальной компоненты вектора 
(первой по счету из минимальной/максимальной, если есть компоненты с одинаковыми значениями).

Методы \verb'nan()' и \verb'inf()' возвращают индекс, содержащий результаты проверки компонент вектора при помощи
функций \verb'::isnan()' и \verb'::isinf()' библиотеки {\tt math.h}.
Методы \verb'cknan()' и \verb'ckinf()' возвращают истину, если хотя бы одна из компонент вектора содержит значение
\verb'NAN' или \verb'INF' (проверяется функциями \verb'::isnan()' и \verb'::isinf()' библиотеки {\tt math.h}).

Oперации и методы для доступа к элементу, изменения размерности и различные преобразования приведены в таблице~\ref{vec:func:table}.

\subsection{Другие операции и методы}
Для сериализации векторов в {\tt Python} перегружены специальные методы \verb'__get/setstate__'.

Для векторов перегружены операции форматированного ввода/вывода в потоки \verb'std::iostream' и
операция форматированного вывода в потоки \verb'aiw::IOstream'. 

Для векторов перегружены операции бинарного ввода/вывода \verb'<>' в потоки \verb'aiw::IOstream'. 

\subsection{Детали реализации}
При написании модуля \verb'vec' основной проблемой  являлась необходимость 
инстацирования шаблона {\tt Vec} в {\tt Python} при помощи {\tt SWIG}.
Ситуация усугублялась тем, что  модуль {\tt vec} написан с широким использованием возможностей {\tt C++11}
(шаблонов с переменным числом аргументов, оператора \verb'decltype', принципа \verb'SFINAE')~--- 
в момент написания модуля утилита \verb'SWIG' эти возможности не поддерживала. 
Кроме того, сама необходимость инстацирования
большого числа шаблонов \verb'Vec' с разными наборами параметров существенно усложняла сборку и 
эксплуатацию библиотеки.

В итоге было решено отказаться от прямого инстацирования шаблонов \verb'Vec' при помощи директивы \verb'%template'
утилиты \verb'SWIG'. Вместо этого на \verb'Python' был написан отдельный модуль \verb'vec.py',
использующий служебный класс \verb'PVec' и несколько функций из заголовочного файла \verb'aiwlib/swig'. 
При импорте модуль \verb'vec.py' анализирует таблицу типов \verb'SWIG' и устанавливает
дополнительные связи между всеми использованиями шаблонов \verb'Vec' в импортируемом \verb'C++'--коде и 
служебным классом \verb'PVec'. В итоге, поведение шаблонов класса \verb'Vec' полностью эмулируется в \verb'Python',
единственным ограничением является размер вектора в памяти, ограниченный размером памяти выделяемой под 
класс \verb'PVec'~--- в настоящий момент он не должен превышать 1024 байта.

Для корректной работы с \verb'C++' методами имеющими аргументы (возвращающими значения) и переменными типа \verb'Vec',
достаточно проимпортировать модуль \verb'aiwlib.vec' как
\begin{verbatim}
    import aiwlib.vec
\end{verbatim}
или
\begin{verbatim}
    from aiwlib.vec import *
\end{verbatim}
Для удобства работы рекомендуется второй вариант, хотя и в первом варианте переменные и возвращаемые значения 
типа \verb'Vec' оказываются полностью работоспособными в \verb'Python'.


Модуль \verb'vec' подключает и использует следующие библиотеки:
\begin{itemize}
\item \verb'<math.h>' --- стандартные математические функции;  
\item \verb'"aiwlib/debug"' --- средства отладки (проверка диапазона номеров компонент).
\end{itemize}
