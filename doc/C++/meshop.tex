% -*- mode: LaTeX; coding: utf-8 -*-
\section{Операции над равномерными многомерными прямоугольными (картезианскими) сетками --- модуль {\tt meshop}}\label{meshop:sec}
\subsection{Общие замечания}
Модуль \verb'meshop' перегружает операции  <<унарный минус>>, бинарные \verb'+', \verb'-', \verb'*', \verb'/', \verb'^' (как степень) и
функции \verb'abs', \verb'acos', \verb'asin', \verb'atan', \verb'ceil', \verb'cos', \verb'exp',  \verb'fabs', \verb'floor', \verb'log', \verb'log10', \verb'sin',
\verb'sinh',  \verb'sqrt', \verb'tan', \verb'tanh', \verb'atan2', \verb'fmod',  \verb'pow' над экземплярами классов \verb'Mesh<T,D>'.

Допускаются выражения произвольной сложности, содержащие перегруженные операции и функции, операндами которых являются экземпляры классов
\verb'Mesh<T,D>' или любые другие данные, для которых выражение будет иметь смысл если вместо
экземпляров классов \verb'Mesh<T,D>' подставляется значения из одной ячейки (типа \verb'T').

Само по себе выражение не приводит к выполнению каких либо действий, пока не будет выполнена операция \verb'<<=='
левым операндом которого должен быть экземпляр класса \verb'Mesh<T,D>', а правым построенное выражение. При этом запускается цикл по ячейкам
сетки стоящей слева от операции \verb'<<==', для каждой ячейки сетки слева отдельно вычисляется и записывается результат выражения справа.
Например:
\begin{verbatim}
#import <aiwlib/meshop>
using namespace aiw;
    ...
  Mesh<float, 3> f; f.init(ind(10,10,10));
  f <<= 1; // заполнить сетку f единицами
  f = f*2; // умножить значения f на два  
  Mesh<double, 3> g;   
   ...
  f <<= g*f+2*sin(g); // выражение выполянется по ячейкам независимо 
\end{verbatim}
Пределы, шаги и логарифмические масштабы всех сеток задействованных в выражении игнорируются, значение имеют лишь
размеры сеток в ячейках. 

\subsection{Детали реализации}
В модуле \verb'meshop' для каждой перегруженной операции и функции объявлен свой класс, параметризованный по типу операндов.
Все эти классы, как и класс \verb'Mesh', являются наследниками пустой структуры \verb'BaseMeshOp' объявленной в модуле \verb'mesh'.

При помощи технологии \verb'SFIANE'\footnote{<<Substitution failure is not an error>> --- неправильная подстановка не является ошибкой},
реализованной через шаблоны \verb'std::enable_if' и \verb'std::is_base_of', операции и функции перегружаются только для тех случаев,
когда хотя бы один из операндов является наследником структуры \verb'BaseMeshOp'. В итоге компилятор превращает
выражение справа от оператора \verb'<<=' в AST (абстрактное синтакстическое дерево) собранное из
объявленных в модуле \verb'meshop' классов, которое позволяет  вычислить значение выражение для произвольной (формально) позиции в сетке. 
