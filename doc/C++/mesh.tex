% -*- mode: LaTeX; coding: utf-8 -*-
\subsection{Массивы и равномерные прямоугольные сетки}
Массивы и равномерные прямоугольные сетки реализованы в заголовочных файлах
{\tt <aivlib/arrayTD.hpp>} и {\tt <aivlib/meshTD.hpp>} в виде класса {\tt array<$T$,$D$>} и наследующего
его класса {\tt mesh<$T$,$D$>}, где $T$~---~тип ячейки массива, $D$~---
размерность массива. 

Многомерный массив эффективно эмулируется при помощи
одномерного массива, смещение в котором пересчитывается с учетом размеров
многомерной области. При прохождении массива с использованием итератора или
оператора {\tt '\%'},
сравнение индесков и изменение позиции итератора реализованы с учетом
обеспечения локальности данных. При самостоятельной организации прохода
массива с помощью нескольких вложенных циклов, для обеспечения локальности
данных во внутренних циклах должны меняться первые компоненты индекса. Для
упрощения копирования массивов перегружен оператор доступа к элементу по
целому числу, позволяющий работать с многомерным массивом как с одномерным.

Размер массива {\tt N} задается при помощи функции {\tt
  init(const indx<$D$>\& N)}, и может быть изменен только через эту функцию,
или задан при создании массива через конструктор. 

Массивы и сетки имеют поле 
\begin{verbatim}
    const char* head;
\end{verbatim}
которое может содержать некоторый текстовый заголовок (описание) массива. Поле
устанавливается при мапировании, либо чтении/записи массива из потока. 

Массивы и сетки обеспечивают упорядоченный доступ к некоторому участку памяти.
Возможно создание массивов и сеток с другими размерами, обеспечивающих доступ
к тому же участку. В частности, конструкторы копирования массивов и сеток не
выделяют новых участков памяти под данные~---~копии ссылаются на тот же
участок. Сборка мусора призводится на основе подсчета ссылок.  С одной
стороны это существенно ускоряет копирование объектов, с другой стороны копии не являются
независимыми, т.е. изменение одной копии влечет за собой изменение всех
остальных копий. Для полноценного копирования с выделением нового участка
памяти под данные используется метод {\tt copy()}.

Параметры исходного массива, к которому обеспечивается дступ, могут быть
получена через следующие методы:
\begin{itemize}
\item \verb'int mem_szT()' --- возвращает размер ячейки исходного массива в байтах;
\item \verb'int mem_D()' --- возвращает размерность исходного массива;
\item \verb'int mem_N( int axe )' --- возвращает размер исходного массива по оси {\tt axe};
\item \verb'int mem_links()' --- возврщает число ссылок на участок памяти.
\end{itemize}
Если массив не инциализирован, методы {\tt mem\_...} возвращают ноль.

Для сеток дополнительно введены поля {\tt vctr<$D$> min, max, step} задающие границы
размера области и шаг равномерной прямоугольной сетки; поле {\tt T ext\_val} задающее значения на сетке за
пределами области. Значения {\tt min, max, step} должны быть заданы
пользователем {\bf согласованным образом}, правильное соотношение {\tt
  step=(max-min)/N}.

Для получения детальной информации о массивах и сетках служит метод
\begin{verbatim}
    void info( Ostream& S=mystdout ) const;
\end{verbatim}
выводящий в поток {\tt S} при помощи макроса {\tt WSTR} (см. раздел
\ref{aivlib:debug:info:sec}) значения всех полей объекта.

\subsubsection{Доступ к элементам}
Для доступа к элементам традиционно определены операторы \verb'[]' по
индексу. {\bf
Для увеличения производительности проверка выхода за границы массива в
операторе доступа \verb'[]' не производится, используйте для этого функцию
{\tt \_\_contains\_\_} поля размера массива {\tt N}!}. 

Для сеток дополнительно перегружен оператор доступа \verb'[]' по координатам точки ({\tt vctr<$D$>}) и
функция {\tt bool~\_\_contains\_\_(const~vctr<$D$>\& r)}. При доступе по
координатам проверяется принадлежность к области определения сетки, в случае выхода за
пределы сетки возвращается ссылка на поле {\tt ext\_val}. При задании значений сетки
следует быть осторожным, так как при выходе
за пределы области будет изменено не значение ячейки а значение поля {\tt ext\_val}.

Каждый доступ по и индексу требует $D$ операций сложения и $D$ операций
умножения, это плата за универсальность (возможность создавать массивы с
альтернативным доступом, другой размерности, преобразованными осями и
т.д.). Доступ по целому числу дополнительно требует $D$ операций деления и $D$
операций вычисления остатка от деления, поскольку число сначала преобразуется
к индексу. При доступе по вектору в сетках вектор преобразуется к индексу, что
требует $D$ операций вычитания и $D$ операций деления с плавающей точкой. 

Для организации прямого доступа без лишних операций предназначены методы
\begin{verbatim}
    const T& get( long i ) const ;
          T& get( long i )       ;
\end{verbatim}
принимающие смещение элемента от начала участка памяти массива в байтах. 
Для вычисления смещения предназначены методы
\begin{verbatim}
    long index( const indx<D>& I ) const;
    long index( long i )            const;
\end{verbatim}
принимающие индекс элемента и номер элемента соответственно. Для вычисления
расстояния в байтах между ближайшими элементами вдоль заданной оси
используется метод
\begin{verbatim}
    long nb_shift( const indx<D>& I, int axe ) const;
\end{verbatim}
где {\tt I}~--- точка от которой вычисляется смещение к ближайшему соседу
вправо, 
{\tt axe}~--- номер оси по котрой вычисляется смещение (0 для $x$, 1 для $y$ и т.д.), результат можно
использовать для итерирования. Метод реализует периодические граничные условяи
для массива. Вот как может выглядеть код с прямым доступом
для линейной фильтрации $D$-мерного массива типа {\tt T} по близжайшим соседям
\begin{verbatim}
array<D,T> src, tgt;
...
tgt.init( src.N-indx<D>(2) );
double w0 = 1./D; 
double wi = (1.-w0)/(D*2);
long snb[D];
for( int k=0; k<D; k++ ) snb[k] = src.nb_shift(indx<D>(),k);
for( int i=0; i<tgt.N; i++ ){
    int si = src.index( indx<D>(1) + i%tgt.N );
    tgt.get(i*sizeof<T>) = src.get(si)*w0;
    for( int k=0; k<D; k++ ) 
        tgt.get(i*sizeof<T>) += ( src.get(si-snb[k])+src.get(si+snb[k]) )*wi;
}
\end{verbatim}
При этом, перед фильтрацией массив {\tt src} может быть преобразован
произвольным образом.

\subsubsection{Изменение размеров, порядка следования координат и направления
  осей~--- методы {\tt crop, swap} и {\tt flip}}
Для создания копий массивов и сеток с измененными размерами, обеспечивающих доступ к тому же
участку памяти, реализованы методы 
\begin{verbatim}
    array<T,D> array<T,D>::crop(const indx<D>& a, const indx<D>& b, indx<D> istep=indx<D>(1));
    mesh<T,D>  mesh<T,D>:: crop(const indx<D>& a, const indx<D>& b, indx<D> istep=indx<D>(1));
    mesh<T,D>  mesh<T,D>:: crop(const vctr<D>& a, const vctr<D>& b, indx<D> istep=indx<D>(1));
\end{verbatim}
где {\tt a, b}
задают левый нижний и правый верхний углы области для копирования, правая
верхняя границы не включаются. Аргумент {\tt step} определяет скважность
доступа в копии, например для двумерного  массива {\tt array<T,2> A} вызов 
\begin{verbatim}
    array<T,2> B = A.crop( Indx(0,0), Indx(5,7), Indx(2,3) );
\end{verbatim}
создаст копию {\tt B} размерами $3\times3$ элемента, в которой элемент с индексом
$(1,1)$ будет реально соответствовать элементу с индексом $(2,3)$.

Для создания копий массивов и сетоки c измененным порядком следования координат реализованы методы
\begin{verbatim}
    array<T,D> array<T,D>::swap( int i, int j );
     mesh<T,D>  mesh<T,D>::swap( int i, int j );
\end{verbatim}
обменивающие местами координаты {\tt i} и {\tt j}. Например, если рассматривать двумерный
массив как матрицу, то вызов {\tt swap(0,1)} аналогичен траспонированию матрицы.
Следует учитывать, что вызов {\tt swap} ухудшает локальность данных при
традиционном обходе и может приводить к существенному замедлению.

Для создания копий массивов и сеток с измененными направлениями осей реализованы методы 
\begin{verbatim}
    array<T,D> array<T,D>::flip( int i );
     mesh<T,D>  mesh<T,D>::flip( int i );
\end{verbatim}
отражающий массив (сетку) по оси с номером {\tt i}. Например, если рассматривать двумерный
массив как матрицу, то вызов {\tt flip(1)} аналогичен перевороту матрицы вверх
ногами, т.е. нижняя строка становиться верхней, а верхняя нижней.

Описанные функции не приводят к реальному перемещению данных, изменяется лишь
порядок доступа (вычисление смещения относительно начала выделенного участка памяти).

\subsubsection{Изменение типа и размерности --- функции {\tt splice}}
Для создания срезов, обеспечивающих доступ к тому же
участку памяти, но имеющих меньшую размерность и/или обеспечивающих доступ к
некоторым элементам структуры, содержащейся в исходном массиве, используется
внешняя функция {\tt splice}. 

Первый вариант функции {\tt splice<D2>(array<T,D>\&
  A,indx<D> pos )} возвращает массив вида\linebreak {\tt array<T,D2>},
обеспечивающий доступ к тому же участку памяти что и массив {\tt A}. При
этом, размерность {\tt D2} должна быть меньше {\tt D}; тем кооординатам, которые остаются в срезе, в аргументе
{\tt pos} должны соответствовать значения~{\tt-1}; остальные компоненты
аргумента {\tt pos} определяют точку, через которую проходит срез (то есть
в аргументе {\tt pos} должно быть строго {\tt D2} значений {\tt
  -1}). Например, для массива {\tt array<double,3> A} вызов 
\begin{verbatim}
     array<double,2> B = splice<2>( A, Indx(-1,-1,20) );
\end{verbatim}
создаст двумерный срез {\tt B}, проходящий через двадцатые ячейки по оси $z$.

Во втором случае, функция {\tt splice} позволяет изменять не только
размерность массива, но и тип содержащихся в массиве данных. Допустим есть
стуктура 
\begin{verbatim}
     struct cell{ double a, b; int c;}; 
\end{verbatim}
для которой создан массив
{\tt array<cell,2> A;} Тогда, вызов 
\begin{verbatim}
     array<double,1> B = splice<1>( A, Indx(10,-1), &cell::b );
\end{verbatim}
создаст срез {\tt B} в виде одномерного массива развернутого по оси $y$, проходящего
через десятые ячейки по оси $x$, и обеспечивающий доступ к полям {\tt b}
соответствующих ячеек.

В третьем случае, функция {\tt splice} позволяет изменять не только
размерность массива, но и тип содержащихся в массиве данных, причем смещение в
ячейке исходного массива задается пользователем в байтах. Следует с
осторожностью использовать этот вариант фунцкии {\tt splice}, поскольку
неверно вычисленное смещение может привести к непредсказуемым результатам. Допустим есть
стуктура 
\begin{verbatim}
     struct cell{ double a, b; int c[10];}; 
\end{verbatim}
для которой создан массив
{\tt array<cell,2> A;} Тогда, вызов 
\begin{verbatim}
     array<int,1> B = splice<1>( A, Indx(10,-1), int, (int*)(&cell::c)+2 );
\end{verbatim}
создаст срез {\tt B} в виде одномерного массива развернутого по оси $y$, проходящего
через десятые ячейки по оси $x$, и обеспечивающий доступ к полям {\tt c[2]}
соответствующих ячеек. Здесь третье поле используется лишь для указания типа
ячеек создаваемого среза.

Для сеток, метод {\tt crop} и функции {\tt splice} кроме свойств массива дополнительно преобразуют поля {\tt min,
  max}, {\tt step} и копируют содержимое поля {\tt ext\_val} (или его компонент).

Функции {\tt splice} доступны только в {\tt C++}. Для обеспечения доступа к
этим функциям в {\tt Python} необходимо провести их инстацирование, например
указать в хидере обрабатываемом пакетом {\tt SWIG}:
\begin{verbatim}
     inline array<int,2> splice( array<cell,3>& A, indx<3> pos ){ 
          return splice<2>( A, pos, &cell::c ); 
     }
\end{verbatim}
или в {\tt .i} файле добавить строку 
\begin{verbatim}
    %namesapce aiv { %template(splice) splice<2,int,3,cell>; };
\end{verbatim}
По умолчанию, при сборке модулей {\tt arr...}, для визуализации инстанцируются
функции 
{\tt splice<1>}, {\tt splice<2>} и {\tt splice<3>}, соответственно как {\tt
  splice1}, {\tt splice2} и {\tt splice3}, 
позволяющие изменять размерность (но не тип ячейки) массива.

\subsubsection{Преобразование к вектору по младшей координате и обратно~--- функции {\tt pack/unpack}}
Для преобразования массива из элементов типа {\tt T} размерности {\tt D} в
массив c размерностью {\tt D-1} содержащий вектора размерности
{\tt V} элементов типа {\tt T} реализована функция 
\begin{verbatim}
    array<vctr<V,T>,D-1> pack<V>( const array<T,D>& );
\end{verbatim}
Следует с осторожностью применять функцию {\tt pack}. Во первых далеко не
для всякого типа может быть построен вектор {\tt vctr<V,T>}, поскольку тип
{\tt T} должен поддерживать операции сложения, умножения и т.д. Во
вторых упакован может быть лишь массив, элементы которого по младшей из
координат лежат в памяти друг за другом, т.е. невозможно упаковать массив,
полученный в результате среза младшей из координат исходного массива, или
массив, обеспечивающий доступ к некторому полю элементов исходного массива. В
третьих, размер вектора {\tt V} не должен превышать размер пакуемого массива
по младшей из координат. Если какое либо из приведенных выше условий не
выполянется, возбуждается исключение. Если необходимо упаковать массив, не
отвечающий двум последним из приведенных выше условий, его можно скопировать перед упаковкой
при помощи метода {\tt copy()}~--- массив возвращенный методом {\tt copy()}
гарантированно удовлетворяет всем приведенным требованиям. 

Для проверки возможности использования функции {\tt pack} можно использовать
метод 
\begin{verbatim}
   int solid_dims() const;
\end{verbatim}
возвращающий число младших координат массива, по которым данные лежат
непрерывно.
Отчасти помочь (или помешать) может метод 
\begin{verbatim}
    void swap(int i, int j);
\end{verbatim}
обменивающий местами координаты $i$ и $j$.


Напротив, функция 
\begin{verbatim}
    array<T,D+1> unpack( const array<vctr<V,T>,D>& );
\end{verbatim}
применима к любому массиву, поскольку в векторе данные гарантированно лежат в памяти
правильным образом.

Функции {\tt pack/unpack} не приводят к выделению новых участков памяти и
копированию данных, результаты их работы (как и результаты работы метода {\tt
  crop} и функций {\tt splice}) реализуют альтернативный доступ к
ранее выделенным участкам
памяти.


\subsubsection{Мультилинейная интерполяция}
В ряде случаев необходимо построение непрерывной функции на основе сеточных
данных (например при генерации изображения по массиву с малым количеством
точек). Для мультилинейной интерполяции данных массива в {\tt arrayTD.hpp} реализовано семейство функций
\begin{verbatim}
    T interpolate( const array<T,D>& A, const vctr<D>& w, const indx<D>& I );
    R interpolate( const array<T,D>& A, const vctr<D>& w, const indx<D>& I, 
                   R (*f)(const T&) ); 
    R interpolate( const array<T,D>& A, const vctr<D>& w, const indx<D>& I, 
                   base_value_convert<R,T>* conv );
\end{verbatim}
где {\tt I}~--- индекс левого нижнего угла ячейки, образованной значениями
массива в {\tt D} мерном пространстве (всего в худшем случае задействовано
$2^D$ значений), {\tt w}~--- координаты точки в которой рассчитывается
значение внутри ячейки, кооднината (0,0,...) соответствует левому нижнему углу
ячейки, координата (1,1,...) соответствует правому верхнему углу
ячейки. Границами массива считаются крайние точки (с индексами {\tt
  Indx(0,0,...)} и {\tt A.N-Indx(1,1,...)} соответственно. Попытка рассчитать
данные за пределами массива дает непредсказуемые результаты. 

Первая функция {\tt interpolate} производит мультилинейную интерполяцию по значениям,
непосредственно находящимся в массиве. Вторая функция {\tt interpolate} предварительно
преобразует каждое значение к типу {\tt R} при помощи некоторой
пользовательской функции вида 
\begin{verbatim}
    R userfunc( const T& );
\end{verbatim}
 передаваемой через указатель на функциию {\tt f}. 
Третья функция {\tt interpolate} предварительно
преобразует каждое значение к типу {\tt R} при помощи метода {\tt convert}
пользовательского класса, являющего наследником полностью вирутального
параметризованного класса
\begin{verbatim}
	template< class R, class T > class base_value_convert{ 
       public: virtual R convert( const T& )=0; 
   };
\end{verbatim}

Второй и третий варианты позволяют строить непрывные функции с предварительным
преобразованием данных содержащихся в массиве без выделения дополнительной
памяти и копирования. Воторой вариант работает несколько быстрее, третий
вариант безопасней с точки зрения контроля типов при вызове из {\tt Python}.

Следует учитывать, что при интерполяции функции во втором и третьем вариантах
будут вызваться для каждой точки по многу раз, так что с точки зрения
производительности при громоздких вычислениях производимых в функцииях
преобразования оптимальней будет построить новый массив нужного типа и
скопировать туда результаты преобразования, а уже затем производить
интерполяцию.

\subsubsection{Периодические граничные условия}
Периодические граничные условия для сеток и массивов реализуются при помощи
внешних функций
\begin{verbatim}
    indx<D> range_bc<P>( const array<T,D>& A, const indx<D>& I );
    vctr<D> range_bc<P>( const mesh<T,D>&  M, const vctr<D>& V );
  
          T& periodic_bc<P>(       array<T,D>& A, const indx<D>& I );
    const T& periodic_bc<P>( const array<T,D>& A, const indx<D>& I );
          T& periodic_bc<P>(       mesh<T,D>& M,  const indx<D>& I );
    const T& periodic_bc<P>( const mesh<T,D>& M,  const indx<D>& I );
          T& periodic_bc<P>(       mesh<T,D>& M,  const vctr<D>& V );
    const T& periodic_bc<P>( const mesh<T,D>& M,  const vctr<D>& V );
\end{verbatim}
где {\tt P}~--- целое число, полученное как $2^{k_1}+2^{k_2}+...$ для
множества индексов координат $\{k_i\}$ по которым необходимо реализовать
периодические граничные условия. Например для периодические граничных условий
по осям $x$ и $z$ {\tt P}$=2^0+2^2=5$. 


Функции {\tt range\_bc} преобразуют индекс {\tt I} или вектор {\tt V} в
соответствии с размерами массива {\tt A} или сетки {\tt M}.
Например, для массива {\tt A} с размерами
$(10\times 10\times 10)$ и сетки {\tt M} определенной в области {\tt
  M.min=Vctr(2,4,8)}, {\tt M.max=Vctr(22,14,18)} 
\begin{verbatim}
    range_bc<5>( A, Indx(10,15,-5) ) --> Indx(0,15,5)
    range_bc<5>( M, Vctr(25,25,-0.01) ) --> Vctr(5,25,17.9)
\end{verbatim}

Функции {\tt periodoc\_bc} обеспечивают доступ к элементу массива или сетки в
соответствии с аргументом, преобразованным функцией {\tt range\_bc}.

\subsubsection{Выгрузка/загрузка массивов и сеток через потоки {\tt I/Ostream}}
Для эффективной выгрузки/загрузки данных массивов и сеток определены методы 
\begin{verbatim}
    void array::dump( aiv::Ostream& S, const char* head=0 );
    void array::load( aiv::Istream& S, 
                      indx<D> a=indx<D>(), indx<D> b=indx<D>(), 
                      indx<D> step=indx<D>(1), int* pos=0, int D2=D, 
                      int szT=sizeof(T), long shift_in=-1 );

    void mesh::dump( aiv::Ostream& S, const char* head=0 );
    void mesh::load( aiv::Istream& S, 
                     indx<D> a=indx<D>(), indx<D> b=indx<D>(), 
                     indx<D> step=indx<D>(1), int* pos=0, int D2=D,
                     int szT=sizeof(T), long shift_in=-1 );
\end{verbatim}
где {\tt head}~--- необязательный аргумент для записи текстовой
аннотации. Форматы выгрузки сеток и массивов совпадают, пределы и шаг сетки
выгружаются после выгрузки всех данных массива и лежат в конце файла,
т.е. сохраненная сетка может быть прочитана как массив. 

Аргументы {\tt a}, {\tt b}, и {\tt step} задают область читаемого массива и
шаг (аналогично аргументам метода {\tt crop}). 
Если какие то компоненты индекса {\tt b} равны нулю или
больше соотвествующих размеров записанных данных, они
заменяются значениями размеров записанных данных.
Аргументы {\tt pos}, {\tt D2},
{\tt szT} и {\tt shift\_in} задают срез читаемого массива, аналогично функции
{\tt splice}. При этом для осей,
которые читаются в {\tt pos} должны стоять значения -1, {\tt szT} и {\tt D2}
задают размер ячейки и размерность читаемого массива (должны совпадать со
значениями в файле, длина вектора {\tt pos} должна быть равна {\tt
  D2}). Аргумент {\tt shift\_in} задает внутри каждой ячейки в байтах, и
должен быть обязательно задан если {\tt szT!=sizeof(T)}. 

На основе методов {\tt load()} реализованы конструкторы 
\begin{verbatim}
    array( Istream& S, indx<D> a=indx<D>(), indx<D> b=indx<D>(), 
                       indx<D> step=indx<D>(1), int* pos=0, int D2=D, 
                       int szT=sizeof(T), long shift_in=-1 );
    mesh(  Istream& S, indx<D> a=indx<D>(), indx<D> b=indx<D>(), 
                       indx<D> step=indx<D>(1), int* pos=0, int D2=D, 
                       int szT=sizeof(T), long shift_in=-1 );
\end{verbatim}
Если загрузка не удалась, возбуждается исключение.

В файл записываются заголовок, размерность массива, длина ячейки
массива в байтах размер массива, затем следуют данные. Если массив является
срезом, записываются лишь те данные, к которым он обеспечивает доступ. 
При чтении проверяются размерность массива и длина ячейки, если хотя бы один
из этих параметров не совпадает чтение прерывается и возбуждается исключение.
Прочитанный заголовок сохраняется в
поле {\tt head}. Перед чтением данных массив всегда
инициализируется размерами, полученными из файла, т.е. если перед вызовом {\tt
load(...)} массив являлся срезом, то после вызова {\tt load(...)} под данные массива
выделяется отдельный участок памяти. Все вышеизложенное относится и к сеткам.

Для загрузки данных в уже выделенные участки памяти для массивов реализованы
методы 
\begin{verbatim}
    void array::update( const array & A );
    void array::update( aiv::Istream& S, 
                        indx<D> a=indx<D>(), indx<D> b=indx<D>(), 
                        indx<D> step=indx<D>(1), int* pos=0, int D2=D, 
                        int szT=sizeof(T), long shift_in=-1 );
\end{verbatim}
Первый метод копирует данные из массива {\tt A} в массив в области их пересечения.

Второй метод загружает данные из потока и полностью аналогичен методу {\tt
  load(Istream\&,...)}, с единственным отличием~--- инициализация массива не
проводится, данные загружаются в ранее выделенную память. Метод возвращает
размеры прочитанного участка. 
При этом обновляется текстовый заголовок массива.

Например в коде
\begin{verbatim}
struct cell{ int a, b; double c; };
...
    array<cell,3> A(Indx(10,10,10));
...
    A.dump( Ofile("test.arr") );
...
    array<double,2> B; 
    B.update( Ifile("test.arr"), indx<2>(), indx<2>(), indx<2>(1),
              (int[]){-1,5,-1}, 3, sizeof(cell), 2*sizeof(int) );
\end{verbatim}
массив {\tt A} сохраняется в файл {\tt test.arr}, а затем из этого файла
загружается срез проходящий через пятые ячейки массива {\tt A}, причем
загружаются лишь поля {\tt cell::c} типа {\tt double}. Следует с осторожностью
использовать аргумент {\tt shift\_in}, поскольку ошибка может привести к
чтению искаженных данных.

Для просмотра сохраненных ранее массивов в формате {\tt .arr} предназначен
класс \verb'arr_head', предоставляющий следующие поля и методы:
\begin{verbatim}
    const int &D, &szT; // размерность и размер ячейки
    int* const &N;      // вектор размеров длиной D
    char* const &head;  // заголовок 

    void load( Istream& S ); // загрузка из потока
    arr_head( Istream& S );

    ~arr_head();
    arr_head();

    const arr_head& operator = ( const arr_head& H );
    arr_head( const arr_head& H );
\end{verbatim}

\subsubsection{Мапирование массивов}
В ряде случаев может оказаться удобным не загрузка массива с диска, а
мапирование файла, содержащего данные массива, при помощи функции {\tt
  mmap(...)} системной библиотеки {\tt <sys/mman.h>}. В частности, мапирование
обеспечивает более эффективный доступ на чтение к сохраненным ранее данным
большого размера. Для мапирования используются следующие методы класса {\tt array}:
\begin{verbatim}
    void mmap( const indx<D>& AN, const char* fname, long offset, 
               bool write=false, const char* header=0 );
    array( const indx<D>& AN, const char* fname, int offset, 
           bool write=false, const char* header=0 );
    void load( const char* fname, int D2=D, int axe=D-1, 
               int* offset=0, int max=-1, bool write=false );
    array( const char* fname, int D2=D, int axe=D-1, int* offset=0, 
           int max=-1, bool write=false );
\end{verbatim}
Метод {\tt mmap(...)} аналогичен методу {\tt init}, но при его вызове вместо
выделения памяти производится мапирование файла с именем {\tt fname}. Файл не
должен быть сжатым. Аргумент {\tt AN} описывает размеры массива в файле,
аргумент {\tt offset} указывает, насколько данные сдвинуты от начала файла (в
байтах). Необязательный аргумент {\tt write} указывает, в каком режиме должен мапироваться
файл (допустимо ли изменение содержимого файла). Если файл не существует или
мапирование невозможно возбуждается исключение. Следует с осторожностью
применять метод {\tt mmap(...)}~--- никаких проверок на соответствие типов
данных, сдвига и размеров массива не производится, вся ответственность за
корректное задание этих параметров лежит на пользователе. Первый варинт конструктора {\tt
  array(...)} вызывает метод {\tt mmap(...)}. 

Аргумент {\tt header} устанавливает текстовый заголовок массива (поле {\tt
  head}). Под заголовок выделяется буфер необходимой длины, в которую
копируется аргумент.

Метод {\tt load(...)} мапирует файл, сохраненный в файл при помощи метода {\tt
dump(...)}, при этом производится контроль рамерности массива (должен
совпадать с {\tt D2}) и размера ячейки
массива (должен совпадать с {\tt sizeof(T)}). Необязательные аргументы {\tt offset}, {\tt axe} и {\tt max} определяют какая
область сохраненного ранее массива будет мапироваться. Поскольку возможно 
мапирование области, содержащей только непрерывный участок данных, то:
\begin{itemize}
\item по коoрдинатам с индексами меньше {\tt axe} размер мапируемой области должен
совпадать с размером сохраненного массива, поэтому он не задается в аргументах;
\item для координаты {\tt axe}
мапируется участок {\tt offset[0]<=i<max}, при этом {\tt max>=offset[0]}
(иначе возбуждается исключение), если
размер области заранее неизвестен можно указать {\tt max=-1} (интерпретируется как
размер сохраненных данных по соотвествующей координате);
\item для коoрдинатам с индексами больше {\tt axe} сдвиг {\tt offset}
  учитывается, а размер мапируемой области считается равным единице.
\end{itemize}
Метод {\tt load(...)} после анализа аргументов вызывает метод {\tt mmap(...)}.
Второй вариант конструктора {\tt array(...)} вызывает метод {\tt load(...)}.

Мапирование сеток пока не реализовано, в частности по идеологическим
причинам~--- неясно как обеспечить синхронизацию с диском пределов и шага
сетки при мапировании
файла с разрешением на запись.


\subsubsection{Загрузка и сохранение данных в формате {\tt .drp}}
Формат {\tt .drp} и реализующий его класс {\tt Arr3D} были разработаны Вадимом Дмитриевичем Левченко для хранения
трехмерных прямоугольных сеток с ячейками типа {\tt float}. Формат {\tt .drp} является одним из
внутренних стандартов третьего сектора третьего отдела ИПМ им. М.В.Келдыша
РАН. Класс {\tt Arr3D} практически идентичен классу {\tt mesh<float,3>} за
некоторыми косметическими отличиями~--- в {\tt Arr3D} нет поля {\tt ext\_val}
и не реализован оператор доступа по координате, зато координаты ячеек могут
образовывать неравномерную прямоугольную сетку (значения по каждой из координат
хранятся в своем одномерном массиве). 

Для загрузки/выгрузки данных в формате {\tt .drp} модуль {\tt arr2drp.hpp}
предоставляет функции
\begin{verbatim}
indx<3> load_drp( array<T,3> &A, Istream& I, bool re_init=true,
                  indx<3> a=indx<3>(), indx<3> b=indx<3>(), indx<3> n=indx<3>(1) );
indx<3> load_drp( mesh<T,3> &M, Istream& I, bool re_init=true,
                  indx<3> a=indx<3>(), indx<3> b=indx<3>(), indx<3> n=indx<3>(1) );
mesh<float,3> load_drp( Istream& I, indx<3> a=indx<3>(), indx<3> b=indx<3>(), indx<3> n=indx<3>(1) );

void dump_drp( const array<T,3> &A, Ostream& O );
void dump_drp( const mesh<T,3> &M,  Ostream& O );

array<float,3> mmap_drp3( const char* fname, int z_min=0, int z_max=0, bool write=false );
array<float,2> mmap_drp2( const char* fname, int z, int y_min=0, int y_max=0, bool write=false );
array<float,1> mmap_drp1( const char* fname, int z, int y, int x_min=0, int x_max=0, bool write=false );
\end{verbatim}
Должны быть обеспечены преобразования от типа {\tt float} к типу {\tt T} (для
чтения {\tt .drp} файлов) и от типа {\tt T} к типу
{\tt float} (для записи {\tt .drp} файлов).
%При загрузке данных в двумерный массив или сетку от вектора
%размерности {\tt D}, если {\tt D} больше, чем размер загружаемых
%данных по младшей координате, загружается лишь начало вектора которому
%соответствуют данные а конец вектора не изменяется; если {\tt D} меньше, чем размер загружаемых
%данных по младшей координате, загружаеются лишь те данные которые поместятся в
%вектор, а остаток данных пропускается. 

При загрузке массивов значения координат пропускаются. При загрузке сеток на
основе значений сохраненных координат задаются поля сеток {\tt min, step} и
{\tt max} на основе усредненного шага. Если размер массива по какой то из
координат равен единице, минимум и максимум по этой координате примаются как
$x_0\pm\frac 12$ где $x_0$~--- сохраненное значение. При загрузке и выгрузке
координат считается, что координаты соответствуют центрам ячеек сетки.

Поле {\tt re\_init} функции {\tt load\_drp} указывает, нужно ли изменять размеры массива или сетки
куда производится загрузка, если изнчальные размеры не соответствуют размерам
данных. Аргументы {\tt a}, {\tt b} и {\tt n} 
задают при необходимости
область читаемого с диска массива  и
шаг  (см. описание метода {\tt
  array::crop}). Если какие то компоненты индекса {\tt b} равны нулю или
больше соотвествующих размеров записанных данных, они
заменяются значениями размеров записанных данных.

Функция возвращает размер загруженной области. Запрет на изменения размера массива
имеет смысл при загрузке данных в срез некоторого другого массива, например при
сборе общего массива из нескольких разрозненных кусков~--- в этом случае
изменение размеров массива приведет к выделению нового участка памяти под
данные, а не загрузке данных в строго отведенное место выделенного ранее участка.

Фнукции {\tt mmap\_drp1,2,3} мапируют {\tt.drp} область файла {\tt fname},
определяемую аргументами {\tt [x,y,z][\_min|\_max]} и возвращают
массив соотвествующей размерности. Необязательный аргумент {\tt write} определяет режим
мапирования (допустимо ли изменение мапированных данных).

Следует отметить, что в отличии от загрузки массивов из формата {\tt .arr}, где
метод {\tt load} фактически  совмещает возможности методов {\tt crop} и {\tt
  splice}, при загрузке массивов из формата {\tt .drp} возможности метода {\tt splice} не
реализована. Это сделано намеренно, поскольку для формата {\tt .drp} заранее,
на этапе компиляции известно, что размерность сохраненных данных равна
трем. Если необходимо загрузить одно- или двумерный срез, всегда можно
загрузить трехмерный массив с единиными размерами по соответствующим
координатам, и применить к нему стандартный метод {\tt splice}. 

Для просмотра сохраненных ранее массивов в формате {\tt .drp} предназначен
класс \verb'drp_head', предоставляющий следующие поля и методы:
\begin{verbatim}
    const indx<3>& N; // размеры массива
    float* const &X;  // вектор координат по оси X длиной N[0]
    float* const &Y;  // вектор координат по оси Y длиной N[1]
    float* const &Z;  // вектор координат по оси Z длиной N[2]

    void load( Istream& S ); // загрузка из потока
    drp_head(  Istream& S );

    ~drp_head();
    drp_head();

    const drp_head& operator = ( const drp_head& H );
    drp_head( const drp_head& H );
\end{verbatim}


Для работы из {\tt Python} библиотека предоставляет модуль {\tt Arr3D}
содержащий функции {\tt load\_drp} и {\tt dump\_drp}, инстацированные для трехмерных
массивов и сеток для типов {\tt float} и {\tt double}, а так же функцию {\tt mmap\_drp}.

