% -*- mode: LaTeX; coding: utf-8 -*-
\section{Равномерные многомерные прямоугольные (картезианские) сетки --- модуль {\tt mesh}}
\subsection{Общие замечания}
Равномерные прямоугольные сетки реализованы в заголовочном файле
{\tt <aiwlib/mesh>}  в виде параметризованного класса {\tt Mesh<$T$,$D$>}, где $T$~---~тип ячейки массива, $D$~---
размерность массива. 

Многомерные сетки поддерживают настройку осей координат~--- для каждой оси могут быть заданы пределы, шаг
и опционально логарифмический масштаб. Поддерживается обращение к ячейкам сетки как по индексу (номеру по всем осям)
так и по координате, которая пересчитывается в индекс на основе настроек осей.

Многомерная сетка (массив) эмулируется при помощи
одномерного массива, смещение в котором пересчитывается с учетом размеров
многомерной области. Предоставляются средства для организации эффективного обхода содержимого сетки  с учетом локальности данных.

Многомерные сетки {\tt aiw::Mesh} обеспечивают упорядоченный доступ к некоторому участку памяти.
Возможно создание сеток с другими размерами, обеспечивающих доступ
к тому же участку. В частности, конструкторы копирования сеток не
выделяют новых участков памяти под данные~---~копии ссылаются на тот же
участок. Сборка мусора призводится на основе подсчета ссылок.  С одной
стороны это существенно ускоряет копирование объектов, с другой стороны копии не являются
независимыми, т.е. изменение данных в одной копии влечет за собой изменение всех
остальных копий. Для полноценного копирования с выделением нового участка
памяти под данные используется метод {\tt copy()}.

Многомерные сетки допускают проведение ряда преобразований~--- разворот и изменение порядка нумерации осей координат, 
вырезание подобластей, построение срезов и т.д. При этом не происходит копирование данных исходной сетки, а лишь предоставляется 
альтернативный способ доступа к исходным данным, что открывает широкие возможности для манипуляций с данными.

Многомерные сетки обеспечивают запись и чтение данных на диск в бинарном формате (сейчас используется старый 
формат библиотеки {\tt aivlib}) и форматированный вывод данных в текстовом виде для {\tt gnuplot}. 

\subsection{Поля и методы для получения информации о сетке}
Класс {\tt Mesh<$T$,$D$>} содежит следующие открытые поля:
\begin{verbatim}
    std::string head;  // произвольный текстовый заголовок
    T out_value;       // значение (ячейка) за пределами сетки
    aiw::Vec<D> bmin;  // координаты левого нижнего угла области
    aiw::Vec<D> bmax;  // координаты правого верхнего угла области
    aiw::Vec<D> step;  // размер ячейки сетки
    aiw::Vec<D> rstep; // обратный размер ячейки
    int logscale;      // битовая маска отмечающая логарифмические масштабы осей
\end{verbatim}

Класс {\tt Mesh<$T$,$D$>} предоставляет следующие методы для получения информации о состоянии сетки
\begin{verbatim}
    size_t size() const;       // общее число элементов сетки
    aiw::Ind<D> bbox() const;  // размеры сетки по всем осям
    size_t mem_size() const;   // размер области памяти в ячейках
    size_t mem_sizeof() const; // размер ячейки в байтах
\end{verbatim}
Методы \verb'mem_size()' и \verb'mem_sizeof()' выдают информацию об области памяти сетки без учета
проведенных преобразований. 

\subsection{Инициализация сетки и настройка осей}
Для настройки осей сетки предназначен метод
\begin{verbatim}
    void set_axes(const aiw::Vec<D> &bmin, const aiw::Vec<D> &bmax, int logscale=0);
\end{verbatim}
Метод настраивает оси на основе текущих размеров сетки в ячейках.

Для инициализации сетки (выделения памяти) служат методы 
\begin{verbatim}
    void init(const aiw::Ind<D> &box);
    void init(const aiw::Ind<D> &box, 
              const aiw::Vec<D> &bmin, const aiw::Vec<D> &bmax, int logscale=0);
\end{verbatim}
Вторая версия метода \verb'init' производит настройку осей после выделения памяти.
Первая версия метода \verb'init' настраивает оси по умолчанию~--- размеры области от нуля до \verb'box' 
(шаг равен еденице), логарифмического масштаба нет.

Каждый вызов метода \verb'init' приводит к выделению новой области памяти под данные, однако старая область памяти
может оказаться используемой преобразованной сеткой и не обязательно будет освобождена, см. раздел~\ref{mesh:change:sec}

Все настройки осей хранятся в открытых полях \verb'bmin', \verb'bmax', \verb'step',
\verb'rstep' и \verb'logscale'. 
Несогласованное изменение этих полей может привести к некорректному преобразованию координат точки
в индекс ячейки сетки.

\subsection{Доступ к ячейкам и обход сетки}
Сетки обеспечивают доступ к ячейкам по координате (вектору) или индексу (набору номеров ячейки по всем осям).

Базовыми являются методы
\begin{verbatim}
    inline aiw::Ind<D> coord2pos(const aiw::Vec<D> &r) const;
    inline aiw::Vec<D> pos2coord(const aiw::Ind<D> &p) const;
\end{verbatim}
пересчитывающие координаты в индексы и обратно согласно настройкам осей. Метод \verb'pos2coord' возвращает координаты 
центра ячейки. 

Для доступа к ячейкам служат методы
\begin{verbatim}
    inline const T& get(const aiw::Ind<D> &pos) const;
    inline const T& get(const aiw::Vec<D> &r) const;
\end{verbatim}
При включенном режиме отладки (опция \verb'debug=on' утилиты \verb'make' либо опция \verb'-DEBUG' компилятора)
метод доступа по индексу проверяет попадание индекса внутрь сетки, при промахе возбуждается исключение.
При отключенной отладке проверка не происходит, что может приводить при промахе к доступу в неверные ячейки 
либо ошибке сегментирования. При доступе по индексу вычисление адреса ячейки требует $D$ целочисленных умножений и сложений.

Метод доступа по вектору требует дополнительных вычислений для перевода вектора в индекс ячейки. 
При промахе (если вектор попадает за пределы обоасти сетки) обеспечивается доступ к открытому полю сетки \verb'out_value'.

Для традиционного доступа в \verb'C++' перегружены операции 
\begin{verbatim}
    inline const T& operator [] (const aiw::Ind<D> &p) const;
    inline       T& operator [] (const aiw::Ind<D> &p);
    inline const T& operator [] (const aiw::Vec<D> &r) const;
    inline       T& operator [] (const aiw::Vec<D> &r);
\end{verbatim}
вызывающие функции \verb'get', те же операторы перегружены в \verb'Python' как
\begin{verbatim}
    inline const T& __getitem__(const aiw::Ind<D> &p) const;
    inline const T& __getitem__(const aiw::Vec<D> &r) const;
    inline void __setitem__(const aiw::Ind<D> &p, const T& v);
    inline void __setitem__(const aiw::Vec<D> &r, const T& v);
\end{verbatim}

Для реализации доступа с периодическими граничными условиями предназначены методы
\begin{verbatim}
    template<int P> inline const T& periodic_bc(Ind<D> pos) const;
    template<int P> inline T& periodic_bc(Ind<D> pos);
\end{verbatim}
где $P$ --- битовая маска, указывающая по каким осям необходимо создать периодичность.
Например $P=5$ задаст периодические граничные условия по осям $x$ и $z$.
Методы \verb'periodic_bc' корректируют компоненты индекса по тем осям, для которых указаны периодические граничные условия,
и затем вызывают метод \verb'get'.

Для оптимального обхода сетки предназначены методы
\begin{verbatim}
    inline aiw::Ind<D> inbox(size_t offset) const;
    inline aiw::Ind<D> first() const;
    inline bool next(aiw::Ind<D> &pos) const;
\end{verbatim}
Метод \verb'inbox' преобразует номер элемента сетки (от начала области памяти) в его индекс. Для непреобразованной сетки
его результат будет совпадать с результатами операции \verb'offset%bbox()', 
однако для преобразованной сетки это может быть неверно. Метод \verb'inbox' является относительно дорогостоящим,
но обеспечивает оптимальный (с точки зрения локальности данных) порядок обхода сетки и позволяет
легко распараллеливать циклы обходы средствами библиотеки \verb'OpenMP'
\begin{verbatim}
    Mesh<T,D> M;
    ...
    size_t sz = M.size();
#pragma omp parallel for
    for(size_t i=0; i<sz; ++i){
        Ind<D> pos = M.inbox(i);
        ...
    }
\end{verbatim}

Аналогичный порядок обхода (с меньшими накладными расходами, но без такого простого распараллеивания) 
можно получить при помощи конструкции
\begin{verbatim}
    Ind<D> pos=M.first(); 
    do{...} while(M.next(pos));
\end{verbatim}
Для непреобразованных сеток этот обход экивалентен конструкции
\begin{verbatim}
    for(Ind<D> pos; pos^=M.bbox(); ++pos){...} 
\end{verbatim}
но после преобразований такой вариант может оказаться неэффективным.

\subsection{Преобразования сеток}\label{mesh:change:sec}
Для преобразования сеток служат методы
\begin{verbatim}
    Mesh flip(int a, bool axe=true) const;
    Mesh transpose(int a, int b) const;
    Mesh crop(aiw::Ind<D> l, aiw::Ind<D> m, aiw::Ind<D> n=Ind<D>(1)) const;
    template <class T2, int D2> 
        Mesh<T2, D2> slice(Ind<D> pos, size_t offset_in_cell) const;
\end{verbatim}
Все эти методы не приводят к выделению новых областей памяти для данных сетки, а лишь 
создают альтернативные способы доступа к уже выделенной памяти в исходной сетке. 
После создания преобразованной сетки исходная сетка может быть удалена/перенициализирована, однако 
освобождение памяти произойдет лишь после уничтожения/перенициализации всех преобразованных сеток. 
Сборка мусора осуществляется при помощи подсчета ссылок на основе указателя \verb'std::shared_ptr<BaseAlloc>',
исходная сетка и построенные на ее основе преобразованные сетки являются равноправными владельцами выделенной под 
данные памяти.

Метод  \verb'flip(int a, bool axe=true)' разворачивает (отражает) ось $a$, параметр \verb'axe' указывает следует ли 
преобразовать так же настройки оси (пределы и шаг).

Метод \verb'transpose(int a, int b)' меняет оси $a$ и $b$ местами, при этом преобразуются так же настройки осей.

Метод \verb'crop(aiw::Ind<D> l, aiw::Ind<D> m, aiw::Ind<D> n=Ind<D>(1))' вырезает фрагмент сетки
с левым нижним углом в ячейке $\l$, правым верхним углом в ячейке $\m$, правая верхняя граница не включается.
При задании $\l$ и $\m$ допускается использовать отрицательные значения, которые отсчистываются 
от верхней границы (размера сетки) по соответствующей оси. Необязательный параметр $\n$ позволяет задать шаг,
т.е. использовать каждую $\n$--ю ячейку внутри указанной области.

Метод \verb'slice<D2, T2>(Ind<D> pos, size_t offset_in_cell)' позволяет строить срезы~---
уменьшать размерность сетки и изменять тип хранимых данных,
например составляя новую сетку из отдельных полей структуры хранящейся в исходной сетке.

Для уменьшения  размерности необходимо указать в аргументе \verb'pos' значения -1 по тем осям, которые
должны войти в срез (ровно $D_2$ штук), и положение среза по остальным осям.

Для измения типа данных необходимо указать новый тип и сдвиг данных внутри исходной структуры в байтах.
Следует с осторожностью использовать этот вариант вызова метода {\tt slice}, поскольку
неверно вычисленное смещение может привести к непредсказуемым результатам. Допустим есть
стуктура 
\begin{verbatim}
     struct Cell{ double a, b; int c[10];}; 
\end{verbatim}
для которой создана сетка \verb'Mesh<Cell,2> A;' Тогда, вызов 
\begin{verbatim}
     Mesh<int,1> B = A.slice<1, int>(Indx(10,-1), 2*8+2*4);
\end{verbatim}
создаст срез {\tt B} в виде одномерного массива развернутого по оси $y$, проходящего
через десятые ячейки по оси $x$, и обеспечивающий доступ к полям {\tt c[2]}
соответствующих ячеек. 

В настоящий момент метод \verb'slice' недоступен из \verb'Python'-а.

\subsection{Сохранение и загрузка сеток}
Для сохранения и загрузки содержимого сеток в бинарном формате предназначены методы
\begin{verbatim}
    void dump(aiw::IOstream &&S) const;
    void load(aiw::IOstream &&S, int use_mmap=0);
    void dump(aiw::IOstream &S) const;
    void load(aiw::IOstream &S, int use_mmap=0);
\end{verbatim}
В настоящий момент используется старый формат библиотеки \verb'aivlib'. Необязательны параметр \verb'use_mmap' 
указывает на использование мапирования файла, 0~--- не использовать мапирование, 1~--- мапировать файл только на чтение,
2~--- мапировать файл на чтение и запись.

Кроме того перегружены операции \verb'<>' для бинарного ввода/вывода
\begin{verbatim}		
    IOstream& operator < (IOstream &S, const Mesh<T, D> &M);
    IOstream& operator > (IOstream &S,       Mesh<T, D> &M);
\end{verbatim}

Для форматированного вывода (\verb'.dat'--файлы для \verb'gnuplot') предназначены методы
\begin{verbatim}		
    template <typename S> void out2dat(S &&str, bool coords=true) const;
    void out2dat(std::ostream &str, bool coords=true) const;
    void out2dat(IOstream &str, bool coords=true) const;
\end{verbatim}
При выводе используются координаты центров ячеек (при \verb'coords=true') либо номера ячеек.

Для сериализации сеток при помощи модуля \verb'pickle' в \verb'Python' реализованы методы
\begin{verbatim}		
    std::string __getstate__() const; 
    void __C_setstate__(const std::string &state);
\end{verbatim}

		
\subsection{Другие методы}
Для получения копии сетки (с отдельной областью памяти) предназначен метод
\begin{verbatim}		
    Mesh copy() const;
\end{verbatim}
Новая сетка является упорядоченной, в ее память переносятся лишь те данные, к которым обеспечивала доступ исходная сетка.

Для заполнения сетки предназначены методы		
\begin{verbatim}		
    void fill(const T &x);
    template <typename T2> void fill(const Mesh<T2, D> &M);
    void fill(const Mesh &M);
    void fill(aiw::IOstream &&S);
    void fill(aiw::IOstream &S);
\end{verbatim}
Метод \verb'fill(const T &x)' заполняет все яячейки значением $x$.

Метод \verb'fill(const Mesh<T2, D> &M)' копирует в сетку содержимое сетки $M$, при этом должен существовать оператор
приведения типа $T_2$ к $T$. Если размеры (в ячейках) заполняемой сетки и сетки $M$ не совпадают, копируются данные лишь из области пересечения 
сеток.

Метод \verb'fill(aiw::IOstream)' загружает сетку из потока (при этом предполагается что тип данных 
совпадает с заполняемой сеткой), и вызывает метод \verb'fill(const Mesh &M)'.

Метод \verb'min_max(T &a, T &b, aiw::Ind<D> &pos_a, aiw::Ind<D> &pos_b)' находит минимальное $a$ и максимальное $b$
значения в ячейках сетки, а так же их индексы.

\subsection{Инстацирование в {\tt Python}}
Для каждого набора параметров шаблон сетки должен быть инстацирован в питон при помомщи утилиты \verb'make'.
Для этого в директории библиотеки \verb'aiwlib' надо набрать команду
\begin{verbatim}		
    make MeshXXX-T-D
\end{verbatim}
где \verb'MeshXXX'~--- имя инстацируемого шаблона в \verb'Python' (оно же имя модуля содержащего инстацированный шаблон),
\verb'T'~--- тип данных ячейки в \verb'C++', \verb'D'~--- размерность.
 Например команда 
\begin{verbatim}		
    make MeshF3-float-3
\end{verbatim}
создаст модуль \verb'MeshF3' содержащий класс \verb'MeshF3' отвечающий шаблону \verb'Mesh<float,3>'.

