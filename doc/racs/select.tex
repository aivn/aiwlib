\section{Модуль {\sf select.py} --- многопараметрический поиск и комплексная обработка результатов}
Под многопараметрическим поиском понимается создание выборки, т.е. выделение
из всех существующих в обрабатываемом наборе репозитриев расчетов некоторого
множества расчетов, удовлетворяющих условиям поиска. Условия поиска это
выражения, задаваемые пользователем в синтаксисе языка {\sf Python} в виде
строк, вычисляемые функцией {\sf eval}\footnote{Точнее методом {\sf
    \_\_call\_\_(expr)} соотвествующего экземпляра класса {\sf \_RACS}} (см.
\ref{racs:macros}) индивидуально для каждого расчета в локальном пространстве 
словаря параметров расчета и глобальном прострастве имен {\sf
  pickle\_db.\_G}. 

\subsection{Генерация выборки}\label{racs:mkselect:sec}
Модуль {\sf select} содержит класс {\sf SELECT}, реализующий выборку
расчетов. Конструктор класса имеет вид
\begin{verbatim}
    def __init__( self, fromL=['./'], ev_list=[], iscalc = 'statelist!=None', 
                  progressbar=None, go_in_calc='False', chk_tree='False' )
\end{verbatim}
где {\sf fromL}~--- список путей репозиториям, по которым будет вестись поиск
или единственный путь (строка); {\sf ev\_list}~--- список выражений, которые
будут вычисляться для каждого расчета из репозиториев и на основе которорых будет приниамться
решение о включение расчета в выборку; {\sf iscalc}~--- строка, вычисляемая
для каждой поддиректории репозитория и определяющая является ли поддиректория
расчетом (не всякая директория содержащая файл {\sf .RACS} являетс расчетом и
не всякий расчет содержит файл {\sf .RACS}); {\sf progressbar}~--- экземпляр
класса {\sf mixt.progressbar} интерактивно отображающий процесс построения выборки;
{\sf go\_in\_calc}~--- выражение вычисляющееся для каждой поддиректории
репозиториев и показывающее, надо ли заходить внутрь поддиректории если та
является расчетом; {\sf chk\_tree}~--- выражение вычисляющееся для каждой поддиректории
репозиториев и показывающее, надо ли вычислять условяи построения вборки для поддиректорию если она не
является расчетом и соотвественно игнорировать ее содержимое если проверка не удалась.
Таким образом, в процессе многопараметрического поиска существует возможность как рекурсивно
заходить внутрь веток дерева каталогов не соответствующих условиям поиска
(возможно что внутри ветки найдутся расчеты удовлетворяющие критериям поиска),
так и игнорировать их.

Выборка эмулирует список (таблицу), элементами которого могут являться списки
(строки таблицы, одна строка соответствует одному выбранному расчету, каждый
элемент строки это результат вычисления соответствующего выражения для данного
расчета) или значения {\sf None}, интерпретирующиеся как пустая строка (разделитель).


Для компактного задания сортировки и фильтрации синтаксис выражений в {\sf ev\_list} расширен
следующим образом:
\begin{itemize}
\item если выражение начинается с символа \verb|'~'| результаты сортируются
  по возрастанию значения выражения;
\item если выражение начинается с символа \verb|'^'| результаты сортируются
  по убыванию значения выражения;
\item если выражение заканчивается символом \verb|'?'| результаты фильтруются
  по значению выражения (т.е. в списке остаются только те реузльтаты, для
  которых значение данного выражения истинно);
\item если выражение заканчивается символом \verb|'!'| выражение вычисляется
  функцией {\sf exec}, т.е. допускает изменение параметров расчета;
\item если выражение заканчивается символом \verb|'/'|   в выборке остаются
  лишь те расчеты, у которых значение данного выражения отличается от значения
  для предыдущего расчета (аналог функции {\sf DISTINCT} в {\sf SQL});
\item если выражение заканчивается символом \verb|'%'| между расчетами у
  которых значение данного выражения изменяется вставляется разделитель
  (символ {\sf None});
\item если выражение заканчивается символом \verb|'-'| фильтрация, сортировка
  и другие действия с данным выражением будут произведены, но результат
  выражения будет скрыт (соответствующая колонка будет удалена из таблицы);
\item если выражение заканчивается символом \verb|'+'| фильтрация, сортировка
  и другие действия с данным выражением будут произведены, и результат
  выражения будет показан (соответствующая колонка будет оставлена в таблице).
\end{itemize}
Взаимосисключающими являются символы \verb|'~'| и \verb|'^'| вначале
выражения, симоволы \verb|'?!/%'| и символы \verb|'+-'|. Символы \verb|'+-'|
всегда должны находиться в самом конце выражения, т.е. записи
\verb|'EXPR?+'| и \verb|'EXPR-'| корректны, запись \verb|'EXPR-/'| нет. 

Например:
\begin{itemize}
\item \verb|'~a'|~--- отсортировать результаты поиска по возрастанию значений
  параметра $a$;
\item \verb|'^a*b'|~--- отсортировать результаты поиска по убыванию значений
  выражения $a\cdot b$;
\item \verb|'a<10?'|~--- оставить только те результаты поиска, для которых
  выполняется неравенство $a<10$;
\item \verb|'^a*b?'|~--- оставить только те результаты поиска, для которых
  выражение $a\cdot b$ истинно (не равняется нулю, пустой строке, пустому списку,
  словарю или кортежу) и может быть корректно вычислено (в случае
  ошибки результат будет {\sf None}), и отсортировать их по убыванию.
\end{itemize}

По умолчанию, результаты выражений заканчивающихся на символы \verb|'?'| и
\verb|'!'| скрываются. Результат выражения по которому проводилась фильтрация
может быть показан при помомщи симовла \verb|'+'|, результат выражения
вычисленного функцией {\sf exec} всегда равняется {\sf None} и его
демонстрация лишена смысла (хотя и возможна).

Таблица всегда вычисляется построчно, т.е. сначала все выражения вчисляетсю
для первого расчета, затем для второго и т.д. Если по выражению производиться
фильтрация и в результате выичсления выражения было получено {\sf False}
расчет не добавляетс в выборку и остальные выражения для него не
вычисляются. Для уменьшения времени генерации выборки рекомендуется первыми
ставить выражения, по которым производиться фильтрация. 

После вычисления выражений и фильтрации производиться сортировка, затем
удаляются лишние (согласно символу \verb|'%'|) расчеты, затем (согласно
символу \verb|'/'|) вставляются разделители и лишь затем из таблицы убираются
колонки выражений, которые должны быть скрыты. 

В выражениях можно явно ссылаться на параметры из глобального словаря {\sf
  pickle\_db.\_G} как на атрибуты специального объекта {\sf glob}. Например,
после создания в {\sf pickle\_db.\_G} параметра {\sf sum\_a=0} вычисление выражения
\verb|'glob.sum_a+=a!'| для всех расчетов выборки приведет к тому, что
параметр {\sf sum\_a} будет содержать сумму параметров {\sf a} всех расчетов
выборки.\footnote{Если выражение {\sf glob.sum\_a+=a!} указать первым в
  списке выражений, то параметр {\sf sum\_a} будет содержать сумму 
  параметров {\sf a} для всех расчетов, проверенных при создании выборки}  


\subsection{Поля и методы класса {\sf SELECT}}
Класс {\sf SELECT} имеет следующие актуальные поля:
\begin{itemize}
\item {\sf ev\_list}~--- заголовок таблицы (список вычисленных и не скрытых
  выражений), нежелательно изменяеть его руками;
\item {\sf progressbar}~--- экземпляр
класса {\sf mixt.progressbar} интерактивно отображающий процесс построения
выборки;
\item {\sf runtime}~--- время выполнения последней операции над выборкой в
  секундах;
\item {\sf c\_runtime}~--- суммарное время выполнения всех расчетов выборки в
  секундах;
\item {\sf c\_size}~--- суммарный размер всех расчетов выборки в
  байтах;
\item {\sf fromL}~--- список репозиториев по которым проводилась выборка
  (носит чисто информативный характер).
\end{itemize}

Класс {\sf SELECT} имеет следующие методы:
\begin{itemize}
\item {\sf \_\_len\_\_(self)}~--- длина выборки (вместе с разделителями);
\item {\sf \_\_getitem\_\_(self,i)}~--- запись с номером {\sf i} (список
  вычисленных выражений) либо {\sf None} (разделитель);
\item {\sf \_\_delitem\_\_(self,i)}~--- удаляет запись с номером {\sf i} (но
  не разделитель);
\item {\sf \_\_getslice\_\_( self, begin, end )}~--- возвращает экземпляр
  класса {\sf SELECT} содержащий срез выборки (записи с номерами от {\sf
    begin} до  {\sf end});
\item {\sf \_\_delslice\_\_( self, begin, end )}~--- удаляет из выборки срез  (записи с номерами от {\sf
    begin} до  {\sf end});
\item {\sf \_\_call\_\_( self, i )}~--- возвращает экземпляр класса {\sf
  \_RACS} отвечающий записи с номером {\sf i} либо {\sf None} (разделитель);
\item {\sf nodes( self, begin=None, end=None )}~--- возвращает список экземпляров 
класса {\sf \_RACS} для записей с номерами от {\sf
    begin} до  {\sf end}, по умолчанию для всей выборки, без разделителей;
\item {\sf swap\_col( self, i, j )} --- меняет местами столбцы {\sf i} и  {\sf
j};
\item {\sf del\_col( self, begin=None, end=None )} --- удаляет стобцы с номерами от {\sf
    begin} до  {\sf end}, по умолчанию все столбцы, не меняя набор записей;
\item {\sf remove( self, i )} --- удаляет запись с номером {\sf i} из выборки
  и с диска;
\item {\sf remove\_all( self )} --- удаляет все записи из выборки и с диска;
\item {\sf get\_keys\_summary( self )} --- возвращает список всех имен
  параметров, встречающихся в выборке;
\item {\sf get\_values\_summary( self, *patterns )} --- возвращает словарь вида {\sf
  'имя-параметра' : список-значений-параметра-в-выборке} для параметров, имена
  которых удовлетворяют хотя бы одному из шаблонов {\sf patterns};
\item {\sf get\_types\_summary( self )} --- возвращает словарь вида {\sf
  'имя-параметра' : список-типов-значений-параметра-в-выборке};
\item {\sf extend( self, *ev\_list )} --- досчитывает выражения (столбцы)
  для всех записей выборки по описанному выше алгоритму, включая фильтрацию,
  сортировку и т.д.;
\item {\sf commit( self )} --- вызывает метод {\sf commit()} для всех записей выборки;
\item {\sf update( self )} --- вызывает метод {\sf update()} для всех записей выборки.
\end{itemize}



\endinput

\subsection{Локальное вычисление выражений}\label{racs:local:ev}
Под локальным вычислением выражения понимается вычисление выражения в рамках
одного результата поиcка (одной записи~--- одного элемента списка {\sf L} экземпляра класса {\sf racslib.parbase.select}).
То есть при вычислении выражения {\sf code} используется команда 
{\sf Eval(~code,~D,~DD,~[],~self.G~)}. Здесь {\sf D} и {\sf DD}~--- соответствующие
записи в элементе отвечающем данному результату поиска, {\sf self.G}~---
глобальное пространство имен для вычисления выражений экземпляра класса {\sf racslib.parbase.select}
созданное копированием словаря {\sf \_G}. Пользователь может добавлять свои
параметры (обычные и функциональные) в словарь {\sf self.G}.

Для локального вычисления выражений используется метод 
{\sf local\_ev(~self,~*eval\_list~)} класса {\sf racslib.parbase.select}, где {\sf eval\_list}
список выражений для вычисления, каждое выражение должно быть строкой с
синтаксисом языка {\sf Python}, допускается использование
расширенного синтаксиса, описанного в разделе \ref{racs:eval:res}.

Выражения вычисляются в том же порядке, в котором они указаны в {\sf
  eval\_list} внутри цикла по записям. Фильтрация производится сразу после
вычисления выражения. Сортировка  производится
после вычисления всех выражений для всех записей (и соответственно после фильтрации).

Метод {\sf local\_ev(...)} может вызываться многократно.
Реузльтаты вычисления выражений накапливаются в списке {\sf L} класса {\sf
  racslib.parbase.select}, и могут быть получены при вызове метода {\sf
  results(self)} в виде списка списков {\sf [~[~r1,~r2,~...~]~]}, где каждый
вложенный список соответствует одному результату поиска, а элементы {\sf
  r1,~r2,~...} 
соответствуют вычисленным выражениям из списков {\sf eval\_list},
объединенным в порядке вызовов {\sf local\_ev}.  
При этом список {\sf L} очищается от результатов.

%set
Для модификации записей и словаря {\sf self.G} в процессе вычисления выражений
используется функция {\sf set(~index=None,~sync=False,~**d~)}, где {\sf index}~--- индекс (номер)
записи в выборке (списке {\sf self.L}), {\sf sync}~---
параметр указывающий на необходимость вносить изменения в файл {\sf .RACS}
(изменения вносятся в соответствующий объект в памяти и сохраняются на диск при
синхронизации изменений). 
Номер текущей записи задается в
параметре {\sf i} локального пространства имен {\sf DD}.
Так как индексация соседних записей при локальном вычислении запрещена, индекс
должен иметь значения {\sf i} (текущая запись) или {\sf None} (глобальный
словарь {\sf self.G}), иначе будет возбуждено исключение 
{\sf IndexError:~index~out~of~sequence~[i,None]}. 
Так как запись в базу параметра из глобального словаря невозможна, во втором случае аргумент {\sf sync} игнорируется (строго должен быть равен {\sf
  False}).%???
Функция возвращает {\sf d.values()[0]}, то есть при
задании более чем одного устанавливаемого значения результат неопределен
(поскольку неизвестен порядок следования значений в словаре, результатом будет
являться одно из устанавливаемых значаний, но какое именно неизвестно).

\subsection{Нелокальное вычисление выражений}\label{racs:nolocal:ev}
Под нелокальным вычислением выражения понимается вычисление выражения в рамках
всей выборки (списка результатов). При этом вычисляемое в рамках одной записи
(одного результата поиска) выражение может адресовываться к
значениям параметров в других записях, что позволяет проводить численное
дифференцирование, сглаживание, поиск локальных экстремумов и т.д. При
нелокальном вычислении выражений имеет существенное значение порядок следования
записей в выборке.

Для нелокального вычисления выражений используется метод 
{\sf global\_ev(~self,~*eval\_list~)} 
класса {\sf racslib.parbase.select}, где {\sf eval\_list}
список выражений для вычисления, каждое выражение должно быть строкой c
синтаксисом языка {\sf Python}, допускается использование
расширенного синтаксиса, описанного в разделе \ref{racs:eval:res}.

Метод {\sf global\_ev} работает медленнее чем {\sf local\_ev}. Во первых, цикл
по записям находится внутри цикла по выражениям, т.е. сначала первое
выражение вычисляется для всех записей, затем при необходимости по его результатам
производится сортировка и фильтрация, затем вычисляется второе выражение и
т.д. Во вторых, при вычислении каждого выражения внутри одной записи заново
создается локальное пространство имен {\sf DD} на основе словаря {\sf D}
(см. раздел \ref{racs:macros})  и
производятся  некоторые манипуляции над словарем {\sf self.G}.

Для записи нелокальных выражений используется функция 
{\sf get(~'ev',~index~)}, где {\sf 'ev'} строка с выражением, {\sf index}~--- индекс (номер)
записи в выборке (списке {\sf self.L}). Номер текущей записи задается в
параметре {\sf i} локального пространства имен {\sf DD}, длина списка {\sf
  self.L} в параметре {\sf LEN} словаря {\sf self.G}. 

Для модификации записей и словаря {\sf self.G} в процессе вычисления выражений
используется функция 
{\sf set(~indx=None,~sync=False,~**d~)}, где {\sf indx}~--- индекс записи (аналогичный индексу в функции {\sf get}), {\sf sync}~---
параметр указывающий на необходимость вносить изменения в файл {\sf .RACS}
(изменения вносятся в соответствующий объект в памяти и сохраняются на диск при
синхронизации изменений). Функция возвращает {\sf d.values()[0]}, то есть при
задании более чем одного устанавливаемого значения результат неопределен
(поскольку неизвестен порядок следования значений в словаре, результатом будет
являться одно из устанавливаемых значений, но какое именно неизвестно).

%примеры
%описание класса select

\subsection{Однократно вычисляемые функциональные параметры}
В ряде случаев бывает необходимо использовать при поиске или при обработке
результатов поиска значение функционального параметра, вычисление
которого требует больших затрат, но который может быть вычислен однократно (например зависит лишь от набора файлов в
директории расчета). При этом имеет смысл сохранить однажды вычисленное
значение функционального параметра в виде обычного одноименного параметра, что
бы при следующем запросе избежать повторных вычислений.

В этом случае при поиске разумно было бы использовать следующую конструкцию
{\sf set(~i,~True,~mypar=mypar~)}~--- значение справа от знака равенства
будет вычислено функцией {\sf Eval} (и при необходимости будет вычислен функциональный параметр)
и сохранено в базу. Для этого, вначале поиска в словарь {\sf G} (см. раздел
\ref{racs:macros}) добавляется функция {\sf set(~indx,~sync,~**d~)},
аналогичная функции {\sf set} из раздела \ref{racs:local:ev}, так как
выборка на момент поиска не сфрмирована, первый аргумент должен
быть либо {\sf i} (текущая запись) либо {\sf None} (глобальный словарь {\sf
  self.G}). Так как запись в базу параметра из глобального словаря невозможна, во
втором случае аргумент {\sf sync} игнорируется (строго должен быть равен {\sf
  False}).%???
