\section{Структура данных}
Как правило расчет запускается из текущей (рабочей) директории,
содержащей исходные коды, головные исполняемые файлы на {\tt Python}-е или \verb'C++' и т.д. 
Для каждого расчета должна быть создана уникальная директория, в которой будут
храниться параметры расчета, исходные коды и результаты. 

Директория создается в репозитории, который по умолчанию
имеет имя {\tt repo/}. 
Название уникальной директории расчета формируется из
года, номера недели, дня недели и некоторого трехзначного порядкового номера
уникального для данной даты~--- таким образом расчеты внутри
репозитория автоматически
упорядочиваются по дате (например {\tt
  c18\_00\_1005}~--- пятый расчет проведенный в понедельник первой недели 2018
года). При создании уникальной директории расчета,  в текущей директории 
на нее автоматически создается ссылка {\tt '\_'} (одиночный символ подчеркивания).

Набор параметров расчета образует словарь, который сохраняется 
в файле \verb'.RACS' уникальной директории расчета, в формате стандартного модуля \verb'pickle'
языка \verb'Python'. 
Для служебных целей системой {\tt RACS} в каждом расчете автоматически резервируются
следующие параметры:
\begin{itemize}
\item {\tt args} --- аргументы командной строки при запуске расчета (копия
  списка {\tt sys.argv});
\item {\tt runtime} --- время выполнения расчета (экземпляр класса \verb'aiwlib.chrono.Time');
\item {\tt progress} --- степень выполнения расчета (число от нуля до
  единицы, устанавливается пользователем в процессе расчета);
\item {\tt statelist} --- список состояний расчета;
\item {\tt tags} --- множество (экземпляр класса \verb'set') тэгов расчета.
\end{itemize}

Расчет может иметь одно из следующих состояний:
\begin{itemize}
%\item {\tt waited} --- расчет ожидает запуска;
%\item {\tt activated} --- расчет активирован для запуска;
\item {\tt started} --- расчет запущен;
%\item {\tt suspended} --- расчет временно приостановлен;
\item {\tt finished} --- расчет успешно завершен;
\item {\tt stopped} --- расчет завершен с ошибкой.
\end{itemize}

%Состояния расчета изменяются в процессе проведения расчета по схеме,
%представленной на рис. \ref{states:pict}.
Каждое новое состояние расчета добавляется в список {\tt
  statelist}, текущее состояние определяется на основе последнего элемента
списка. 
Каждое состояние (элемент списка {\tt statelist}) представляется кортежем вида\\[2mm]
\verb'( state, user, host, date [,info] )'\\[2mm]
где {\tt state} --- состояние расчета, {\tt user}~--- пользователь
установивший состояние, {\tt host}~--- хост с которого было установлено
состояние, {\tt date}~--- дата (экземпляр класса \verb'aiwlib.chrono.Date') 
установки состояния, {\tt info}~--- необязательная дополнительная
информация.
В частности, для состояния {\tt started} в конец кортежа дописывается {\tt PID}
расчета. Для состояния {\tt stopped} в конец кортежа дописывается отчет об
ошибке (список строк), приведшей к остановке. Отчет генерируется функцией {\tt
except\_report} модуля {\tt mixt.py} и содержит стек исключения.

При непосредственном запуске расчета, расчет получает состояние {\tt
  started}.
Такой подход позволяет проследить историю любого расчета, что играет
большую роль для диагностики.

Тэги расчета воспринимаются при построении выборки как одноименные параметры расчета имеющие значение \verb'True'. 

Кроме файла \verb'.RACS' в уникальной директории расчета могут создаваться файлы \verb'.src.tgz' (архив с исходным кодом приложения выполнявшего расчет)
и в случае <<демонизации>> расчета \verb'logfile' (объединенные стандартный вывод и стандартный поток ошибок).

В репозитории при анализе результатов создается файл \verb'.RACS-CACHE',
содержащий информацию из файлов \verb'.RACS' для всех расчетов репозитория. Кэш предназначен
для ускорения построения выборок и поддерживается в актуальном состоянии автоматически.

Репозиторий может быть структурирован произвольным образом, т.е. являться деревом директорий,
в котором расчеты группируются согласно требованиям пользователя (например на основе значений ключевых параметров).

Отдельные расчеты и репозитории могут перемещаться средствами операционной системы, пересылаться по сети и т.д.
