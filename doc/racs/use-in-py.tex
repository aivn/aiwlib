\section{Подключение системы {\tt RACS} к готовому приложению численного моделирования на языке {\tt Python}}
Для подключения системы \verb'RACS' к готовому приложения на языке \verb'Python' необходимо как минимум проимпортировать
модуль \verb'aiwlib.racs' и создать экземпляр класса \verb'aiwlib.racs.Calc':
\begin{verbatim}
  from aiwlib.racs import *
  calc = Calc()
\end{verbatim}
Аргументы конструктора класса \verb'Calc' являются параметрами расчета по умолчанию, их значения могут быть перекрыты при
помощи аргументов командной строки при запуске расчета либо при серийном запуске. Кроме того, некоторые аргументы могут
играть служебную роль (показаны значения по умолчанию):
\begin{itemize}
\item\verb'_repo="repo"' ---  задает путь к репозитрию для создания расчета;
\item\verb'path' --- (строка) явно задает путь к директории расчета, если расчет сущестовал 
  словарь расчета будет обновлен из директории расчета;
\item\verb'_clean_path=True' ---   требует очищать явно заданную директорию расчета, при этом
  словарь расчета не обновляется из директории;
\item\verb'_symlink=True' --- создавать символическую ссылку \verb'_' на последнюю 
  директорию расчета;
\item\verb'_daemonize=False' --- <<демонизировать>> расчет при запуске (освободить терминал, 
  вывод будет перенаправлен в \verb'logfile' в директории расчета),
  <<демонизация>> происходит при создание экземпляра класса \verb'Calc';
\item\verb'_statechecker=true' --- запускать демона, фиксирующего  в файле \verb'.RACS' аварийное
  завершение расчета;
\item\verb'_copies=1' --- число копий процесса при проведении расчетов с серийными 
  параметрами;
\item\verb'_on_exit=True' --- по завершении расчета автоматически фиксировать время работы,
  состояние расчета и сохранять измения параметров на диск;
\item\verb'_calc_num=3' --- число знаков в номере расчета (в текущем дне) при 
  автоматической генерации имени директории расчета;
\item\verb'_auto_pull=True' --- автоматически сохранять все параметры расчета из 
  контролируемых расчетом объектов;
\item\verb'_commit_sources=True' --- сохранять исходные коды расчета.
\end{itemize}
Все перечисленные аргументы конструктора класса \verb'Calc' (кроме аргумента \verb'path') не
будут являться полями экземпляра класса.

Уникальная директория расчета создается автоматически при первом обращении к полю \verb'path' экземпляра класса \verb'Calc'. 
При этом название репозитория формируется при помощи форматирования аргумента \verb'_repo' (строки) по экземпляру класса \verb'Calc'
(выступающего в роли словаря). Это позволяет автоматически распределять расчеты по различным репозиториям на основе значений
ключевых параметров, например если было указано
\begin{verbatim}
  calc = Calc(_repo='repo-a%(a)s')
\end{verbatim}
в зависимости от значения параметра \verb'a' расчеты будут помещаться в репозитории \verb'repo-a1',
\verb'repo-a2.5', и т.д.

В файл \verb'.RACS' сохраняется содержимое объекта \verb'calc',
необходимо обеспечить перенос значений параметров из \verb'calc' в объекты использующиеся в расчете и обратно.
Для этого существует по крайней мере три возможности:
\begin{enumerate}
\item непосредственные чтение и запись полей объекта \verb'calc';
\item методы \verb'calc.push(...)' и \verb'calc.pull(...)';
\item метод \verb'calc.wrap(...)' реализующий технологию <<monkey patch>>.
\end{enumerate}

Первый вариант хорошо подходит для каких то ключевых параметров~--- максимального времени счета,
выбора типа численной схемы и т.д., например:
\begin{verbatim}
  while model.t<calc.t_max:
    if calc.scheme==1: model.euler() # схема Эйлера
    if calc.scheme==2: model.RK2()   # схема Рунге--Кутты второго порядка
\end{verbatim}

Второй вариант хорошо подходит для задания и сохранения целой группы параметров, относящихся к экземпляру какого--либо класса,
в том числе \verb'C++'--класса импортированного при помощи утилиты \verb'SWIG':
\begin{verbatim}
    def push(self, X, ignore_list=[], _prefix='', **kw_args):
        '''устанавливает аттрибуты объекта X согласно объекту расчета, 
        параметры расчета имеют более высокий приоритет, чем параметры kw_args'''
    def pull(self, X, ignore_list=[], _prefix='', **kw_args):
        '''устанавливает аттрибуты объекта расчета согласно объекту X, 
        параметры kw_args имеют более высокий приоритет, чем параметры расчета
        автоматически устанавливаются аттрибуты имеющие методы __get/setstate__ 
        (но не имеющие аттрибута _racs_pull_lock) или не-являющиеся объектами swig'''
\end{verbatim}

Третий вариант требует минимальной модификации кода, но может показаться безумным.
Пусть для проведения расчета используется экземпляр \verb'C++'--класса \verb'Model' 
импортированного при помощи утилиты \verb'SWIG'\footnote{Комментарии в виде {\tt \#@} необходимы лишь для того, что бы соответствующие строчки выводились
  в автоматически генерирующейся справке при запуске с ключем {\tt -h} или {\tt --help}}:
\begin{verbatim}
  ...
  model = Model()
  model.h = .1       #@ шаг по времени
  model.N = 1000     #@ размер сетки
  model.omega = 1e-3 #@ частота 
  ...
\end{verbatim}
Тогда достаточно в коде модифицировать всего одну строчку
\begin{verbatim}
  ...
  model = calc.wrap(Model()) # <== инициализация monkey patch
  model.tau = 0.1    #@ шаг по времени
  model.N = 1000     #@ размер сетки
  model.omega = 1e-3 #@ частота 
  ...
\end{verbatim}
При этом переменная \verb'model' будет ссылаться на объект специального вида,
содержащий экземпляр класса \verb'Model' и связанный с объектом \verb'calc'.
задание параметров такого объекта будет трактоваться как задание параметров по умолчанию,
значения которых может быть перекрыто при помощи аргументов командной строки или при серийном запуске.
например, если указать в аргументах командной строки 
\begin{verbatim}
  ./run.py ... tau=0.01 ...
\end{verbatim}
то в строке
\begin{verbatim}
  model.tau = 0.1    #@ шаг по времени
\end{verbatim}
параметру \verb'tau' будет на самом деле присвоено значение $0.01$.
Такой патч возможен лишь один раз для каждого параметра за все время расчета, дальше
код работает ожидаемым образом.

Метод \verb'wrap' может вызываться произвольное количество раз для различных объектов.
Во избежании конфликтов имен параметров,
метод \verb'wrap' принимает вторым необязательным аргументом префикс, который нужно будет добавлять к именам параметров в командной строке.   

Объекты, подключенные к \verb'calc' при помощи  метода \verb'wrap' автоматически опрашиваются при помощи метода \verb'pull'
при записи содержимого объекта \verb'calc' на диск (вызове метода \verb'commit'). 

Методы \verb'push/pull' и технология <<monkey patch>> автоматически приводят типы аргументов, заданных в командной строке,
к типам аргументов контролируемого объекта.

Еще одним полезным методом объекта \verb'calc' является метод
\begin{verbatim}
  set_progress(self, progress, prompt='',  runtime=-1)
\end{verbatim}
устанавливающий степень завершенности расчета (число от $0.$ до $1.$). При его вызове 
устанавливаются атрибуты \verb'progress' и \verb'runtime' объекта \verb'calc', 
а так же соответствующие им значения в файле \verb'.RACS' (если файл \verb'.RACS' отсутствует, вызывается метод \verb'commit').

Если приглашение \verb'prompt' не пустое, создается экземпляр класса \verb'aiwlib.mixt.ProgressBar',
отображающий при помощи \verb'ASCII'--графики диаграмму степени завершения расчета, время прошедшее с момента старта и
ориентировочное время до окончания расчета. Для длинных расчетов настоятельно рекомендуется вызывать метод \verb'set_progress(...)'.

При успешном завершении расчета  автоматически устанавливается \verb'calc.progress=1', фиксируется время выполнения \verb'runtime',
состояние расчета изменяется на \verb'finished'. В случае возникновения исключения
фиксируется время выполнения \verb'runtime',
состояние расчета изменяется на \verb'stopped', при этом в \verb'calc.statelist' дописывается стек исключения и сообщение об ошибке.
Все объекты, находившиеся подключенные к \verb'calc' опрашиваются при помощи метода \verb'pull', вызывается метод \verb'calc.commit()'.
Однако, если в течении расчета не было ни одного обращения к полю \verb'calc.path',
уникальная директория расчета не создается и эти действия {\bf не} выполняются~--- если расчет не сохранил никакие данные в
свою уникальную директорию то она ему не нужна, и видимо не требуется метаинформация (файл \verb'.RACS'). 

