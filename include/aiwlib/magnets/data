// -*- C++ -*-
#ifndef AIW_MAGNETS_DATA_HPP
#define AIW_MAGNETS_DATA_HPP

/**
 * Copyright (C) 2016-17 Antov V. Ivanov, KIAM RAS, Moscow.
 * This code is released under the GPL2 (GNU GENERAL PUBLIC LICENSE Version 2, June 1991)
 **/

#include <functional>
#include <vector>
#include <string>
#include "../iostream"
#include "../geometry"
#include "../vec"
#include "initcond"
#include "lattice"

namespace aiw{
	//--------------------------------------------------------------------------
	class MagnData{
		//----------------------------------------------------------------------
		struct lattice_t{ // кристаллическая решетка
			std::vector<MagnSubLattice> sublats; // подрешетки
			Vecf<3> step;     // размеры ячейки		
			Ind<3>  tile_sz;  // размеры tile в ячейках
			Vecf<3> base_r;   // координаты левого нижнего угла ячейки (0,0,0) в глобальной системе координат
			Vecf<3> orts[3];  // повороты (преобразования) осей координат из локальной в глобальную сист.координат

			inline uint32_t pos2idx(const Ind<3> &pos, uint32_t sl, uint32_t stage) const { 
				return pos[0] + tile_sz[0]*(pos[1] + tile_sz[1]*(pos[2] + tile_sz[2]*(sl+sublats.size()*stage)));
			}
			inline Vecf<3> coord(const Vecf<3> &r) const { return base_r + vecf(r&orts[0], r&orts[1], r&orts[2]); }
		};
		//----------------------------------------------------------------------
		struct app_link_t{ // дополнительная обменная связь на интерфейсе, 16 байт
			uint32_t src, dst; // номер атома в tile (внутри одной стадии!!!)
			int tile;  // смещение относительно текущего tile
			float J;   // обменный интеграл
			BINARYIO4POD;
		};
		struct app_DM_link_t: public app_link_t { Vecf<3> D; BINARYIO4POD; };  // обмен Дзялошинского-Мориа, 28 байт
		struct app_H_t{ uint32_t src; Vecf<3> H; 			BINARYIO4POD; };  // дополнительное поле, 16 байт
		//----------------------------------------------------------------------
		// tile-ы всех решеток лежат в общем массиве
		struct tile_t{
			static const int tile_off = ~(1<<31);
			lattice_t *plat; // кристаллическая решетка к которой относится tile
			int nb[27];  // соседние tile-ы (смещение от this), tile_off если соседа нету, в центре [13] всегда 0
			char *data;  // указатель на массивы магнитных моментов, по подрешеткам (лежат друг за другом)
			std::vector<bool> usage; // таблица активности атомов (дискретная геометрия), непуст только для граничных tile-ов
			Vecf<3> base_r; // координаты левого нижнего угла в системе связанной с решеткой
			uint32_t magn_count; // число активных атомов в tile

			std::vector<app_link_t> app_links;       // дополнительные связи
			std::vector<app_DM_link_t> app_dm_links; // дополнительные связи
			std::vector<app_H_t> app_H;              // дополнительные поля

			inline bool check(const Ind<3> &pos, uint32_t sl) const {
				return usage.empty() || usage[plat->pos2idx(pos, sl, 0)];
			}
			inline Vecf<3> coord(const Ind<3> &pos, uint32_t sl) const { 
				return plat->coord(base_r + ((pos+plat->sublats[sl].coord)&plat->step)); 
			}
			inline Vecf<3> center() const { // центр tile
				return plat->coord(base_r + (plat->tile_sz&plat->step)*.5); 
			}

			// тип С должен иметь оператор приведения к Vecf<3> и оператор присваивания от Vecf<3>
			template<typename C> inline const C& m(const Ind<3> &pos, uint32_t sl, uint32_t stage) const{
				return ((C const*)data)[plat->pos2idx(pos, sl, stage)];
			}
			template<typename C> inline C& m(const Ind<3> &pos, uint32_t sl, uint32_t stage){
				return ((C*)data)[plat->pos2idx(pos, sl, stage)];
			}
			template<typename C> inline Vecf<3> Hexch(const Ind<3> &pos, uint32_t sl, uint32_t stage, 
													  Vec<3, uint32_t> &app) const {				
				uint32_t mID = plat->pos2idx(pos, sl, stage);			
				Vecf<3> m = ((C*)data)[mID];
				auto links = plat->sublats[sl].links;
				Vecf<3> H;
				for(auto i=links.begin(); i!=links.end(); ++i){
					Ind<3> pos2 = pos+i->offset; int gID = 13, mul = 1;
					for(int k=0; k<3; k++){ // коррекция pos2 и определения номера соседнего tile
						if(pos2[k]<0){ gID -= mul; pos2[k] += plat->tile_sz[k]; }
						else if(pos2[k]>=plat->tile_sz[k]){ gID += mul; pos2[k] -= plat->tile_sz[k]; }
						mul *= 3;
					}
					const tile_t *gr2 = nb[gID]==tile_off?nullptr:this+nb[gID];
					if(gr2) H += Vecf<3>((C*)(gr2->data[gr2->plat->pos2idx(pos2, i->sl, stage)]))*m*i->J;
				}
				while(app[0]<app_links.size() && app_links[app[0]].src<mID) ++app[0];
				while(app[0]<app_links.size() && app_links[app[0]].src==mID){ 
					auto l = app_links[app[0]++];
					H += Vecf<3>((C*)((this+l.tile)->data)[l.dst])*m*l.J;
				}
				while(app[1]<app_dm_links.size() && app_dm_links[app[1]].src<mID) ++app[1];
				while(app[1]<app_dm_links.size() && app_dm_links[app[1]].src==mID){ 
					auto l = app_dm_links[app[1]++]; Vecf<3> m2 = (C*)((this+l.tile)->data)[l.dst];
					H += m2*m*l.J + m2%l.D;
				}
				return H; 
			}
			inline Vecf<3> Hstat(const Ind<3> &pos, uint32_t sl, Vec<3, uint32_t> &app) const {				
				uint32_t mID = plat->pos2idx(pos, sl, 0);			
				Vecf<3> H;
				while(app[2]<app_H.size() && app_H[app[2]].src<mID) ++app[2]; 
				while(app[2]<app_H.size() && app_H[app[2]].src==mID) H += app_H[app[2]++].H; 
				return H; 
			}
		};		
		//----------------------------------------------------------------------
		std::vector<lattice_t> lats;
		std::vector<tile_t> tiles;
		char *data;
		size_t szT, Nstages, magn_count; // размер типа, число стадий и число актуальных магнитных моментов
	public:
		MagnData(int Nlats=0): lats(Nlats), data(nullptr), szT(0), Nstages(0), magn_count(0) {}
		~MagnData(){ delete [] data; }
		
		std::string head;
		Vecf<3> Hext; // внешнее поле
		float time;  // время
		// float T;     // температура
		
		// настройка подрешеток
		void set_sublattice_sz(int lat, int sz){ lats[lat].sublats.resize(sz); }
		int  get_sublattice_sz(int lat) const { return lats[lat].sublats.size(); }
		MagnSubLattice& get_sublattice(int lat, int sl){ return lats[lat].sublats[sl]; } 

		// создает tile-ы и инициализирует ссылки на соседей
		void set_geometry(int lat, Figure fig,  
						  int periodic_bc_mask, // ??? отдельный метод инициализации, либо явно задавать размеры коробки для ПГУ ???
						  Vecf<3> step,  // размеры ячейки		
						  Ind<3>  tile_sz,  // размеры tile в ячейках
						  Vecf<3> base_r,   // координаты левого нижнего угла ячейки (0,0,0) в глобальной системе координат
						  Vecf<3> ort_x, Vecf<3> ort_y); // ort_z = ort_x%ort_y
		void set_interface1(int lat1, int sl_mask1, int lat2, int sl_mask2, float max_link_len, 
							std::function<void(Vecf<3>, float&, Vecf<3>&)> app_func=0);
		void set_interface2(int lat1, int sl_mask1, int lat2, int sl_mask2, float max_link_len, 
							std::function<void(Vecf<3>, float&, Vecf<3>&)> app_func=0);
		void set_app_H(int lat, int sl_mask, std::function<Vecf<3>(Vecf<3>)> app_func);
		
		void mem_init(size_t szT, size_t Nstages_=1); 

		void magn_init(int lat, int sl_mask, MagnBaseIC& IC, std::function<void(Vecf<3>, char*)> conv=0, int stage=0);
		
		void dump_head(aiw::IOstream &) const;
		void dump_data(aiw::IOstream &, bool pack, std::function<void(const char*, Vecf<3>&)> conv=0, int stage=0) const;
		void load_head(aiw::IOstream &, size_t szT_=12, size_t Nstages_=1);
		// stage=-1 --- загружать данные в стадию задаваемую из файла
		void load_data(aiw::IOstream &, std::function<void(const Vecf<3>&, char*)> conv=0, int stage=0);

		void get_coords(int lat, int sl, std::vector<Vecf<3> >&) const;
		void get_links(std::vector<Vec<2, uint64_t> >&) const; //только для всех магнитных моментов ???
		void get_magns(int lat, int sl, std::vector<Vecf<3> >&, 
					   std::function<void(const char*, Vecf<3>&)> conv=0, int stage=0) const;
		void get_pack_magns(int lat, int sl, std::vector<uint16_t>&, 
							std::function<void(const char*, uint16_t&)> conv=0, int stage=0) const;

#ifndef SWIG
		// запуcкать для отдельных решеток и подрешеток???
		// f(C &m, const Vecf<3> &Hstat, const MagnSubLattice &SL, const Vecf<3> &Hexch, C mm[32]);
		template <typename C, int src=0, int dst=0, int L=32> 
		void foreach(std::function<void(C&, const Vecf<3>&, const MagnSubLattice&, const Vecf<3>&, C*)> &func, 
					 int exch, int stage, Ind<L> lats_mask=Ind<L>(-1)){
			if(src&dst) WRAISE("incorrect masks", exch, src, dst, stage); // защита от дурака???
			int Nt = tiles.size();
#pragma omp parallel for
			for(int it=0; it<Nt; ++it){ // цикл по tile-ам
				C mm[32];
				tile_t &tile = tiles[it];
				const lattice_t &lat = *(tile.plat);
				int lat_mask = lats_mask[&lat-&(lats[0])];
				Vec<3, uint32_t> app;
				for(uint32_t sl=0; sl<lat.sublats.size(); ++sl){ // цикл по подрешеткам
					if(!(lat_mask&(1<<sl))) continue;
					for(Ind<3> pos; pos^=lat.tile_sz; ++pos){ // цикл по атомам
						C &m = tile.m<C>(pos, sl, stage);
						if(!m) continue;
						Vecf<3> Hstat = Hext + tile.Hstat(pos, sl, app);
						Vecf<3> Hexch; if(exch>=0) Hexch = tile.Hexch<C>(pos, sl, exch, app);
						for(int i=0; i<32; i++) if(src&(1<<i)) mm[i] = tile.m<C>(pos, sl, i);
						func(m, Hstat, lat.sublats[sl], Hexch, mm);
						for(int i=0; i<32; i++) if(dst&(1<<i)) tile.m<C>(pos, sl, i) = mm[i];
					} // конец цикла по атомам
				} // конец цикла по подрешеткам
			} // конец цикла по tile-ам
		}
#endif //SWIG
	};
	//--------------------------------------------------------------------------
};
#endif //AIW_MAGNETS_DATA_HPP
