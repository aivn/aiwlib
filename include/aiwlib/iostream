// -*- C++ -*-
#ifndef AIW_IOSTREAM_HPP
#define AIW_IOSTREAM_HPP

/**
 * Copyright (C) 2016 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#ifndef SWIG
#include <cstdio>
#include <string>
#include <stdarg.h>
#endif //SWIG
#include "alloc"

namespace aiw{
	//--------------------------------------------------------------------------
#ifndef SWIG
	template <typename S> void format2stream(S &&str, const char *format){
		for(int i=0; format[i]; ++i){
			if(format[i]=='%'){
				if(format[i+1]=='%'){ str.write(format, i); format += i+1; i = 0; }
				else WRAISE("illegal '%' count: ", format, format+i)
			}
		}
		str<<format;
	}
	template <typename S, typename T, typename ... Args> 
	void format2stream(S &&str, const char *format, T x, Args ... args){
		for(int i=0; true; ++i){
			if(format[i]==0) WRAISE("illegal '%' count: ", format, i, sizeof...(Args)+1, x);
			if(format[i]=='%'){ 
				if(format[i+1]=='%'){ str.write(format, i); format += i+1; i = 0; }
				else {
					if(i) str.write(format, i);
					str<<x; format2stream(str, format+i+1, args...);
					return;
				}  
			}
		}
	}
	template <typename T> struct format2stream_fill_t{ const T& data; int width; char key; };
	template <typename S, typename T> inline S&& operator << (S&& str, const format2stream_fill_t<T> &f){
		str.width(f.width); str.fill(f.key); str<<f.data;
		return str;
	}
	template <typename T> format2stream_fill_t<T> fill(const T& x, int w, char k='0'){ return format2stream_fill_t<T>{x, w, k}; }
#endif //SWIG
	//--------------------------------------------------------------------------
	struct IOstream{
		std::string name;
		virtual ~IOstream(){}
		virtual operator bool () const = 0;
		inline bool operator !() const { return !*this; }
		
		virtual void close() = 0;
		virtual long tell() const = 0;
		virtual void seek(long offset, int whence=0) = 0;
		virtual size_t read(void* buf, size_t size) = 0; // add swig typemap for bind to python style?
		// std::string read(size_t size){ char buf[size]; read(buf, size); return buf; }
		virtual size_t write(const void* buf, size_t size) = 0;
		virtual void flush() = 0;

		virtual bool eof() const = 0;

		// for iostream compability ;-(
		long tellg() const { return this->tell(); }
		void seekg(long offset, int whence=0){ this->seek(offset, whence); }
		
#ifndef SWIG
		virtual std::shared_ptr<aiw::BaseAlloc> mmap(size_t size, bool write_mode=false){
			if(write_mode) WRAISE("can't mmapped IOstream to write mode", name); 
			std::shared_ptr<BaseAlloc> ptr(new MemAlloc<char>(size));
			size_t read_size = read(ptr->get_addr(), size);
			if(read_size!=size) WRAISE("incorrect size from read", size, read_size, name);
			return ptr;
		}
		virtual int printf(const char * format, ...) = 0;
		template <typename ... Args> IOstream& operator ()(const char *format, Args ... args){
			format2stream(*this, format, args...); return *this;
		}
#endif //SWIG

		aiw::IOstream& operator << (const char* S){ write(S, strlen(S)); return *this; }
		aiw::IOstream& operator << (bool   v){ write(v?"True":"False", v?4:5); return *this; }
		aiw::IOstream& operator << (char   c){ printf("%c", c); return *this; }
		aiw::IOstream& operator << (int    v){ printf("%i", v); return *this; }
		aiw::IOstream& operator << (long   v){ printf("%i", v); return *this; }
		aiw::IOstream& operator << (float  v){ printf("%f", v); return *this; }
		aiw::IOstream& operator << (double v){ printf("%lf", v); return *this; }
		aiw::IOstream& operator << (long double v){ printf("%lf", v); return *this; }
		aiw::IOstream& operator << (const std::string &S){ printf("%s", S.c_str()); return *this; }
		// aiw::IOstream& operator << (IOstream& (*func)(IOstream&)){ return func(*this); }

		aiw::IOstream& getline(char *buf, int bufsz, char delim='\n'){
			for(int pos=0; pos<bufsz; pos++){
				char c; if(this->read(&c, 1)!=1) break;
				if(c==delim) break;
				buf[pos] = c;
			}
			return *this; 
		}

		// operators < > for binary IO
	};
	//--------------------------------------------------------------------------
	class File: public IOstream{
		std::shared_ptr<FILE> pf;
	public:
		File(){}
		File(FILE *f){ pf.reset(f, [](FILE*){}); }
		operator bool () const { return pf.get() && !feof(pf.get()); }
#ifndef SWIG
		template <typename ... Args> void open(const char *format, const char *mode, Args ... args){
			std::stringstream path; format2stream(path, format, args...); FILE *f = ::fopen(path.str().c_str(), mode);
			if(!f) WRAISE("cannot open file", path.str(), mode);
			name = path.str(); pf.reset(f, ::fclose);
		}
		template <typename ... Args> File(const char *format, const char *mode, Args ... args){ open(format, mode, args...); }
#endif //SWIG
		File(const char *path, const char *mode){ open(path, mode); }
		
		void close(){ pf.reset(); } 
		long tell() const { return ftell(pf.get()); }
		void seek(long offset, int whence=0){ fseek(pf.get(), offset, whence); }
		size_t read(void* buf, size_t size){ return ::fread(buf, 1, size, pf.get()); }
		size_t write(const void* buf, size_t size){ return ::fwrite(buf, 1, size, pf.get()); }
		void flush(){ fflush(pf.get()); }
		bool eof() const { return feof(pf.get()); }
#ifndef MINGW
		std::shared_ptr<aiw::BaseAlloc> mmap(size_t size, bool write_mode=false){
			return std::shared_ptr<BaseAlloc>(new MMapAlloc(pf, size, write_mode?PROT_READ|PROT_WRITE:PROT_READ)); //O_RDONLY|O_WRONLY:O_RDONLY));
		}
#endif //MINGW
		int printf(const char * format, ...){
			va_list args; va_start(args, format);   
			int r = vfprintf(pf.get(), format, args);
			va_end(args);
			return r;
		}		
	};	
	//--------------------------------------------------------------------------
#ifdef AIW_VEC_HPP
	template <int D, typename T> IOstream& operator << (IOstream &s, const Vec<D, T> &v){
		if(D){ s<<v[0]; } for(int i=1; i<D; i++){ s<<" "<<v[i]; } return s;
	}
#endif //AIW_VEC_HPP
	//--------------------------------------------------------------------------
};
namespace std{
#ifndef SWIG
	inline aiw::IOstream& getline(aiw::IOstream &&S, std::string &dst, char delim='\n'){
		for(char c; S.read(&c, 1)==1 and c!=delim;) dst += c;
		return S;
	}
#endif //SWIG
	inline aiw::IOstream& getline(aiw::IOstream &S, std::string &dst, char delim='\n'){ return getline(std::move(S), dst, delim); }	
};
#endif //AIW_IOSTREAM_HPP
