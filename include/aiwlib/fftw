// -*- C++ -*-
#ifndef AIW_FAST_FOURIER_TRANSITION_WRAPPER_HPP
#define AIW_FAST_FOURIER_TRANSITION_WRAPPER_HPP

/**
 * Copyright (C) 2025-2026 Antov V. Ivanov  <aiv.racs@gmail.com>, Nina S. Tolmacheva
 * Licensed under the Apache License, Version 2.0
 **/

#include <fftw3.h>
#include <omp.h>
#include <complex>
#include <vector>
#include "vec"
#include "binhead"
#include "boxiter"

/* TODO:
1. доступ к значениям частоты
2. сброс результатов в бинарном формате Mesh, в т.ч. того что выходит из bwd
3. вынести имплементацию в отдельный файл?
*/


namespace aiw{
	//--------------------------------------------------------------------------
	//  fftw3 plans for float and double
	//--------------------------------------------------------------------------
	template <typename T> struct fftw3_t;
	
	template <> struct fftw3_t<float>{
		typedef fftwf_complex complex;
		typedef fftwf_plan plan;
		static constexpr auto free = fftwf_free;
		static constexpr auto destroy_plan = fftwf_destroy_plan;
		static constexpr auto malloc = fftwf_malloc;
		static constexpr auto plan_r2c = fftwf_plan_dft_r2c_1d; 
		static constexpr auto plan_c2r = fftwf_plan_dft_c2r_1d;
		static constexpr auto plan_1d = fftwf_plan_dft_1d;
		static constexpr auto execute = fftwf_execute;
	};	

	template <> struct fftw3_t<double>{
		typedef fftw_complex complex;
		typedef fftw_plan plan;
		static constexpr auto free = fftw_free;
		static constexpr auto destroy_plan = fftw_destroy_plan;
		static constexpr auto malloc = fftw_malloc;
		static constexpr auto plan_r2c = fftw_plan_dft_r2c_1d; 
		static constexpr auto plan_c2r = fftw_plan_dft_c2r_1d;
		static constexpr auto plan_1d = fftw_plan_dft_1d;
		static constexpr auto execute = fftw_execute;
	};	
	//--------------------------------------------------------------------------
	template <typename T> class FFTW1D{
		typedef fftw3_t<T> fftw3;
		T *rbuf = nullptr;
		typename fftw3::complex *cbuf = nullptr;
		typename fftw3::plan plan_fwd, plan_bwd;
		int sz = 0; bool r2c = false;
	public:
		void init(int sz_, bool r2c_){
			sz = sz_;  r2c = r2c_;
			if(rbuf) fftw3::free(rbuf);
			if(cbuf){ fftw3::free(cbuf); fftw3::destroy_plan(plan_fwd); fftw3::destroy_plan(plan_bwd); }
			if(r2c){
				rbuf = (T*) fftw3::malloc(sizeof(T)*sz);
				cbuf = (typename fftw3::complex*) fftw3::malloc(sizeof(typename fftw3::complex)*(sz/2+1));
				plan_fwd = fftw3::plan_r2c(sz, rbuf, cbuf, FFTW_ESTIMATE);
				plan_bwd = fftw3::plan_c2r(sz, cbuf, rbuf, FFTW_ESTIMATE);
			} else {
				rbuf = nullptr;
				cbuf = (typename fftw3::complex*) fftw3::malloc(sizeof(typename fftw3::complex)*sz);
				plan_fwd = fftw3::plan_1d(sz, cbuf, cbuf, FFTW_FORWARD, FFTW_ESTIMATE);
				plan_bwd = fftw3::plan_1d(sz, cbuf, cbuf, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
		}
		FFTW1D(){}
		FFTW1D(const FFTW1D& other){ init(other.sz, other.r2c); }
		~FFTW1D(){
			if(rbuf) fftw3::free(rbuf);
			if(cbuf){ fftw3::free(cbuf); fftw3::destroy_plan(plan_fwd); fftw3::destroy_plan(plan_bwd); }
		}

		T& r(int i){ return rbuf[i]; }
		typename fftw3::complex& c(int i){ return cbuf[i]; }

		void fwd(){ fftw3::execute(plan_fwd); }
		void bwd(){ fftw3::execute(plan_bwd); }		
	};
	//--------------------------------------------------------------------------
	//   Final wrapper
	//--------------------------------------------------------------------------
	template <int D, typename T> class FFTW{
		std::vector<std::complex<T> > data;
		int csz = 0, zsz0 = 0, Nth = 0; Ind<D> box;  Vec<D, uint64_t>  mul;
		T* real_buf = nullptr;
		std::vector<FFTW1D<T> > plans;
		Vecf<D> step, _step;
	public:
		size_t size() const { return data.size(); }		
		const Ind<D>& bbox() const { return box; }
		
		FFTW(){}
		void init(const Ind<D> &box_, int csz_, Vecf<D> step_=Vecf<D>(1.f)){
			box = box_;  zsz0 = box[D-1];  box[D-1] = box[D-1]/2+1; csz = csz_;
			data.resize(prod(box)*csz);
			mul[0] = csz; for(int i=0; i<D-1; i++) mul[i+1] = mul[i]*box[i];
			Nth = omp_get_max_threads();  plans.resize(Nth*D);
			for(int ith=0; ith<Nth; ith++) for(int d=0; d<D; d++) plans[ith*D+d].init(box_[d], d==D-1);
			step = step_; _step = 1.f/step;
		}
		FFTW(const Ind<D> &box_, int csz_, Vecf<D> step_=Vecf<D>(1.f)){ init(box_, csz_, step_); }

		std::complex<T>* operator [](size_t i){ return &data[i*csz]; }
		const std::complex<T>* operator [](size_t i) const { return data.data()+i*csz; }		
		//----------------------------------------------------------------------
		template <typename FGET> double fwd(FGET fget){  // fget(const Ind<D> &pos, int id) ==> T x,  return runtime
			double t_start = omp_get_wtime();
			for(int d=D-1; d>=0; d--){  // цикл по направлениям
				Ind<D> dbox = box;  dbox[d] = 1; 	size_t dsz = prod(dbox);  // WMSG(d, dbox, dsz);
#pragma omp parallel for
				for(size_t wid=0; wid<dsz; wid++){  // цикл по 1d линиями
					int thID = omp_get_thread_num();  FFTW1D<T>& plan = plans[thID*D+d];
					Ind<D> pos = wid%dbox;  size_t off = mul*pos;   
					for(int c=0; c<csz; c++){  // цикл по компонентам
						if(d==D-1) for(int i=0, sz=zsz0; i<sz; i++){ pos[D-1] = i; plan.r(i) = fget(pos, c); }
						else for(int i=0, sz=box[d]; i<sz; i++){ auto x = data[off+i*mul[d]+c];  plan.c(i)[0] = x.real();  plan.c(i)[1] = x.imag(); }
						plan.fwd();
						for(int i=0, sz=box[d]; i<sz; i++){ auto &x = data[off+i*mul[d]+c];  x.real(plan.c(i)[0]);  x.imag(plan.c(i)[1]); }						
					}  // конец цикла по компонентам
				}  // конец цикла по 1d линиям
			}  // конец цикла по направлениям
			return omp_get_wtime()-t_start;
		}
		//----------------------------------------------------------------------
		template <typename FSET> double bwd(FSET fset){  // fset(const Ind<D> &pos, int id, T x),  return runtime
			double t_start = omp_get_wtime();
			T norm = double(box[D-1])/prod(box)/zsz0;
			for(int d=0; d<D; d++){  // цикл по направлениям
				Ind<D> dbox = box;  dbox[d] = 1; 	size_t dsz = prod(dbox);  
#pragma omp parallel for
				for(size_t wid=0; wid<dsz; wid++){  // цикл по 1d линиями
					int thID = omp_get_thread_num();  FFTW1D<T>& plan = plans[thID*D+d];
					Ind<D> pos = wid%dbox;  size_t off = mul*pos;   
					for(int c=0; c<csz; c++){  // цикл по компонентам
						for(int i=0, sz=box[d]; i<sz; i++){ auto x = data[off+i*mul[d]+c];  plan.c(i)[0] = x.real();  plan.c(i)[1] = x.imag(); }
						plan.bwd();
						if(d==D-1) for(int i=0, sz=zsz0; i<sz; i++){ pos[D-1] = i; fset(pos, c, plan.r(i)*norm); }						
						else for(int i=0, sz=box[d]; i<sz; i++){ auto &x = data[off+i*mul[d]+c];  x.real(plan.c(i)[0]);  x.imag(plan.c(i)[1]); }						
					}  // конец цикла по компонентам
				}  // конец цикла по 1d линиям
			}  // конец цикла по направлениям
			return omp_get_wtime()-t_start;
		}
		//----------------------------------------------------------------------
		// mask --- по 4 бита на компоненту: re, im, abs, arg
		template <typename S, typename T2=float> double dump(S &&fout, uint64_t mask, std::vector<std::string> axis) const {  // return runtime
			double t_start = omp_get_wtime();
			BinaryHead bh; bh.dim = D; bh.type = aiw::BinaryHead::mesh;
			bh.szT = 0; for(int i=0; i<csz*4; i++) bh.szT += sizeof(T2)*bool(mask&(uint64_t(1)<<i));
			bh.bbox[D-1] = box[D-1];  bh.bmin[D-1] = 0; bh.bmax[D-1] = .5f/step[D-1];
			for(int i=0; i<D-1; i++){ bh.bbox[i] = box[i]/2;  bh.bmin[i] = 0;  bh.bmax[i] = .5f/step[i]; }
			for(int i=0, sz=std::min(D, int(axis.size())); i<sz; i++) bh.axis[i] = axis[i];
			bh.dump(fout);
			Ind<D> lim = box/2; lim[D-1] = box[D-1];
			for(Ind<D> pos: irange(lim)){
				const std::complex<T>* p = data.data()+pos*mul*csz; 
				for(int i=0; i<csz; i++){  // это можно как то оптимизировать? Собрать вектор из смещений и типов обработки?
					if(mask&(uint64_t(1)<<i*4+0)){ T2 v = p[i].real();     fout.write((const char*)&v, sizeof(T2)); }
					if(mask&(uint64_t(1)<<i*4+1)){ T2 v = p[i].imag();     fout.write((const char*)&v, sizeof(T2)); }
					if(mask&(uint64_t(1)<<i*4+2)){ T2 v = std::abs(p[i]);  fout.write((const char*)&v, sizeof(T2)); }
					if(mask&(uint64_t(1)<<i*4+3)){ T2 v = std::arg(p[i]);  fout.write((const char*)&v, sizeof(T2)); }
				}
			}
			return omp_get_wtime()-t_start;
		}
		template <typename S, typename T2=float> double dump(S &fout, uint64_t mask, std::vector<std::string> axis) const {  return dump(std::move(fout), mask, axis); } 
		//----------------------------------------------------------------------
		struct spectr_t{
			double l_av=0, nu_av=0, nu2_av=0;
			T max_ampl=0;
			size_t max_off=0;
			Vecf<D> max_nu;
		};
		spectr_t spectrum(std::vector<T> &res, float &f_max, int cmask=~0) const {  
			// double t_start = omp_get_wtime();
			Ind<D> lim = box/2;  lim[D-1] = box[D-1]-1;
			if(!res.size()) res.resize(int(lim.abs()));
			if(f_max<=0) f_max = .5f*_step.abs();
			std::vector<T> buf(res.size()*Nth, 0.);  std::vector<float> norm(res.size()*Nth, 0.);
			int f_sz = res.size(); float _df = f_sz/f_max;  Vecf<D> _fstep = .5f*_step/lim;
			std::vector<size_t> max_off(Nth);  std::vector<T> max_ampl(Nth, 0.);
			spectr_t av;  double l_av = 0, nu_av = 0, nu2_av = 0, Z = 0;  
			BoxIterOMP<D> biter(box);  size_t sz = biter.size();
#pragma omp parallel for reduction(+:l_av,nu_av,nu2_av,Z)
			for(size_t off=0; off<sz; off++){
				biter(off); Ind<D> F = *biter; for(int i=0; i<D-1; i++) if(F[i]>lim[i]) F[i] = box[i]-F[i];
				T nu = (F&_fstep).abs(); const std::complex<T>* p = data.data()+off*csz;
				int thID = omp_get_thread_num();				
				T a = 0; for(int i=0; i<csz; i++){ if(cmask&(1<<i)) a += std::abs(p[i]); }
				int f = ::floorf(nu*_df); if(f<f_sz){	buf[f_sz*thID+f] += a;  norm[f_sz*thID+f] += 1; }
				if(max_ampl[thID]<a){ max_ampl[thID] = a;  max_off[thID] = off; }
				if(nu){ a /= nu*nu;  Z += a;  l_av += a/nu; nu_av += a*nu;  nu2_av += a*nu*nu; }
			}
			for(int i=f_sz, nsz=norm.size(); i<nsz; i++) norm[i%f_sz] += norm[i];
			for(int i=0; i<f_sz; i++){ res[i] = 0; norm[i] = norm[i]? 1.f/norm[i]: 0; }
			for(int i=0, bsz=buf.size(); i<bsz; i++) res[i%f_sz] += buf[i]*norm[i%f_sz];
			av.l_av = l_av/Z;  av.nu_av = nu_av/Z; av.nu2_av = nu2_av/Z;
			for(int i=0; i<Nth; i++) if(av.max_ampl<max_ampl[i]){ av.max_ampl = max_ampl[i]; av.max_off = max_off[i]; }
			Ind<D> F = av.max_off%box;  for(int i=0; i<D-1; i++) if(F[i]>lim[i]) F[i] = box[i]-F[i];
			av.max_nu = F&_fstep;
			// return omp_get_wtime()-t_start;
			return av;
		}
		//----------------------------------------------------------------------
	};
	//--------------------------------------------------------------------------
}   // end of namespace aiw
#endif //AIW_FAST_FOURIER_TRANSITION_WRAPPER_HPP
