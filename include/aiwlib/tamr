// -*- C++ -*-
#ifndef AIW_TILED_AMR_HPP
#define AIW_TILED_AMR_HPP

/**
 * Copyright (C) 2024, 2026 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 *
 * Tiled Adaptive Mesh header
 **/


#include <set>
#include <map>
#include <unordered_map>
#include <vector>
#include <string>
#include <fstream>
#include <deque>
#include <algorithm>

#include "aiwlib/bitmask"
#include "aiwlib/vec"
#include "aiwlib/zcurve"
#include "aiwlib/binhead"


namespace aiw{
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> class TiledAdaptiveMesh{
		Ind<D> tbox, tmul;  int zbound, rank_lim;  uint64_t zmask;   ///< zbound = 64-log2(tbox.prod()),  rank_lim --- максимально возможный ранг разбиения сетки
		//  key 59 bit offset,  5 bit rank, offset максимально прижат влево
		uint64_t tpos2toff(Ind<D> tpos, int rank) const {  ///< пересчитывает позицию и ранг тайла в ключ forest, в т.ч. реализует ПГУ
			// if(rank==0) return 0;  // корень дерева
			Ind<D> tpos0; int mask = (1<<rank)-1;   // позиция дерева в лесу
			for(int i=0; i<D; i++){
				if(tpos[i]<0) tpos[i] += tbox[i]<<rank;  // ПГУ
				tpos0[i] = tpos[i]>>rank;
				if(tpos0[i]>tbox[i]) tpos0[i] -= tbox[i]; // ПГУ
				tpos[i] &= mask;  // позиция на Z-кривой в дереве
			}
			return (uint64_t(tpos0*tmul)<<zbound)|(ZCurve64<D>(tpos, rank).off<<(zbound-rank*D))|rank;
		}
		Ind<D> toff2tpos(uint64_t toff) const {  ///< пересчитывает ключ из forest в позицию тайла
			int r = toff&31; 
			return (toff>>zbound)%tbox*(1<<r) + *ZCurve64<D>((toff&zmask)>>(zbound-D*r), r);
		}  
		uint64_t next_toff(uint64_t toff) const { return toff+(uint64_t(1)<<(zbound-(toff&31)*D)); }   ///< следующий тайл на том же ранге
		uint64_t up_toff(uint64_t toff) const { int r = toff&31; return (toff&~((uint64_t(1)<<(zbound-(r-1)*D))-1)) | (r-1); }  ///< тайл сверху !!! не проверяет rank>0 !!!
		int up_chID(uint64_t toff) const { return (toff>>(zbound-(toff&31)*D))&((1<<D)-1); }  ///< позиция в тайле сверху !!! не проверяет rank>0 !!!
		//int up_chID(uint64_t toff, uint64_t utoff) const { return (toff>>5+(rank_lim-(utoff&31)-1)*D)&((1<<D)-1); }
		uint64_t down_toff(uint64_t toff, uint64_t chID) const { return (toff|(chID<<(zbound-(toff&31)*D-D)))+1; }  ///< ключ тайла снизу
		int up_off(int off, uint64_t toff) const { return (up_chID(toff)<<((R-1)*D))|(off>>D); }  ///< позиция УЗЛА в тайле сверху
		//static int up_off(int off, const Ind<D> &tpos){ off >>= D; for(int i=0; i<D; i++){ off += tpos[i]%2<<R*(D-1)+i; } return off; }  ///< позиция УЗЛА в тайле сверху
		//static int up_chID(const Ind<D> &tpos){ int res = 0; for(int i=0; i<D; i++){ res += tpos[i]%2<<i; } return res; }                ///< позиция ТАЙЛА в тайле сверху
		static int down_off(int off){ return (off<<D)&((1<<R*D)-1); }  ///< позиция УЗЛА в тайле снизу
		static int down_chID(int off){ return off>>D*(R-1); }          ///< позиция нижнего тайла в который попалает узел
		void dec_rank(uint64_t &toff, int &off, int dr=1) const {      ///< уменьшает ранг на dr>0 согласованно изменяя toff и off
			int r = toff&31;  uint64_t mask = ((uint64_t(1)<<(dr*D))-1) << (zbound-r*D);
			off >>= dr*D;  off |= (toff&mask)>>(zbound-(r-R+dr)*D);
			toff &= ~mask;  toff -= dr;
		}
		void inc_rank(uint64_t &toff, int &off, int dr=1) const {       ///< увеличивает ранг на dr>0 согласованно изменяя toff и off
			if(dr>=R){ toff += dr;  off = 0; }
			else{  toff += dr;  toff |= uint64_t(off>>(R-dr)*D)<<(zbound-(toff&31)*D);  off = (off<<(dr*D))&((1<<(R*D))-1); }
		}

		
		struct tile_t{
			const tile_t *parent = nullptr;  ///< вышележащий (по дереву) тайл, можно с разрывом ранга
			T data[1<<R*D];	                 ///< хранилище данных в тайле
			uint64_t toff;                   ///< ключ тайла в таблице forest, 5 --- ранг,
			uint64_t groups = ~uint64_t(0);  ///< принадлежность узлов тайла к группам задаваемым пользователем
			BitMask<1<<R*D> usage;           ///< битовая маска показываюая использание узлов
			int tID = -1;                    ///< позиция тайла в таблице указателей tiles
			
			int rank() const { return toff&31; }
		};
		std::map<uint64_t, tile_t> forest;  ///< хранилище тайлов обеспечивающее быстрый доступ при необходимости
		std::vector<tile_t*> tiles;         ///< таблица указателей на тайлы для параллельного обхода, сделать таблицу по рангам?

		tile_t& add_tile(const Ind<D> &tpos, const int rank);  ///< при необходимости добавляет тайл и встраивает его в струкутуру данных
		void del_tile(int tID);
		
		Ind<D> coords[1<<R*D];              ///< позиции по Z-кривой в тайле
		struct stencil_node_t { uint32_t off: 24; uint32_t tID: 8; };  // рассматривается куб из тайлов 2х2х2..., tID задает тайл, off смещение в тайле, D<=8
		std::vector<std::vector<stencil_node_t> > stencils;   // для каждого шаблона хранится stencil_sz вариантов по 1<<R*D элементов

		bool fix_mode;  ///< задает стадию обхода для Item
	public:
		int add_stencil(const std::vector<Ind<D> > &stencil);  ///< добавляет шаблон в таблицу stencil-ов, возвращает stencilID>0
		void init(const Ind<D> &tbox_);
		TiledAdaptiveMesh(const Ind<D> &tbox_){ init(tbox_); }
		void tiles2dat(std::string fname) const;
		void items2dat(std::string fname) const;
		//----------------------------------------------------------------------
		class Stencil{   ///< интерфейс обхода соседей по шаблону
			const TiledAdaptiveMesh* storage;
			const tile_t **cube;  ///< куб из указателей на тайлы 2х2х..., cube[0] указывает на тайл в котором находится Item и всегда существует
			const stencil_node_t *snodes;
			int sz;
		public:
			Stencil(const TiledAdaptiveMesh* storage_, const tile_t **cube_, const stencil_node_t *snodes_, int sz_):
				storage(storage_), cube(cube_), snodes(snodes_), sz(sz_){}
			int size() const { return sz; }  ///< число узлов в шаблоне
			int rank;                        ///< ранг последнего узла к которому был произведен доступ через operator []
			const T* operator [] (int cID) noexcept;  ///< доступ к элементу шаблона номер cID, если такого узла нет возвращает nullptr
		};  // end of Stencil struct
		//----------------------------------------------------------------------
		class Item {  ///< интерфейс доступа к одному узлу или ячейке при обходе сетки, каждый поток работает с одним экземляром Item
			friend class TiledAdaptiveMesh;
			const TiledAdaptiveMesh *storage;  ///< указатель на саму сетку
			tile_t *tile;                            ///< указатель на тайл к которому относится узел или ячейка
			const tile_t *cube[1<<D];                ///< кубик тайлов 2x2х...
			Ind<D> tpos;                             ///< позиция тайла на сетке соотв. ранга
			
			std::unordered_map<uint64_t, std::set<int> > add_tiles;  ///< создаваемые узлы по тайлам, накапливаются при проходе
			std::unordered_map<uint64_t, std::set<int> > del_tiles;  ///< позиции удаляемых узлов по тайлам, накапливаются при проходе
			
			// Vecf<D> bmin, step;  ///< позиция и шаг для данного тайла
			int off;             ///< смещение узла в тайле
		public:
			/** @brief очень важный параметр! При первом проходе, при входе в лямбда-функцию пользователя содержит группы тайла  и позволяет их изменить
				При втором проходе (инициализации новых узлов) при входе в лямбда-функцию пользователя инициализируется нулем, что позволяет отличить второй проход и
				позволяет задать группы тайла, если оставить его без изменений нулем то узел НЕ будет создан.
			 */
			uint64_t groups;  

			int rank() const { return tile->rank(); }                                             ///< ранг узла
			Ind<D> pos() const { return tpos*(1<<R) + storage->coords[off]; }  ///< позиция узла на глобальной сетке соответствующего ранга
			// Vecf<D> coord() const { return bmin+(storage->coords[off]&step); }                    ///< координаты узла 
			int Dbits() const { return off&((1<<D)-1); }                                          ///< последние D бит оффсета, м.б. полезно для нумерации шаблонов
			Stencil operator () (int stencilID) const {  ///< создает объект для доступа к соседям по шаблону stencilID
				const auto &st = storage->stencils[stencilID]; int sz = st.size()>>R*D; 
				return Stencil(storage, (const tile_t**)cube, st.data()+sz*off, sz);
			}			
			const T* get_up_item() const noexcept;  ///< возвращает узел с рангом на единицу больше (если есть, иначе nullptr)
			const T* get_down_item() const noexcept;  ///< возвращает узел с рангом на единицу меньше (если есть, иначе nullptr)
			bool check_dec_rank() const { return tile->rank() && !Dbits(); }  ///< проверяет возможность существования узла с рангом на единицу меньше
			void remove(){  ///< удаляет текущий узел !!! никаких ограничений нет, можно пробить в сетке дырку !!!
				if(!storage->fix_mode){ WMSG(tile->rank()); del_tiles[tile->rank()].insert(off); }
			}			
			void add_item(const Ind<D> &dpos, int drank); ///< создает узел с рангом rank+drank и смещенной на dpos на ранге rank+drank
			// сделать add_item по шаблону?
		};	// end of Item struct			
		//----------------------------------------------------------------------
	private:
		void config_item(Item& item, tile_t* tile);
	public:
		/**
		 * @brief Последовательно по тайлам применяет пользовательскую void func(T& cell, Item &item) к узлам сетки. Обход проводится в две стадии:
		 * 1) перестроение сетки --- обходятся узлы имеющие ранг из битовой маски rmask, битовая маска groups позволяет отсекать тайлы не имеющие
		 *    ни одного узла с такими группами, проверка и задание groups (через Item) лежит на пользователе, Item позволяет перестраивать сетку;
		 * 2) фиксация изменений --- обходятся все новые узлы созданные после перестроения сетки, создание узла должно быть подтверждено через item.groups;
		 *    затем удаляются пустые тайлы
		 */
		template <typename Func> void for_each(Func func, uint32_t rmask=~0, uint64_t groups=~uint64_t(0));
		//----------------------------------------------------------------------		
	};
	//--------------------------------------------------------------------------
#include "tamr_impl"
}
#endif AIW_TILED_AMR_HPP
