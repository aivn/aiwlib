// -*- C++ -*-
#ifndef AIW_TILED_AMR_HPP
#define AIW_TILED_AMR_HPP

/**
 * Copyright (C) 2024, 2026 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 *
 * Tiled Adaptive Mesh header
 **/


#include <set>
#include <map>
#include <unordered_map>
#include <vector>
#include <string>
#include <fstream>
#include <deque>
#include <algorithm>

#include "aiwlib/bitmask"
#include "aiwlib/vec"
#include "aiwlib/zcurve"
#include "aiwlib/binhead"

/*  TODO:
	2)  вернуть параллельность в for_each (с возможностью отключения?)
	3)  вернуть сообщения от создателя при создании узлов
	8)  for_each с удвоением/учетверением шага по времени?
	9)  диагностика работы for_each --- времена работы для разных стадий
	10) бинарный формат хранения и визуализации в qplt 
	11) не хватает тестов!!!
	12) произвольный доступ --- насколько для ячеек имеет смысл поиска вниз по дереву? Можно ли это оптимизировать через std::map::lower_bound?
	13) LRnLA обход?
	14) битовые маски periodic и logscale, добавить шаг  и пределы сетки
	15) в cellBased если соседней ячейки нет (разбита) нужно вернуть указатель на  группу соседних ячеек и как то проинформировать что это группа (через rank доступа)?
	    при этом нужен контроль за разбиениями (избегать резких скачков S)
	16) сделать Item::add_item по шаблону?
	17) ограничение на градиент ранга разбиения? Ограничение на дырки по рангам разбиения? 
	18) запоминать в отдельной таблице смещения stencil-а
	19) отдельный метод проверки границы сетки?
	20) сетка со сложной границей?
	
	какой то обход всех узлов специфицированный как const, без доступа к соседям, например для сложного сброса


==========================  
1. жесткое требование --- Item::add_new_item должно создавать узел на том же ранге что и Item, иначе все очень запутанно. Для ячеек этот метод заблокирован.
2. Item::inc_rank может создавать соседей на мелкой сетке, определяется аргументом (скажем маска с номерами коорд сфер). 
3. Генератор шаблонов с коорд сферами - просто add_stencil(sphere_mask)

   Можно хранить дерево вообще отдельно от данных (рядом/поверх) 
   Поддерживать дерево гораздо проще чем создавать его фрагмент для item заново!!!
   Для item нормально достраивать дерево (кубик 3х3) на заданном ранге.

5. Не хранить малозаполненные тайлы, вместо этого использовать систему патчей (глобальное хранилище узлов)? Нужно посмотреть на оверхед по памяти
   Таким образом может быть три типа тайлов (узлов дерева тайлов) - пустой, частично заполненный и полностью заполненный
   Вместо позиции и ранга хранить только toff?

 */


namespace aiw{
	//--------------------------------------------------------------------------
	template <int P> struct calc_3pow { static const int x = 3*calc_3pow<P-1>::x; };
	template <> struct calc_3pow<1> { static const int x = 3; };
	//--------------------------------------------------------------------------
	template <typename T, int D, int R, bool cell_based=true> class TiledAdaptiveMesh{
		struct stencil_node_t { uint32_t off: 22; uint32_t tID: 10; };  // tID задает тайл в кубе из соседей 3х3х3..., off смещение в тайле, D<=6, R*D<=22
		struct tile_t{
			T data[1<<R*D];	                 ///< хранилище данных в тайле
			const tile_t *parent = nullptr;  ///< вышележащий (по дереву) тайл, можно с разрывом ранга
			uint64_t toff;                   ///< ключ тайла в таблице forest, 5 --- ранг,
			uint64_t groups = ~uint64_t(0);  ///< принадлежность узлов тайла к группам задаваемым пользователем
			BitMask<1<<R*D> usage;           ///< битовая маска показывающая использывание узлов
			int tID = -1, rtID = -1;         ///< позиции тайла в таблицах указателей tiles и rtiles[rank()]
			
			int rank() const { return toff&31; }
		};
		//----------------------------------------------------------------------
	public:  // user interface
		//------------------  инициализация  -----------------------------------
		void init(const Ind<D> &tbox_);  ///< инициализирует сетку нулевого ранга разбиения, tbox --- размер в ТАЙЛАХ
		TiledAdaptiveMesh(const Ind<D> &tbox_){ init(tbox_); }

		int add_stencil(const std::vector<Ind<D> > &stencil);  ///< добавляет шаблон в таблицу, возвращает stencilID>=0

		//------------------  диагностика  -------------------------------------
		void tiles2dat(std::string fname) const;  ///< выводит для отладки все тайлы, по z ранг разбиения. Только для 2D сетки 
		void items2dat(std::string fname) const;  ///< выводит для отладки координаты и ранги разбиения всех узлов/центров ячеек сетки		
		template <int V, typename Func, typename Fout> void dump2balls(Func func, Fout &&fout, std::string head="") const;  ///< func(const T&) ==> Vecf<V>
		template <int V, typename Func, typename Fout> void dump2balls(Func func, Fout &fout, std::string head="") const { dump2balls<V>(func, std::move(fout), head); }

		Ind<D>  bbox(int rank=0) const { return tbox*(1<<(R+rank)); }        ///< размер сетки на ранге разбиения rank
		Indl<2> size(uint32_t rmask=~0, uint64_t gmask=~uint64_t(0)) const;  ///< число узлов/ячеек и тайлов отвечающих критериям rmask, gmask
		Ind<2>  ranks_range() const;                                         ///< минимальный и максимальный ранги разбиения сетки
		
		//---  произвольный доступ, всегда очень медленный и неэффективный  ----
		Ind<2> get_addr(const Ind<D+1> &pos_rank) const;  ///< возвращает пару tileID, offset_in_tile, при промахе оба значения =-1, после перестроения сетки теряют смысл 
		int rank(int tileID) const { return tiles[tileID]->rank(); }
		uint64_t groups(int tileID) const { return tiles[tileID]->groups; }
		
		T dummy;  ///< элемент на который возвращается ссылка если произошел промах при произвольном доступе
		const T& operator [] (const Ind<D+1> &pos_rank) const { Ind<2> addr = get_addr(pos_rank); return addr[0]>=0? tiles[addr[0]]->data[addr[1]]: dummy; }
		T&       operator [] (const Ind<D+1> &pos_rank)       { Ind<2> addr = get_addr(pos_rank); return addr[0]>=0? tiles[addr[0]]->data[addr[1]]: dummy; }

		//-- обход сетки, любые сложные вычисления должны делаться только так -- 
		/**
		 * @brief Параллельно по тайлам применяет пользовательскую void func(T& cell, Item &item) к узлам сетки. Обход проводится в две стадии:
		 * 1) перестроение сетки --- обходятся узлы имеющие ранг из битовой маски rmask, битовая маска groups позволяет отсекать тайлы не имеющие
		 *    ни одного узла с такими группами, проверка и задание groups (через Item) лежит на пользователе, Item позволяет перестраивать сетку;
		 * 2) фиксация изменений --- обходятся все новые узлы созданные после перестроения сетки;  затем удаляются пустые тайлы
		 */
		template <typename Func> void for_each(Func func, uint32_t rmask=~0, uint64_t groups=~uint64_t(0));

		/**
		 * @brief Аналогично for_each применяет пользовательскую void func(T& cell, Item &item) к узлам  попадающим в область тайла с нулевым уровнем разбиения (дерево в лесу)
		 находящимся в позиции tpos0. Обход идет последовательно согласно Z-кривой и проводится в две стадии:
		 * 1) перестроение сетки --- обходятся узлы имеющие ранг из битовой маски rmask, битовая маска groups позволяет отсекать тайлы не имеющие
		 *    ни одного узла с такими группами, проверка и задание groups (через Item) лежит на пользователе, Item позволяет перестраивать сетку;
		 * 2) фиксация изменений --- обходятся все новые узлы созданные после перестроения сетки;  затем удаляются пустые тайлы
		 * сейчас НЕ позволяет изменять группы для тайлов
		 */
		template <typename Func> void for_zorder(const Ind<D> &tpos0, Func func, uint32_t rmask=~0, uint64_t groups=~uint64_t(0));
		//----------------------------------------------------------------------
	public:
		class Item {  ///< интерфейс доступа к одному узлу или ячейке при обходе сетки, каждый поток работает с одним экземляром Item
		protected:
			friend class TiledAdaptiveMesh;
			const TiledAdaptiveMesh *storage;     ///< указатель на саму сетку

			tile_t *tile = nullptr;               ///< указатель на тайл к которому относится узел или ячейка
			const tile_t *cube[calc_3pow<D>::x];  ///< кубик 3x3х... из указателей на тайлы
			uint64_t toff_cube[calc_3pow<D>::x];  ///< кубик 3x3х... из оффсетов тайлов, в отличие от указателей они всегда определены
			Ind<D> tpos;                          ///< позиция тайла на сетке соотв. ранга
			int off;                              ///< смещение узла в тайле
			
			std::unordered_map<uint64_t, std::set<int> > add_tiles;  ///< создаваемые узлы по тайлам, накапливаются при проходе
			std::unordered_map<uint64_t, std::set<int> > del_tiles;  ///< позиции удаляемых узлов по тайлам, накапливаются при проходе

			const stencil_node_t *snodes;
			int stencil_sz;

			// Vecf<D> bmin, step;  ///< позиция и шаг для данного тайла
		public:
			/** @brief очень важный параметр! При первом проходе, при входе в лямбда-функцию пользователя содержит группы тайла  и позволяет их изменить
				При втором проходе (инициализации новых узлов) при входе в лямбда-функцию пользователя инициализируется нулем, что позволяет отличить второй проход и
				позволяет задать группы тайла, если оставить его без изменений нулем то узел НЕ будет создан.
			 */
			uint64_t groups;  

			int rank() const { return tile->rank(); }                          ///< ранг узла
			Ind<D> pos() const { return tpos*(1<<R) + storage->coords[off]; }  ///< позиция узла на глобальной сетке соответствующего ранга
			// Vecf<D> coord() const { return bmin+(storage->coords[off]&step); }                    ///< координаты узла 
			int Dbits() const { return off&((1<<D)-1); }                       ///< последние D бит оффсета, м.б. полезно для нумерации шаблонов

			void stencil(int stID){  ///< Настраивает Item для доступа к соседям по шаблону stID
				const auto &st = storage->stencils[stID];  int stencil_sz = st.size()>>R*D; 
				snodes = st.data()+stencil_sz*off;
			}			
			int size() const { return stencil_sz; }    ///< число узлов в шаблоне
			int srank;                                 ///< ранг последнего элемента шаблона к которому был произведен доступ через operator []
			const T* operator [] (int cID) noexcept {  ///< доступ к элементу шаблона номер cID, если такого узла нет возвращает nullptr
				stencil_node_t sn = snodes[cID];  srank = rank();  return cube[sn.tID]->data+sn.off;  // штатное поведение, целевой элемент есть
			}
			const T* get_up_item() const noexcept;    ///< возвращает узел/ячейку с рангом на единицу больше (если есть, иначе nullptr)
			const T* get_down_item() const noexcept;  ///< возвращает узел/ячейку с рангом на единицу меньше (если есть, иначе nullptr)
			// тут бы надо получать доступ к массиву нижележащих ячеек? Как то помечать какие ячейки активны, или считаем что слишком большого счкачка по рангу быть не может?
			
			bool check_dec_rank() const { return cell_based || (tile->rank() && !Dbits()); }  ///< проверяет возможность существования узла с рангом на единицу меньше
			void remove(){ if(!storage->fix_mode){ del_tiles[tile->toff].insert(off); } }     ///< удаляет текущий узел !!! никаких ограничений нет, можно пробить в сетке дырку !!!
			void add_item(const Ind<D> &dpos, int drank);        ///< создает узел с рангом rank+drank и смещенной на dpos на ранге rank+drank
			bool new_item() const { return storage->fix_mode; }  ///< отмечает второй проход (это новый узел)
			// сделать add_item по шаблону?
		};	// end of Item struct			
		//----------------------------------------------------------------------		
	protected:  // детали реализации
		struct BItem: public Item {
		protected:
			friend class TiledAdaptiveMesh;
			using Item::storage;
			using Item::tile;
			using Item::cube;
			using Item::toff_cube;
			using Item::tpos;
			using Item::snodes;
			using Item::off;
		public:
			using Item::srank;
			const T* operator [] (int cID) noexcept;  ///< доступ к элементу шаблона номер cID, если такого узла нет возвращает nullptr
		};
		//-------  функции для работы с ключами и позициями тайлов  -----------
		Ind<D> tbox, tmul;  int zbound, rank_lim;  uint64_t zmask;   ///< zbound = 64-log2(tbox.prod()),  rank_lim --- максимально возможный ранг разбиения сетки
		//  key 59 bit offset,  5 bit rank, offset максимально прижат влево

		uint64_t tpos2toff(Ind<D> tpos, int rank) const;  ///< пересчитывает позицию и ранг тайла в ключ forest, в т.ч. реализует ПГУ
		Ind<D> toff2tpos(uint64_t toff) const { int r = toff&31; return (toff>>zbound)%tbox*(1<<r) + *ZCurve64<D>((toff&zmask)>>(zbound-D*r), r); }  ///< вычисляет позицию тайла

		uint64_t next_toff(uint64_t toff) const { return toff+(uint64_t(1)<<(zbound-(toff&31)*D)); }   ///< следующий тайл на том же ранге
		uint64_t up_toff(uint64_t toff) const { int r = toff&31; return (toff&~((uint64_t(1)<<(zbound-(r-1)*D))-1)) | (r-1); }  ///< тайл сверху !!! не проверяет rank>0 !!!

		//  up_chID нигде кроме up_off не используется?
		int up_chID(uint64_t toff) const { return (toff>>(zbound-(toff&31)*D))&((1<<D)-1); }  ///< позиция тайла toff в тайле сверху !!! не проверяет rank>0 !!!
		int up_off(int off, uint64_t toff) const { return (up_chID(toff)<<((R-1)*D))|(off>>D); }  ///< позиция УЗЛА off из тайла toff в тайле сверху

		bool dec_rank(int &off, uint64_t &toff) const {  ///< уменьшает (по возможности) ранг тайла и согласованно изменяет off и toff
			if((toff&31)==0 || (!cell_based && (off&((1<<D)-1)))) return false;
			off = up_off(off, toff);  toff = up_toff(toff);
			return true;
		}
		bool inc_rank(int &off, uint64_t &toff) const {  ///< увеличивает (по возможности) ранг тайла и согласованно изменяет off и toff
			if((toff&31)>=rank_lim) return false;
			toff++;  toff |= uint64_t(off>>(R-1)*D)<<(zbound-(toff&31)*D);  off = (off<<D)&((1<<(R*D))-1);
			return true;
		}
		
		//int up_chID(uint64_t toff, uint64_t utoff) const { return (toff>>5+(rank_lim-(utoff&31)-1)*D)&((1<<D)-1); }
		//uint64_t down_toff(uint64_t toff, uint64_t chID) const { return (toff|(chID<<(zbound-(toff&31)*D-D)))+1; }  ///< ключ тайла снизу
		//static int up_off(int off, const Ind<D> &tpos){ off >>= D; for(int i=0; i<D; i++){ off += tpos[i]%2<<R*(D-1)+i; } return off; }  ///< позиция УЗЛА в тайле сверху
		//static int up_chID(const Ind<D> &tpos){ int res = 0; for(int i=0; i<D; i++){ res += tpos[i]%2<<i; } return res; }                ///< позиция ТАЙЛА в тайле сверху
		//static int down_off(int off){ return (off<<D)&((1<<R*D)-1); }  ///< позиция УЗЛА в тайле снизу
		//static int down_chID(int off){ return off>>D*(R-1); }          ///< позиция нижнего тайла в который попалает узел
		/*
		void dec_rank(uint64_t &toff, int &off, int dr=1) const {      ///< уменьшает ранг на dr>0 согласованно изменяя toff и off
			int r = toff&31;  uint64_t mask = ((uint64_t(1)<<(dr*D))-1) << (zbound-r*D);
			off >>= dr*D;  off |= (toff&mask)>>(zbound-(r-R+dr)*D);
			toff &= ~mask;  toff -= dr;
		}
		void inc_rank(uint64_t &toff, int &off, int dr=1) const {       ///< увеличивает ранг на dr>0 согласованно изменяя toff и off
			if(dr>=R){ toff += dr;  off = 0; }
			else{  toff += dr;  toff |= uint64_t(off>>(R-dr)*D)<<(zbound-(toff&31)*D);  off = (off<<(dr*D))&((1<<(R*D))-1); }
		}
		*/

		//-----------------  основная структура данных  ------------------------  
		std::map<uint64_t, tile_t> forest;          ///< хранилище тайлов обеспечивающее быстрый доступ при необходимости
		std::vector<tile_t*> tiles;                 ///< таблица указателей на тайлы для параллельного обхода
		std::vector<std::vector<tile_t*> > rtiles;  ///< таблица указателей на тайлы по рангам

		tile_t& add_tile(const Ind<D> &tpos, const int rank);  ///< при необходимости добавляет тайл и встраивает его в струкутуру данных
		void del_tile(int tID);
		
		Ind<D> coords[1<<R*D];              ///< позиции по Z-кривой в тайле
		std::vector<std::vector<stencil_node_t> > stencils;   // для каждого шаблона хранится stencil_sz вариантов по 1<<R*D элементов

		bool fix_mode;  ///< задает стадию обхода для Item

		bool config_item(BItem& item, tile_t* tile);  ///< конфигурирует Item, возвращает принадлежность к границе разбиения
		template <typename Func> void rebuild(Func func, BItem& item);  ///< завершает перестроение сетки
		struct item_addr_t{  ///< для for_zorder
			uint64_t zoff;
			int32_t tID, off;
			item_addr_t(uint64_t zoff_, int32_t tID_, int32_t off_): zoff(zoff_), tID(tID_), off(off_){}
			bool operator < (const item_addr_t& other) const { return zoff<other.zoff; }
		};
		//----------------------------------------------------------------------		
	};
	//--------------------------------------------------------------------------
#include "tamr_impl"
}
#endif AIW_TILED_AMR_HPP
