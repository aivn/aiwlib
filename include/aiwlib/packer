// -*- C++ -*-
#ifndef AIW__HPP
#define AIW__HPP

/**
 * Copyright (C) 2020 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#include <string.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include "iostream"

namespace aiw{
	//--------------------------------------------------------------------------
	class Packer{
		std::vector<char> buf;
		size_t rpos; // = 0;

		void pack_sz(uint32_t sz){ if(sz<128) *this<char(sz); else *this<((1<<31)|sz); }
		uint32_t unpack_sz(){
			uint8_t sz1 = 0; *this>sz1; if(sz1<128) return sz1;
			rpos--; uint32_t sz2 = 0; *this>sz2; return sz2&(~(1<<31));
		}
	public:
		Packer(): rpos(0){}
		Packer(const std::string &S): buf(S.size()), rpos(0) { memcpy(buf.data(), S.c_str(), S.size()); }
		operator std::string () const { return std::string(buf.data(), buf.size()); }

		size_t size() const { return buf.size(); }
		const char* data() { return buf.data(); }

		//--- write operations ---
		void write(const void *x, int sz){ buf.resize(buf.size()+sz); memcpy(buf.data()+buf.size()-sz, x, sz); }
		template<typename T> Packer& operator < (const T& x){ write(&x, sizeof(T)); return *this; }
		template <typename T, int D> Packer& operator < (T const (&p)[D]){ for(int i=0; i<D; i++) *this<p[i]; return *this; }

		void push_str(const std::string &x){ write(x.c_str(), x.size()); }
		Packer& operator < (const std::string &x){  pack_sz(x.size());  push_str(x);  return *this;  }
		Packer& operator < (const char *x){ return *this<std::string(x); }
		
		template<typename T> Packer& operator < (const std::vector<T>& C){ pack_sz(C.size()); for(const auto& x: C) *this<x; return *this; }
		template<typename T> Packer& operator < (const std::list<T>& C){   pack_sz(C.size()); for(const auto& x: C) *this<x; return *this; }
		template<typename K, typename V> Packer& operator < (const std::map<K, V>& M){
			pack_sz(M.size()); for(const auto& I: M) *this<I.first<I.second;
			return *this;
		}
		void crop(int sz){ buf.resize(sz); }
		void insert_zero(int pos, int sz){ if(sz) buf.insert(buf.begin()+pos, sz, 0); }

		void dump(IOstream& S) const { S<uint32_t(buf.size()); if(buf.size()) S.write(buf.data(), buf.size()); }
		void dump(std::ostream& S) const { uint32_t sz = buf.size(); S.write((char*)&sz, 4); if(buf.size()) S.write(buf.data(), buf.size()); }
		
		//--- read operations ---
		bool load(IOstream& S){
			size_t s = S.tell(); int32_t sz = -1; S>sz; if(sz<0){ S.seek(s); return false; }
			buf.resize(sz); rpos = 0; if(!sz || int(S.read(buf.data(), sz))==sz) return true;
			S.seek(s); return false;
		}
		bool load(std::istream& S){
			size_t s = S.tellg(); int32_t sz = -1;  if(!S.read((char*)&sz, 4) || sz<0){ S.seekg(s); return false; }
			buf.resize(sz); rpos = 0; if(!sz || S.read((char*)buf.data(), sz)) return true;
			S.seekg(s); return false;
		}		

		void seek(int pos){ rpos = pos; }
		int tell() const { return rpos; };
		void rseek(int pos){ rpos = buf.size()-pos; }
		int tail_sz() const { return buf.size()-rpos; }
		operator bool () const { return rpos<buf.size(); }
		void read(void *x, int sz){
			if(rpos+sz<buf.size()){  memcpy(x, buf.data()+rpos, sz); rpos += sz; }
			else rpos = buf.size();
		}
		template<typename T> Packer& operator > (T& x){  read(&x, sizeof(T)); return *this;  }
		template <typename T, int D> Packer& operator > (T (&p)[D]){ for(int i=0; i<D; i++) *this>p[i]; return *this; }

		std::string pull_str(int sz){ std::string x(sz, 0); read(&(x[0]), sz); /*x[sz] = 0;*/  return x; }
		Packer& operator > (std::string &x){ uint32_t sz = unpack_sz(); x.resize(sz); read(&(x[0]), sz); /*x[sz] = 0;*/  return *this; }
		template<typename T> Packer& operator > (std::vector<T>& C){ int sz = unpack_sz(); C.resize(sz); for(auto& x: C) *this>x; return *this; }
		template<typename T> Packer& operator > (std::list<T>& C){   int sz = unpack_sz(); C.resize(sz); for(auto& x: C) *this>x; return *this; }
		template<typename K, typename V> Packer& operator > (std::map<K, V>& M){
			int sz = unpack_sz();  for(int i=0; i<sz; i++){ K k; V v; *this>k>v; M[k] = v; }
			return *this;
		}		
		template<typename T> void get(int pos, T& x){  memcpy(&x, buf.data()+pos, sizeof(T)); }
		template <typename T, int D> void get(int pos, T (&p)[D]){ memcpy(p, buf.data()+pos, sizeof(T)*D); }
	};
	//--------------------------------------------------------------------------
}   // end of namespace aiw
#endif //AIW__HPP
