// -*- C++ -*-
#ifndef AIW_INTEPROLATIONS_HPP
#define AIW_INTEPROLATIONS_HPP

/**
 * Copyright (C) 2017 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#include "vec"

namespace aiw{
	//--------------------------------------------------------------------------
	inline Vec<2> interpolate_line_weights(double x){ return vec(1-x, x); }
	inline Vec<4> interpolate_cube_weights(double x){
		double x2 = x*x; double x3 = x2*x;
		return vec(-.5*(x+x3)+x2, 1-2.5*x2+1.5*x3, .5*x+2*x2-1.5*x3, .5*(x3-x2));
	}
	inline Vec<4> interpolate_Bspline_weights(double x){
		double x2 = x*x; double x3 = x2*x;
		return vec(-x3+3*x2-3*x+1, 3*x3-6*x2+4, -3*x3+3*x2+3*x+1, x3)/6.;
	}
	//--------------------------------------------------------------------------
	template<typename T, int D, typename C, int DD> T interpolate(const C& arr, const Ind<D> &pos, const Vec<D> &x, uint64_t interp, const Ind<DD> &point){
		// return x[0];
		int mask = interp&(0xF<<(4*(D-DD-1)));
		if(mask==0) return interpolate<T>(arr, pos, x, interp, point|0); // without intepolation
		if(mask==1){ // linear interpolation
			T y[2]; for(int i=0; i<2; i++) y[i] = interpolate<T>(arr, pos, x, interp, point|i);
			return y[0]*(1-x[DD])+y[1]*x[DD];
		}
		T y[4]; for(int i=0; i<4; i++) y[i] = interpolate<T>(arr, pos, x, interp, point|(i-1));
		Vec<4> w = mask==2? interpolate_cube_weights(x[DD]): interpolate_Bspline_weights(x[DD]);
		return y[0]*w[0]+y[1]*w[1]+y[2]*w[2]+y[3]*w[3];
	}
	template<typename T, int D, typename C> T interpolate(const C& arr, const Ind<D> &pos, const Vec<D> &x, uint64_t interp, const Ind<D> &point){
		return arr[pos+point];  // recursion final
	}
	// frontend
	template<typename C> typename C::cell_type interpolate(const C& arr,            // container
														   const Ind<C::dim> &pos,  // left cell position
														   const Vec<C::dim> &x,    // coordinates in cell
														   uint64_t interp          // type of interpolations
														   ){ return interpolate<typename C::cell_type>(arr, pos, x, interp, Ind<0>()); }
	//--------------------------------------------------------------------------
	// This code is generated by bin/bspline_codegen.py automatically:
	//--------------------------------------------------------------------------
    template <int K> inline double bspline(double x){ static_assert(K<=10, "code not implemented"); return 0; }

    template <> inline double bspline<1>(double x){
		//x = fabs(x);
        if(-0.5<=x && x<.5) return 1.0;
        return 0.;
    }
    template <> inline double bspline<2>(double x){
		x = fabs(x);
        if(x<1) return 1.0-x;
        return 0.;
    }
    template <> inline double bspline<3>(double x){
		x = fabs(x);
        if(x<0.5) return 0.75+x*(x*(-1.0));
        if(x<1.5) return 1.125+x*(-1.5+x*(0.5));
        return 0.;
    }
    template <> inline double bspline<4>(double x){
		x = fabs(x);
        if(x<1) return 0.666666666667+x*(x*(-1.0+x*(0.5)));
        if(x<2) return 1.33333333333+x*(-2.0+x*(1.0+x*(-0.166666666667)));
        return 0.;
    }
    template <> inline double bspline<5>(double x){
		x = fabs(x);
        if(x<0.5) return 0.598958333333+x*(x*(-0.625+x*(x*(0.25))));
        if(x<1.5) return 0.572916666667+x*(0.208333333333+x*(-1.25+x*(0.833333333333+x*(-0.166666666667))));
        if(x<2.5) return 1.62760416667+x*(-2.60416666667+x*(1.5625+x*(-0.416666666667+x*(0.0416666666667))));
        return 0.;
    }
    template <> inline double bspline<6>(double x){
		x = fabs(x);
        if(x<1) return 0.55+x*(5.55111512313e-17+x*(-0.5+x*(-4.16333634234e-17+x*(0.25+x*(-0.0833333333333)))));
        if(x<2) return 0.425+x*(0.625+x*(-1.75+x*(1.25+x*(-0.375+x*(0.0416666666667)))));
        if(x<3) return 2.025+x*(-3.375+x*(2.25+x*(-0.75+x*(0.125+x*(-0.00833333333333)))));
        return 0.;
    }
    template <> inline double bspline<7>(double x){
		x = fabs(x);
        if(x<0.5) return 0.511024305556+x*(x*(-0.401041666667+x*(x*(0.145833333333+x*(x*(-0.0277777777778))))));
        if(x<1.5) return 0.511783854167+x*(-0.00911458333333+x*(-0.35546875+x*(-0.121527777778+x*(0.328125+x*(-0.145833333333+x*(0.0208333333333))))));
        if(x<2.5) return 0.179557291667+x*(1.31979166667+x*(-2.5703125+x*(1.84722222222+x*(-0.65625+x*(0.116666666667+x*(-0.00833333333333))))));
        if(x<3.5) return 2.55314670139+x*(-4.37682291667+x*(3.12630208333+x*(-1.19097222222+x*(0.255208333333+x*(-0.0291666666667+x*(0.00138888888889))))));
        return 0.;
    }
    template <> inline double bspline<8>(double x){
		x = fabs(x);
        if(x<1) return 0.479365079365+x*(x*(-0.333333333333+x*(-2.77555756156e-17+x*(0.111111111111+x*(3.12250225676e-17+x*(-0.0277777777778+x*(0.00694444444444)))))));
        if(x<2) return 0.490476190476+x*(-0.0777777777778+x*(-0.1+x*(-0.388888888889+x*(0.5+x*(-0.233333333333+x*(0.05+x*(-0.00416666666667)))))));
        if(x<3) return -0.220634920635+x*(2.41111111111+x*(-3.83333333333+x*(2.72222222222+x*(-1.05555555556+x*(0.233333333333+x*(-0.0277777777778+x*(0.00138888888889)))))));
        if(x<4) return 3.25079365079+x*(-5.68888888889+x*(4.26666666667+x*(-1.77777777778+x*(0.444444444444+x*(-0.0666666666667+x*(0.00555555555556+x*(-0.000198412698413)))))));
        return 0.;
    }
    template <> inline double bspline<9>(double x){
		x = fabs(x);
        if(x<0.5) return 0.452920968192+x*(x*(-0.2822265625+x*(x*(0.083984375+x*(x*(-0.015625+x*(x*(0.00173611111111))))))));
        if(x<1.5) return 0.452908761161+x*(0.0001953125+x*(-0.28359375+x*(0.00546875+x*(0.0703125+x*(0.021875+x*(-0.0375+x*(0.0125+x*(-0.00138888888889))))))));
        if(x<2.5) return 0.506302315848+x*(-0.2845703125+x*(0.380859375+x*(-0.88046875+x*(0.80859375+x*(-0.371875+x*(0.09375+x*(-0.0125+x*(0.000694444444444))))))));
        if(x<3.5) return -0.856089564732+x*(4.07508370536+x*(-5.72265625+x*(4.00234375+x*(-1.6328125+x*(0.409375+x*(-0.0625+x*(0.00535714285714+x*(-0.000198412698413))))))));
        if(x<4.5) return 4.17041800363+x*(-7.41407645089+x*(5.76650390625+x*(-2.562890625+x*(0.7119140625+x*(-0.1265625+x*(0.0140625+x*(-0.000892857142857+x*(2.48015873016e-05))))))));
        return 0.;
    }
    template <> inline double bspline<10>(double x){
		x = fabs(x);
        if(x<1) return 0.430417768959+x*(5.55111512313e-17+x*(-0.243055555556+x*(-2.28983498829e-16+x*(0.0659722222222+x*(-6.33174068732e-17+x*(-0.0115740740741+x*(-3.90312782095e-18+x*(0.00173611111111+x*(-0.000347222222222)))))))));
        if(x<2) return 0.429839065256+x*(0.00520833333333+x*(-0.263888888889+x*(0.0486111111111+x*(-0.00694444444444+x*(0.0729166666667+x*(-0.0601851851852+x*(0.0208333333333+x*(-0.00347222222222+x*(0.000231481481481)))))))));
        if(x<3) return 0.599151234568+x*(-0.756696428571+x*(1.25992063492+x*(-1.72916666667+x*(1.32638888889+x*(-0.59375+x*(0.162037037037+x*(-0.0267857142857+x*(0.00248015873016+x*(-9.92063492063e-05)))))))));
        if(x<4) return -1.84169697972+x*(6.56584821429+x*(-8.50347222222+x*(5.86458333333+x*(-2.47048611111+x*(0.671875+x*(-0.119212962963+x*(0.0133928571429+x*(-0.000868055555556+x*(2.48015873016e-05)))))))));
        if(x<5) return 5.38228891093+x*(-9.68812003968+x*(7.75049603175+x*(-3.61689814815+x*(1.08506944444+x*(-0.217013888889+x*(0.0289351851852+x*(-0.00248015873016+x*(0.000124007936508+x*(-2.7557319224e-06)))))))));
        return 0.;
    }
	//--------------------------------------------------------------------------
	//  End of bin/bspline_codegen.py fragment code
	//--------------------------------------------------------------------------
	class BSpline{
		double (*bsplines[10])(double) {bspline<1>, bspline<2>, bspline<3>, bspline<4>, bspline<5>, bspline<6>, bspline<7>, bspline<8>, bspline<9>, bspline<10>};
		double (*pf)(double) = nullptr;
		int K = 0;
	public:
		BSpline(int order=0){
			K = order;
			if(K==0) pf = nullptr;
			else if(0<K && K<=10) pf = bsplines[K-1];
			else WRAISE("code not implimented ", K);
		}
		operator bool () const { return K; }
		bool operator !() const { return !K; }
		int order() const { return K; }
		double hwidth() const { return .5*K; } 
		inline double operator()(double x) const { return pf(x); }
	};
	//--------------------------------------------------------------------------
	template <typename T, typename S>
	inline void add_table2table(const T *src, int src_sz, // таблица-источник
								T *dst, int dst_sz,       // таблица-приемник
								double offset,            // смещение начала источника от начала приемника в ячейках
								const S &spline){         // сплайн определяющий порядок аппроксимации при подсуммировании
		int offset0 = floor(offset), w_sz = spline.order();
		double delta = offset-offset0, weights[w_sz];
		int delta_i = floor(spline.hwidth()-delta);
		for(int i=0; i<w_sz; ++i) weights[i] = spline(i-delta_i-delta); 

		for(int i=0; i<src_sz; i++)
			for(int j=0; j<w_sz; j++){
				int dst_i = offset0+i+j-delta_i;
				if(dst_i<0 || dst_i>= dst_sz) continue;
				dst[dst_i] += src[i]*weights[j];
			}
	}
	//--------------------------------------------------------------------------
};
#endif //AIW_INTEPROLATIONS_HPP
