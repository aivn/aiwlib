// -*- C++ -*-
#ifndef AIW_MESH_HPP
#define AIW_MESH_HPP

#include <utility>
#include "iostream"
#include "vec"
#include "binaryio"

namespace aiw{
//------------------------------------------------------------------------------
	template <typename T, int D> class Mesh {
		std::shared_ptr<BaseAlloc> mem;
		void *ptr;           // указатель на элемент с позицией Ind(0,0...)
		size_t sz;           // общее число элементов
		Ind<D> box;          // размеры сетки в ячейках
		Ind<D> axes;         // порядок следования осей
		Vec<D, int64_t> mul; // то на что умножается pos в адресной арифметике
		template <typename T2, int D2> friend class Mesh;
	public:
		std::string head;
		T out_value;
		aiw::Vec<D> bmin, bmax, step, rstep;
		int logscale; // логарифмический масштаб по осям в виде битовой маски (0 --- нет, 1 --- да).

		inline      size_t size() const { return sz; }
		inline aiw::Ind<D> bbox() const { return box; }
		size_t mem_size() const { return mem->get_size(); }
		size_t mem_sizeof() const { return mem->get_sizeof(); }
		//----------------------------------------------------------------------
		void set_axes(const aiw::Vec<D> &bmin_, const aiw::Vec<D> &bmax_, int logscale_=0){
			bmin = bmin_; bmax = bmax_;	logscale = logscale_;
			for(int i=0; i<D; i++){
				step[i] = logscale&1<<i? exp(log(bmax[0]/bmin[0])/box[i]) :(bmax[i]-bmin[i])/box[i];
				axes[i] = i; rstep[i] = logscale&1<<i? 1./log(step[i]) : 1./step[i];
			}
		}
	protected:
		size_t sz_init(const aiw::Ind<D> &box_){ 		  
			box = box_; box.prod(sz); mul[0] = sizeof(T); 
			for(int i=1; i<D; i++) mul[i] = mul[i-1]*box[i-1];
			return sz;
		}
	public:
		void init(const aiw::Ind<D> &box_, const aiw::Vec<D> &bmin_, const aiw::Vec<D> &bmax_, int logscale_=0){
			mem.reset(new MemAlloc<T>(sz_init(box_))); ptr = mem->get_addr(); 
			set_axes(bmin_, bmax_, logscale_);
		}
		void init(const aiw::Ind<D> &box_){ init(box_, Vec<D>(), box_); }
		//----------------------------------------------------------------------
		//???оптимизировать для простых случаев???		
#ifndef SWIG
		void dump(aiw::IOstream &&S) const {
			S<head<D<int(sizeof(T))<box;
			for(Ind<D> pos; pos^=box; ++pos) S.write(&(*this)[pos], sizeof(T));  
		}
		bool load(aiw::IOstream &&S, int use_mmap=0, bool raise_on_error=true){ // mmap = 0 - not use, 1 - readonly, 2 - rw
			std::string h; int rD=-1, szT=-1; Ind<D> b; size_t s = S.tell(); S>h>rD>szT>b;
			if(rD!=D || szT!=sizeof(T)){ 
				S.seek(s); 
				if(raise_on_error){ WRAISE("incorrect Mesh::load() ", D, rD, sizeof(T), szT, S.name, S.tell(), b, h); }
				else return false;
			}
			head = h; sz_init(b);
			if(use_mmap){ mem = S.mmap(sz*sizeof(T), use_mmap-1); ptr = mem->get_addr(); set_axes(vec(0.), box); }
			else { init(b); S.read(ptr, sz*sizeof(T)); }
			return true;
		}
#endif //SWIG
		void dump(aiw::IOstream &S) const { dump(std::move(S)); }
		bool load(aiw::IOstream &S, int use_mmap=0, bool raise_on_error=true){ // mmap = 0 - not use, 1 - readonly, 2 - rw 
			return load(std::move(S), use_mmap, raise_on_error); 
		}
		//----------------------------------------------------------------------		
		inline aiw::Ind<D> coord2pos(const aiw::Vec<D> &r) const {
			Ind<D> p;
			for(int i=0; i<D; i++) p[i] = logscale&1<<i ? log(r[i]/bmin[i])*rstep[i] :(r[i]-bmin[i])*rstep[i];
			return p;
		}
		inline aiw::Vec<D> pos2coord(const aiw::Ind<D> &p) const {
			Vec<D> r;
			for(int i=0; i<D; i++) r[i] = logscale&1<<i ? bmin[i]*pow(step[i], p[i]+.5) :bmin[i]+step[i]*(p[i]+.5);
			return r;
		}
		//----------------------------------------------------------------------
#ifndef SWIG		
		inline const T& get(const aiw::Ind<D> &pos) const {
			WASSERT(Ind<D>()<=pos && pos<box, "position out of box", pos, box);
			return *((const T*)((const char*)ptr+mul*pos));
		}
		inline const T& get(const aiw::Vec<D> &r) const {
			Ind<D> pos = coord2pos(r);
			return Ind<D>()<=pos && pos<box ? *((const T*)((const char*)ptr+mul*pos)) : out_value;
		}
		inline const T& operator [] (const aiw::Ind<D> &p) const { return     get(p); }
		inline       T& operator [] (const aiw::Ind<D> &p)       { return (T&)get(p); }
		inline const T& operator [] (const aiw::Vec<D> &r) const { return     get(r); }
		inline       T& operator [] (const aiw::Vec<D> &r)       { return (T&)get(r); }
#endif // SWIG
		inline const T& __getitem__(const aiw::Ind<D> &p) const { return get(p); }
		inline const T& __getitem__(const aiw::Vec<D> &r) const { return get(r); }
		inline void __setitem__(const aiw::Ind<D> &p, const T& v){ (*this)[p] = v; }
		inline void __setitem__(const aiw::Vec<D> &r, const T& v){ (*this)[r] = v; }
		
		// (int i, int j, ...) ???
		
		inline aiw::Ind<D> inbox(size_t offset) const {
			Ind<D> pos;
			for(int i=0; i<D; i++){
				int a = axes[i]; pos[a] = offset%box[a];
				if(mul[a]<0) pos[a] = box[a]-pos[a]-1;
				offset /= box[a];
			}
			return pos;
		}
		inline aiw::Ind<D> first() const { Ind<D> pos; for(int i=0; i<D; i++) if(mul[i]<0) pos[i] = box[i]-1; return pos; }
		inline bool next(aiw::Ind<D> &pos) const {
			for(int i=0; i<D; i++){
				int a = axes[i]; 
				if(mul[a]>0){
					if(++(pos[a])<box[a]) return true;
					pos[a] = 0;
				} else {
					if(--(pos[a])>=0) return true;
					pos[a] = box[a]-1; 
				}
			}				
			return false;
		}
		//----------------------------------------------------------------------
		Mesh copy() const { Mesh A; A.init(box); for(Ind<D> pos; pos^=box; ++pos) A[pos] = (*this)[pos]; return A; }		
		Mesh flip(int a, bool axe=true) const {
			Mesh A(*this); Ind<D> I; I[a] = box[a]-1; A.ptr = (void*)&((*this)[I]); A.mul[a] = -mul[a];
			if(axe){
				A.bmin[a] = bmax[a]; A.bmax[a] = bmin[a]; 
				if(logscale&1<<a){ A.step[a] = 1./step[a]; A.rstep[a] = exp(log(bmin[a]/bmax[a])/box[a]); }
				else { A.step[a] = -step[a]; A.rstep[a] = -rstep[a]; }
			}
			return A;
		}
	private:
		template <typename T2, int D2> void set_axe(int a, const Mesh<T2, D2> &M, int m){
			mul[a] = M.mul[m]; box[a] = M.box[m]; axes[a] = M.axes[m]; mul[a] = M.mul[m];
			bmin[a] = M.bmin[m]; bmax[a] = M.bmax[m]; step[a] = M.step[m]; rstep[a] = M.rstep[m];
			if(M.logscale&1<<m) logscale |= 1<<a; else logscale &= ~(1<<a);
		}
	public:
		Mesh transpose(int a, int b) const { Mesh A(*this); A.set_axe(b, *this, a); A.set_axe(a, *this, b); return A; }
		//----------------------------------------------------------------------
		Mesh crop(aiw::Ind<D> a, aiw::Ind<D> b, aiw::Ind<D> d=Ind<D>(1)) const {
			Mesh A(*this); 
			for(int i=0; i<D; i++){
				if(a[i]<0) a[i] += box[i]; if(b[i]<=0) b[i] += box[i];
				A.box[i] = (b[i]-a[i]-1)/d[i]+1;
				if(logscale&1<<i){ 
					A.bmin[i] = bmin[i]*pow(step[i], a[i]); A.step[i] = pow(step[i], d[i]); 
					A.bmax[i] = A.bmin[i]*pow(A.step[i], A.box[i]);
					A.rstep[i] = exp(log(A.bmax[0]/A.bmin[0])/A.box[i]);
				} else {
					A.bmin[i] = bmin[i]+step[i]*a[i]; A.step[i] *= d[i]; 
					A.bmax[i] = A.bmin[i]+A.step[i]*b[i]; A.rstep[i] /= d[i];
				}
			}
			A.mul = mul&d; A.ptr = (char*)ptr + mul*a;
			return A;
		}
		//----------------------------------------------------------------------
		template <class T2, int D2> Mesh<T2, D2> slice(Ind<D> pos, size_t offset_in_cell) const {
			if(!ptr) WRAISE("can't make slice from empty Mesh", pos, box, sizeof(T), D, sizeof(T2), D2, offset_in_cell);
			int n = 0; Mesh<T2, D2> A;
			for(int i=0; i<D; i++)
				if(pos[i]==-1){  
					if(n>=D2) WRAISE("too many -1 values in pos", i, pos, box, sizeof(T), D, sizeof(T2), D2, offset_in_cell);
					A.set_axe(n, *this, i); n++;
				} else if(pos[i]<0 || box[i]<=pos[i])
					WRAISE("pos out of range", i, pos, sizeof(T), D, sizeof(T2), D2, box, offset_in_cell);
			if(n<D2) WRAISE("too small -1 values in pos", n, pos, box, sizeof(T), D, sizeof(T2), D2, offset_in_cell);
			A.mem = mem; A.ptr = (char*)ptr+mul*pos+offset_in_cell; A.box.prod(A.sz);
			return A;
		}
		//----------------------------------------------------------------------
		template<int P> inline const T& periodic_bc(Ind<D> pos) const {
			for(int i=0; i<D; i++) if(P&(1<<i)){
					while(pos[i]<0) pos[i] += box[i];
					if(pos[i]>=box[i]) pos[i] %= box[i];
				}
			return get(pos);
		}
		template<int P> inline T& periodic_bc(Ind<D> pos){ return (T&)(((const Mesh*)this)->periodic_bc<P>(pos)); }
		//----------------------------------------------------------------------
		// coords содержит режимы вывода для каждой из координатных осей: 
		//    0 --- выводить значения из сетки вдоль оси в одну строку через пробел
		//    1 --- выводить номер ячейки
		//    2 --- выводить координату центра ячейки
		//    3 --- не выводить ни номер ячейки ни координату центра ячейки
		//   +4 --- не выводить пустую строку при изменении номера ячейки, не влияет на режим 0
#ifndef SWIG				
		template <typename S> void out2dat(S &&str, Ind<D> coords=Ind<D>(2), const char* prefix=nullptr) const {
			Ind<D> B1 = box, B2 = box; int nl_id = -1;
			for(int i=0; i<D; i++){ 
				if(coords[i]==4) coords[i] = 0;
				if(coords[i]==0 && B1[i]) B1[i] = 1; else B2[i] = 1; 
				if(nl_id==-1 && coords[i]&3 && !(coords[i]&4)) nl_id = i;
			}
			// WOUT(box, coords, B1, B2, nl_id);
			for(Ind<D> pos; pos^=B1; ++pos){
				if(prefix) str<<prefix<<" ";
				Vec<D> r = pos2coord(pos);
				for(int i=0; i<D; i++) if((coords[i]&3)!=3){ if(coords[i]&1) str<<pos[i]<<" "; else str<<r[i]<<" "; }
				for(Ind<D> pos2; pos2^=B2; ++pos2) str<<(*this)[pos+pos2]<<" ";
				str<<"\n"; if(nl_id!=-1 && pos[nl_id]==box[nl_id]-1) str<<"\n";
			}
			str.flush();
		}
#endif //SWIG
		void out2dat(std::ostream &str=std::cout, aiw::Ind<D> coords=aiw::Ind<D>(2), const char* prefix=nullptr) const { 
			out2dat(std::move(str), coords, prefix); 
		}
		void out2dat(aiw::IOstream &str, aiw::Ind<D> coords=aiw::Ind<D>(2), const char* prefix=nullptr) const { 
			out2dat(std::move(str), coords, prefix); 
		}
		//----------------------------------------------------------------------
		void min_max(T &a, T &b, aiw::Ind<D> &pos_a, aiw::Ind<D> &pos_b) const {
			Ind<D> pos = first(); pos_a = pos_b = pos; a = b = (*this)[pos];
			do {
				const T& x = (*this)[pos];
				if(a>x){ a = x; pos_a = pos; }
				if(b<x){ b = x; pos_b = pos; }
			} while(next(pos));
		}
		//----------------------------------------------------------------------
		void fill(const T &x){ Ind<D> pos = first(); do (*this)[pos] = x; while(next(pos)); }
		template <typename T2> void fill(const Mesh<T2, D> &M){
			Ind<D> up = box<<M.box; for(Ind<D> pos; pos^=up; ++pos) (*this)[pos] = M[pos];
		}
		void fill(const Mesh &M){ 
			Ind<D> up = box<<M.box; for(Ind<D> pos; pos^=up; ++pos) (*this)[pos] = M[pos];
		}

#ifndef SWIG		
		void fill(aiw::IOstream &&S){
			std::string h; int rD, szT; Ind<D> b; size_t s = S.tell(); S>h>rD>szT>b;
			if(rD!=D || szT!=sizeof(T)){ S.seek(s); WRAISE("incorrect Mesh fill ", D, sizeof(T), S.name, rD, szT, b, s); }
			Ind<D> up = b<<box, m; s = S.tell();
			m[0] = sizeof(T); for(int i=1; i<D; ++i) m[i] = m[i-1]*b[i-1]; 
			for(Ind<D> pos; pos^=up; ++pos){
				if(pos[0]==0) S.seek(s+m*pos);
				S.read(&(*this)[pos], sizeof(T));
			}
		}
		template <typename S> void fill_from_dat(S&& str, Ind<D> rcols=Ind<D>(), int vcol=0){
			Ind<D+1> columns = rcols|vcol;
			if(columns==Ind<D+1>()) for(int i=0; i<D+1; i++) columns[i] = i;
			long pos;
			do {
				char buf[4096]; pos = str.tellg(); str.getline(buf, 4096); // читаем строку
				int i0; for(i0=0; i0<4096 && buf[i0]; i0++) if(buf[i0]!=' ' && buf[i0]!='\t') break; // пропускаем ведущие пробелы
				if(buf[i0] && buf[i0]!='#'){ // если строка не пустая и не комментарий
					std::stringstream ss(buf+i0); Vec<D> r; T v;
					for(int i=0; i<D+1; i++) if(columns[i]<D) ss>>r[i]; else ss>>v;
					if(ss.rdstate()==1) (*this)[r] = v;
				}
			} while(pos!=str.tellg());			
		}
#endif //SWIG
		void fill(aiw::IOstream &S){ fill(std::move(S)); }
		static const int D1=D+1;
		void fill_from_dat(aiw::IOstream &S, Ind<D> rcols=Ind<D>(), int vcol=0){ fill_from_dat(std::move(S), rcols, vcol); }
		void fill_from_dat(std::istream &S, Ind<D> rcols=Ind<D>(), int vcol=0){ fill_from_dat(std::move(S), rcols, vcol); }
		//----------------------------------------------------------------------
		// operators +, -, *, /, % etc?

		std::string __getstate__() const { 
			std::stringstream buf;
			uint32_t h_sz = head.size(); buf.write((const char*)&h_sz, sizeof(h_sz)); buf<<head;
			buf.write((const char*)&box, sizeof(box));          
			buf.write((const char*)&out_value, sizeof(out_value));
			buf.write((const char*)&bmin, sizeof(bmin));
			buf.write((const char*)&bmax, sizeof(bmax));
			buf.write((const char*)&logscale, sizeof(logscale));
			for(Ind<D> pos; pos^=box; ++pos) buf.write((const char*)&get(pos), sizeof(T));
			return buf.str();
		}
		void __C_setstate__(const std::string &state){
			std::stringstream buf(state);
			uint32_t h_sz = head.size(); buf.read((char*)&h_sz, sizeof(h_sz)); 
			head.resize(h_sz); buf.read(&(head[0]), h_sz); // ???
			Ind<D> box_; Vec<D> bmin_, bmax_; int logscale_; 
			buf.read((char*)&box_, sizeof(box));          
			buf.read((char*)&out_value, sizeof(out_value));
			buf.read((char*)&bmin_, sizeof(bmin));
			buf.read((char*)&bmax_, sizeof(bmax));
			buf.read((char*)&logscale_, sizeof(logscale));
			init(box_, bmin_, bmax_, logscale_);
			for(Ind<D> pos; pos^=box; ++pos) buf.read((char*)&get(pos), sizeof(T));
		}
		static const bool _racs_pull_lock = true;
		size_t __sizeof__() const { return sizeof(Mesh) + head.size() + (mem?mem->get_size()*mem->get_sizeof():0); }
	};
//------------------------------------------------------------------------------
	template <typename T, int D> aiw::IOstream& operator < (aiw::IOstream &S, const aiw::Mesh<T, D> &M){ M.dump(S); return S; }
	template <typename T, int D> aiw::IOstream& operator > (aiw::IOstream &S,       Mesh<T, D> &M){ M.load(S); return S; }
//------------------------------------------------------------------------------
};
#endif //AIW_MESH_HPP
