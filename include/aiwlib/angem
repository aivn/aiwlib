// -*- C++ -*-
#ifndef AIW_ANGEM_HPP
#define AIW_ANGEM_HPP

/**
 * Copyright (C) 2017 Antov V. Ivanov <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#include "vec"

namespace aiw{
	//--------------------------------------------------------------------------
	// проекция точки r на плоскость заданную точкой p и нормалью n (|n|==1)
	template <int D, typename T> Vec<D, T> point2plane(const Vec<D, T> &r, const Vec<D, T> &p, const Vec<D, T> &n){	return r-(r-p)*n*n;	}
	//--------------------------------------------------------------------------
	// расчет точки пересечения прямой (или луча) проходящей через точку r в направлении g (|g|==1) и плоскости заданной точкой p и нормалью n (|n|==1)
	template <int D, typename T> bool cross_plane(Vec<D, T> &res, const Vec<D, T> &r, const Vec<D, T> &g,
												  const Vec<D, T> &p, const Vec<D, T> &n, bool ray=false){
		double rpn = (r-p)*n;
		if(ray && rpn*n*g>=0) return false;
		double ng = n*g; if(fabs(ng)<1e-8) return false;
		res = r-g*(rpn/ng); return true;
	}
	// расчет точки пересечения прямой (или луча) проходящей через точку r в направлении g (|g|==1) и плоскости заданной точкой p и осью координат axe
	template <int D, typename T> bool cross_plane(Vec<D, T> &res, const Vec<D, T> &r, const Vec<D, T> &g,
												  const Vec<D, T> &p, int axe, bool ray=false){
		double rpn = (r[axe]-p[axe]);
		if(ray && rpn*g[axe]>=0) return false;
		if(fabs(g[axe])<1e-8) return false;
		res = r-g*(rpn/g[axe]); return true;
	}
	//--------------------------------------------------------------------------
	// расчет точки пересечения луча выходящего из точки r в направлении g (|g|==1) и параллепипеда заданного точками a, b (a<=r && r<=b)
	template <int D, typename T> Vec<D, T> shoot_box_out(const Vec<D, T> &r, const Vec<D, T> &g, const Vec<D, T> &a, const Vec<D, T> &b){
		double len = -1; Vec<D, T> res, tmp;
		for(int axe=0; axe<D; axe++){
			if(cross_plane(tmp, r, g, a, axe, true)){ double tmp_l = (r-tmp).abs(); if(len<0 || len>tmp_l){ len = tmp_l; res = tmp; } }
			if(cross_plane(tmp, r, g, b, axe, true)){ double tmp_l = (r-tmp).abs(); if(len<0 || len>tmp_l){ len = tmp_l; res = tmp; } }
		}
		return res;
	}
	//--------------------------------------------------------------------------
	// разбиение параллелпипеда (a, b) плоскостью с нормалью n проходящей через точку r, возвращает объемы параллелепипеда ниже и выше плоскости
	template <int D, typename T> Vec<2, T> split_box_by_plane(const Vec<D, T> &r, const Vec<D, T> &n, Vec<D, T> a, Vec<D, T> b, int order=10){
		Vec<D, T> ab = b-a; a -= r; b -= r; Vec<2, T> res;
		if(order<=0){ T an = a*n; return (an*(b*n)<0?Vec<2, T>(.5): (an<0? Vec<2, T>(1., 0.): Vec<2, T>(0., 1.)))*ab.prod(); 
		} else {
			Vec<D, T> c = (a+b)*.5; if(fabs(c*n)<fabs(n*ab)/(1<<(1+order))) return Vec<2, T>(.5)*ab.prod();  // оптимизация при прохождении около центра куба
			for(Ind<D> sub; sub^=ind(2); ++sub){ // цикл по под-кубам 
				int sign = -2;
				for(Ind<D> vid; vid^=ind(2); ++vid){  // цикл по вершинам под-куба
					Vec<D, T> r; for(int i=0; i<D; i++) r[i] = vid[i]?(sub[i]?b[i]:c[i]):(sub[i]?c[i]:a[i]); 
					if(sign==-2) sign = r*n<0? -1: 1;
					else if(sign!=(r*n<0? -1: 1)){
						sign = 2; Vec<D, T> aa, bb;
						for(int i=0; i<D; i++) if(sub[i]){ aa[i] = c[i]; bb[i] = b[i]; } else { aa[i] = a[i]; bb[i] = c[i]; }
						res += split_box_by_plane(Vec<D, T>(), n, aa, bb, order-1);
						break;
					}
				}
				if(sign!=2) res[(1+sign)/2] += ab.prod()/(1<<D);
			}
		}
		return res;
	}
	template <typename T> Vec<2, T> split_box_by_plane(const Vec<2, T> &r, const Vec<2, T> &n, Vec<2, T> a, Vec<2, T> b){
		a -= r; b -= r; Vec<2, T> vs[4] = {a, vec(a[0], b[1]), b, vec(b[0], a[1])}; T V = (b-a).prod();
		bool sign[4]; int c = 0; for(int i=0; i<4; i++) c += (sign[i] = vs[i]*n>0.);
		// 1 2   
		// 0 3
		if(c==0) return Vec<2, T>(V, 0);
		if(c==4) return Vec<2, T>(0, V);
		if(c==2){
			T Va, Vb;
			if((sign[0] && sign[3]) || (sign[1] && sign[2])){ // горизонтальное разбиение
				T Yc = -n[0]*(a[0]+b[0])/(2*n[1]);
				Va = (b[0]-a[0])*(Yc-a[1]); Vb = V-Va;
			} else {  // вертикальное разбиение
				T Xc = -n[1]*(a[1]+b[1])/(2*n[0]);
				Va = (b[1]-a[1])*(Xc-a[0]); Vb = V-Va;
			}
			if(sign[0]) return vec(Vb, Va); else return vec(Va, Vb);
		}
		// c==1 || с==3, откушена одна вершина
		int vid; for(vid=0; vid<4; vid++) if(sign[vid]==(c==1)) break;
		T X = -n[1]*(vs[vid][1])/n[0], Y = -n[0]*(vs[vid][0])/n[1];
		T Va = fabs((X-vs[vid][0])*(Y-vs[vid][1]))*.5, Vb = V-Va; 
		if(sign[vid]) return vec(Vb, Va);
		return vec(Va, Vb);
	}
	//--------------------------------------------------------------------------
	/*
	// разбиение тетраэдра tetr плоскостью с нормалью n проходящей через точку r, возвращает объемы тетраэдра ниже и выше плоскости
	template <typename T> Vec<2, T> split_tetr_by_plane(const Vec<3, T> &r, const Vec<3, T> &n, Vec<3, T> *tetr){
		T V0 = fabs((tetr[1]-tetr[0])%(tetr[2]-tetr[0])*(tetr[3]-tetr[0]))/6; // объем тетраэдра
		
		int n = 0, n_cr = 0; Vec<3> cr[6]; bool f_cr[6] = {false};
		T nr = n*r, wr[4]; for(int i=0; i<4; i++) wr[i] = tetr[i]*n-nr;
		for(int i=0; i<3; i++)  // цикл по вершинам тетраэдра
			for(int j=i+1; j<4; j++){
				if(wr[i]*wr[j]<=0){
					f_cr[n] = true; n_cr++;
					cr[n] = (tetr[i]*fabs(wr[i]) + tetr[j]*fabs(wr[j]))/(fabs(wr[i])+fabs(wr[j]));
				}
				n++;
			}
		if(n_cr==3){
			
		}
		
		if(n_cr==0) return ...;
		if(n_cr==4) return ...;
		if(n_cr==...)
	}	
	//--------------------------------------------------------------------------
	*/
	// intriagle
};
#endif //AIW_ANGEM_HPP
