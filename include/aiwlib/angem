// -*- C++ -*-
#ifndef AIW_ANGEM_HPP
#define AIW_ANGEM_HPP

/**
 * Copyright (C) 2017 Antov V. Ivanov <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#include "vec"

namespace aiw{
	//--------------------------------------------------------------------------
	// проекция точки r на плоскость заданную точкой p и нормалью n (|n|==1)
	template <int D, typename T> Vec<D, T> point2plane(const Vec<D, T> &r, const Vec<D, T> &p, const Vec<D, T> &n){	return r-(r-p)*n*n;	}
	//--------------------------------------------------------------------------
	// расчет точки пересечения прямой (или луча) проходящей через точку r в направлении g (|g|==1) и плоскости заданной точкой p и нормалью n (|n|==1)
	template <int D, typename T> bool cross_plane(Vec<D, T> &res, const Vec<D, T> &r, const Vec<D, T> &g,
												  const Vec<D, T> &p, const Vec<D, T> &n, bool ray=false){
		double rpn = (r-p)*n;
		if(ray && rpn*n*g>=0) return false;
		double ng = n*g; if(fabs(ng)<1e-8) return false;
		res = r-g*(rpn/ng); return true;
	}
	// расчет точки пересечения прямой (или луча) проходящей через точку r в направлении g (|g|==1) и плоскости заданной точкой p и осью координат axe
	template <int D, typename T> bool cross_plane(Vec<D, T> &res, const Vec<D, T> &r, const Vec<D, T> &g,
												  const Vec<D, T> &p, int axe, bool ray=false){
		double rpn = (r[axe]-p[axe]);
		if(ray && rpn*g[axe]>=0) return false;
		if(fabs(g[axe])<1e-8) return false;
		res = r-g*(rpn/g[axe]); return true;
	}
	//--------------------------------------------------------------------------
	// расчет точки пересечения луча выходящего из точки r в направлении g (|g|==1) и параллепипеда заданного точками a, b (a<=r && r<=b)
	template <int D, typename T> Vec<D, T> shoot_box_out(const Vec<D, T> &r, const Vec<D, T> &g, const Vec<D, T> &a, const Vec<D, T> &b){
		double len = -1; Vec<D, T> res, tmp;
		for(int axe=0; axe<D; axe++){
			if(cross_plane(tmp, r, g, a, axe, true)){ double tmp_l = (r-tmp).abs(); if(len<0 || len>tmp_l){ len = tmp_l; res = tmp; } }
			if(cross_plane(tmp, r, g, b, axe, true)){ double tmp_l = (r-tmp).abs(); if(len<0 || len>tmp_l){ len = tmp_l; res = tmp; } }
		}
		return res;
	}
	//--------------------------------------------------------------------------
	// разбиение параллелпипеда (a, b) плоскостью с нормалью n проходящей через точку r, возвращает объемы параллелепипеда ниже и выше плоскости
	template <int D, typename T> Vec<2, T> split_box_by_plane(const Vec<D, T> &r, const Vec<D, T> &n, Vec<D, T> a, Vec<D, T> b, int order=10){
		Vec<D, T> ab = b-a; a -= r; b -= r; Vec<2, T> res;
		if(order<=0){ T an = a*n; return (an*(b*n)<0?Vec<2, T>(.5): (an<0? Vec<2, T>(1., 0.): Vec<2, T>(0., 1.)))*ab.prod(); 
		} else {
			Vec<D, T> c = (a+b)*.5; if(fabs(c*n)<fabs(n*ab)/(1<<(1+order))) return Vec<2, T>(.5)*ab.prod();  // оптимизация при прохождении около центра куба
			for(Ind<D> sub; sub^=ind(2); ++sub){ // цикл по под-кубам 
				int sign = -2;
				for(Ind<D> vid; vid^=ind(2); ++vid){  // цикл по вершинам под-куба
					Vec<D, T> r; for(int i=0; i<D; i++) r[i] = vid[i]?(sub[i]?b[i]:c[i]):(sub[i]?c[i]:a[i]); 
					if(sign==-2) sign = r*n<0? -1: 1;
					else if(sign!=(r*n<0? -1: 1)){
						sign = 2; Vec<D, T> aa, bb;
						for(int i=0; i<D; i++) if(sub[i]){ aa[i] = c[i]; bb[i] = b[i]; } else { aa[i] = a[i]; bb[i] = c[i]; }
						res += split_box_by_plane(Vec<D, T>(), n, aa, bb, order-1);
						break;
					}
				}
				if(sign!=2) res[(1+sign)/2] += ab.prod()/(1<<D);
			}
		}
		return res;
	}
	//--------------------------------------------------------------------------
	// intriagle
};
#endif //AIW_ANGEM_HPP
