// -*- C++ -*-
#ifndef AIW_DEBUG_HPP
#define AIW_DEBUG_HPP

/**
 * Copyright (C) 2016-17, 2020-21, 2025 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#ifndef __NVCC__

#include <cstring>
#include <iostream>
#include <sstream>
#include <cmath>

namespace aiw{
	//--------------------------------------------------------------------------
	struct SplitArgForOut{
		int end, next;
		SplitArgForOut(const char *str){
			const char *br = "()[]{}"; int brc[3] = {0, 0, 0};
			for(end=0; str[end] && (brc[0] || brc[1] || brc[2] || str[end]!=','); ++end)
				for(int k=0; k<6; ++k) if(str[end]==br[k]){ brc[k/2] += 1-k%2*2; break; }
			next = str[end]?end+1:end; while(str[next] && (str[next]==' ' || str[next]=='\t')) next++;
		}
	};
	//--------------------------------------------------------------------------
	// template <typename T> void debug_out(std::ostream& out, const char* str, T x){ out<<str<<"="<<x; }
	inline void debug_out(std::ostream&, const char*){}
	template <typename T, typename ... Args> void debug_out(std::ostream& out, const char* str, T x, Args ... args){
		SplitArgForOut key(str);
		if(str[0]!='"'){ out.write(str, key.end); out<<"="; } out<<x;
		if(sizeof...(Args)>0 && !(str[0]=='"' && str[key.end-1]!=' ')) out<<", ";
		debug_out(out, str+key.next, args...);
	} 
	//--------------------------------------------------------------------------
	template <typename T> bool is_bad_value(T){ return false; }
	inline bool is_bad_value(float  x){ return (std::isnan(x)) || (std::isinf(x)); }
	inline bool is_bad_value(double x){ return (std::isnan(x)) || (std::isinf(x)); }
	template <typename T, typename ... Args> bool is_bad_value(T x, Args ... args){ return is_bad_value(x) || is_bad_value(args...); }
	//--------------------------------------------------------------------------
	template <typename T> struct CSVOut{
		const T &ref;
		CSVOut(const T &ref_):ref(ref_){}
	};
	template <typename T> CSVOut<T> csv_out(const T& ref){ return CSVOut<T>(ref); }
	template <typename T> std::ostream& operator << (std::ostream& S, const CSVOut<T>& R){ return S<<R.ref; }
	//--------------------------------------------------------------------------
}   // end of namespace aiw 

#ifndef AIW_WIN32
#include <unistd.h>
#define WMSG(args...) { std::cerr<<"#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<": ";	\
		aiw::debug_out(std::cerr, #args, args); std::cerr<<"\n"; }
#ifdef EBUG
#   define WSTR(out, args...) { out<<"#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<": "; \
		aiw::debug_out(out, #args, args); out<<"\n"; }
#   define WASSERT(cond, args...) if(!(cond)) WRAISE(args)
#else //EBUG
#   define WSTR(S, args...)
#   define WASSERT(cond, args...)
#endif //EBUG

#define WOUT(args...) WSTR(std::cout, args)
#define WERR(args...) WSTR(std::cerr, args)
#define WCHK(args...) WASSERT(!aiw::is_bad_value(args), "some values are bad: ", args) 
#define WARNING(args...){ std::cerr<<"\033[1;4m#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<":\033[0m "; \
		aiw::debug_out(std::cerr, #args, args); std::cerr<<"\n"; }
#define WRAISE(args...) { std::stringstream	bUfFoRwRaIsE;		\
		bUfFoRwRaIsE<<"\033[31m#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<":\033[0m "; \
		if(errno) bUfFoRwRaIsE<<" [\033[31;1;5m"<<strerror(errno)<<"\033[0m] ";	\
		aiw::debug_out(bUfFoRwRaIsE, #args, args);	bUfFoRwRaIsE<<'\n';	\
		std::cerr<<bUfFoRwRaIsE.str()<<std::flush;	throw bUfFoRwRaIsE; \
	}	
#else //AIW_WIN32
#include "unistd.h"
namespace aiw{  // это заглушка для Visual Studio etc.
	template <typename ... Args> void WASSERT(bool cond, const char* msg, Args ... args){
#ifdef EBUG
		if(!cond) throw(msg);
#endif //EBUG
	}
	template <typename ... Args> void WOUT(Args ... args){}
	template <typename ... Args> void WERR(Args ... args){}
	template <typename ... Args> void WCHK(Args ... args){}
	template <typename ... Args> void WARNING(const char *msg, Args ... args){ std::cout<<msg; }

	template <typename ... Args> void WRAISE(const char* msg, Args ... args){ throw(msg); }
}
#endif //AIW_WIN32		
//------------------------------------------------------------------------------
#define NAME_OF_AUTODOC1(num) autodoc_##num
#define NAME_OF_AUTODOC2(num) NAME_OF_AUTODOC1(num)
#define AUTODOC(C) static constexpr const char * NAME_OF_AUTODOC2(__LINE__) = __FILE__ ":" C;
//------------------------------------------------------------------------------

#else //__NVCC__
#define WOUT(...)
#define WMSG(...)
#define WERR(...)
#define WASSERT(...)
#define WRAISE(...)
#endif //__NVCC__

#endif //AIW_DEBUG_HPP
