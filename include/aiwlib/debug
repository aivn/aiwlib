// -*- C++ -*-
#ifndef AIW_DEBUG_HPP
#define AIW_DEBUG_HPP

/**
 * Copyright (C) 2016, 2017 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#ifndef SWIG		

#include <cerrno>
#include <cstring>
#include <iostream>
#include <sstream>
#include <exception>
#include <tuple>
#include <cmath>

namespace aiw{
	//--------------------------------------------------------------------------
	struct SplitArgForOut{
		int end, next;
		SplitArgForOut(const char *str);
	};
	//--------------------------------------------------------------------------
	template <typename T> void debug_out(std::ostream& out, const char* str, T x){ out<<str<<"="<<x; }
	template <typename T, typename ... Args> void debug_out(std::ostream& out, const char* str, T x, Args ... args){
		SplitArgForOut key(str);
		out.write(str, key.end); out<<"="<<x<<", ";
		debug_out(out, str+key.next, args...);
	}
	//--------------------------------------------------------------------------
	template <typename T> bool is_bad_value(T){ return false; }
	inline bool is_bad_value(float  x){ return (std::isnan(x)) || (std::isinf(x)); }
	inline bool is_bad_value(double x){ return (std::isnan(x)) || (std::isinf(x)); }
	template <typename T, typename ... Args> bool is_bad_value(T x, Args ... args){ return is_bad_value(x) || is_bad_value(args...); }
	//--------------------------------------------------------------------------
	/*
	struct DebugStackFrame{
		std::stringstream buf;
		DebugStackFrame(){ buf.copyfmt(std::cerr); }
		~DebugStackFrame(){ if(std::uncaught_exception()) std::cerr<<buf.str(); }
	};
	*/
	struct BaseDebugStackTupleFrame{
		virtual void out_msg(std::ostream&) = 0;
		BaseDebugStackTupleFrame(bool reg); 
		virtual ~BaseDebugStackTupleFrame(); 
	};
	template<typename ... Args> struct DebugStackTupleFrame: public BaseDebugStackTupleFrame{
		std::tuple<Args...> data;
		DebugStackTupleFrame(bool reg): BaseDebugStackTupleFrame(reg){}
		
		template <int I> struct counter_t{};
		void out_node(counter_t<1>, std::ostream& out, const char* str){ out<<str<<"="<<std::get<sizeof...(Args)-1>(data);	}
		template <int I> void out_node(counter_t<I>, std::ostream& out, const char* str){
			SplitArgForOut key(str);
			out.write(str, key.end); out<<"="<<std::get<sizeof...(Args)-I>(data)<<", ";
			out_node(counter_t<I-1>(), out, str+key.next, data);
		}
		void out_msg(std::ostream &out){
			out<<"#"<<std::get<0>(data)<<" "<<std::get<1>(data)<<"()"<<std::get<2>(data)<<": ";
			out_node(counter_t<sizeof...(Args)-4>(), out, std::get<3>(data)); out<<'\n';
		}	
		~DebugStackTupleFrame(){ if(std::uncaught_exception()) out_msg(std::cerr); }
	};
	template<typename ... Args> DebugStackTupleFrame<const char*, const char*, int, const char*, Args...>
	make_debug_stack_tuple_frame(bool reg, const char *fname, const char *func, int line, const char *keys, Args... args){
		DebugStackTupleFrame<const char*, const char*, int, const char*, Args...> res(reg);
		res.data = std::make_tuple(fname, func, line, keys, args...);
		return res;
	}
	//--------------------------------------------------------------------------
	void init_segfault_hook();
	//--------------------------------------------------------------------------
};

#ifdef EBUG
#   define WSTR(out, args...) { out<<"#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<": "; \
		aiw::debug_out(out, #args, args); out<<"\n"; }
#   define NAME_OF_STFR1(num) tmp_wrap_stack_frame##num
#   define NAME_OF_STFR2(num) NAME_OF_STFR1(num)
//# define WEXC(args...) aiw::DebugStackFrame NAME_OF_STFR2(__LINE__); WSTR(NAME_OF_STFR2(__LINE__).buf, args)
#   define WEXC(args...) auto NAME_OF_STFR2(__LINE__) = aiw::make_debug_stack_tuple_frame(false, __FILE__, __FUNCTION__, __LINE__, #args,  args);
#   define WEXT(args...) auto NAME_OF_STFR2(__LINE__) = aiw::make_debug_stack_tuple_frame(true,  __FILE__, __FUNCTION__, __LINE__, #args,  args);
#   define WASSERT(cond, msg, args...) if(!(cond)) WRAISE((msg), args)
#else //EBUG
#   define WSTR(S, args...)
#   define WEXC(args...)
#   define WEXT(args...)
#   define WASSERT(cond, msg, args...)
#endif //EBUG

#define WOUT(args...) WSTR(std::cout, args)
#define WERR(args...) WSTR(std::cerr, args)
#define WCHK(args...) WASSERT(!is_bad_value(args), "some values are bad: ", args) 
#define WARNING(msg, args...){ std::cerr<<"\033[1;4m#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<":\033[0m "<<msg; \
		aiw::debug_out(std::cerr, #args, args); std::cerr<<"\n"; }
#define WRAISE(msg, args...){ std::stringstream bUfFoRwRaIsE;			\
		bUfFoRwRaIsE<<"\033[31m#"<<__FILE__<<" "<<__FUNCTION__<<"() "<<__LINE__<<":\033[0m "<<msg; \
		if(errno) bUfFoRwRaIsE<<" [\033[31;1;5m"<<strerror(errno)<<"\033[0m] ";	\
		aiw::debug_out(bUfFoRwRaIsE, #args, args); bUfFoRwRaIsE<<"\n";	\
		std::cerr<<bUfFoRwRaIsE.str(); throw bUfFoRwRaIsE.str().c_str(); \
	}	
//------------------------------------------------------------------------------
#endif //SWIG		
#endif //AIW_DEBUG_HPP
