// -*- C++ -*-
#ifndef AIW_AMRVIEW_HPP
#define AIW_AMRVIEW_HPP

/**
 * Copyright (C) 2019 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 *
 * For read and view AMR data only!
 **/

#include <string>
#include <vector>
#include "vec"
#include "iostream"
#include "zcube"

namespace aiw{
	//--------------------------------------------------------------------------
	class AdaptiveMeshView{
		static const int Dmax = 4; // максимальная поддерживаемая размерность
		//----------------------------------------------------------------------
		struct tile_t{
			uint16_t rank;            // ранг (степень вложенности) тайла
			Ind<Dmax> pos;            // позиция нижнего левого угла тайла на мелкой сетке
			std::vector<bool> usage;  // длины 1<<(D*R) для ячеек.
			std::vector<bool> ghost;  // длины 1<<(D*R) для ячеек.
			std::vector<bool> split;  // длины 1<<(D*R) для ячеек.
			tile_t *parent = nullptr, *childs[1<<Dmax] = {0}; // родительский и дочерние тайлы
			int find_child_ID(tile_t *t) const { for(int i=0; i<(1<<Dmax); i++){ if(childs[i]==t) return i; } return -1; }
				
			virtual float get(int offset, AdaptiveMeshView *msh) const = 0; // доступ к ячейке
			void set_child_pos(int D, int dR2max){
				for(int i=0; i<(1<<D); i++) if(childs[i]){
						for(int j=0; j<D; j++) childs[i]->pos[j] = pos[j] + bool(i&(1<<j))*(1<<dR2max);
						childs[i]->set_child_pos(D, dR2max-1);
					}
				}
			tile_t* root(){ return parent? parent->root(): this; }
		}; // end of struct tile_t
		//----------------------------------------------------------------------
		struct heavy_tile_t: public tile_t{
			std::vector<char> data; // длины 1<<(D*R) для ячеек!
			
			float raw_get(int offset, AdaptiveMeshView *msh) const { return  *(float*)&(data[offset*msh->core->szT + msh->offset_in_cell]);	}
			float get(int offset, AdaptiveMeshView *msh) const { return usage[offset]? (msh->offset_in_cell>=0? raw_get(offset, msh) : float(rank)): nanf(""); }
		}; // end of struct heavy_tile_t		
		//----------------------------------------------------------------------
		struct light_tile_t: public tile_t{
			heavy_tile_t *page;
			std::vector<uint16_t> chunks; // длины 1<<(D*(R-1)) для чанков, содержит смещения чанков
			float get(int offset, AdaptiveMeshView *msh) const {
				int c = 1<<msh->core->D;
				// WOUT(offset, usage[offset], chunks[offset>>msh->D], (chunks[offset>>msh->D]-1)*c+offset%c);
				return usage[offset]? (msh->offset_in_cell>=0? page->raw_get((chunks[offset>>msh->core->D]-1)*c+offset%c, msh) :
									   float(msh->offset_in_cell==-1? rank: rank-.5)): nanf("");
			}
		}; // end of struct light_tile_t
	public:
#ifndef SWIG
		//----------------------------------------------------------------------
		struct iterator{
			uint32_t offset = 0, mask = 0;  // смещение внутри тайла и маска (для построения среза), содержит 1 на позициях которые могут меняться
			tile_t *tile = nullptr;
			AdaptiveMeshView *msh = nullptr;
			int axes[2] = {0};  // номера осей по которым происходит итерирование
			Ind<2> imin, imax;  // границы ячейки на мелкой сетке  на обрезанном изображении

			float operator *() const { return tile? tile->get(offset, msh): nanf(""); }
			void next();
			bool check_bbox() const { for(int i=0; i<2; i++) if(imax[i]<0 || imin[i]>=msh->box_[i]) return false; return true; }
			void operator ++ (){ next();  while(tile && !check_bbox()) next(); }
			bool operator == (const iterator &) const { return !tile; }
			bool operator != (const iterator &) const { return tile; }
			int rank() const { return tile->rank; }
			bool tile_bound(int axe) const; // axe - номер оси + 1 со знаком (-слева, +справа) т.е. -/+1, -/+2 
		}; // end of struct iterator
		//------------------------------------------------------------------
#endif //SWIG
	private:
		//----------------------------------------------------------------------
		struct core_t{
			int R, D, szT;  // ранг (размер) тайла, размерность сетки, размер ячейки
			int max_rank;   // максимальный ранг (степень вложенности) тайла
			Ind<Dmax> box;  // размер сетки нулевого ранга В ТАЙЛАХ
			Vec<Dmax> bmin, bmax, step;
			std::string head; 

			std::list<heavy_tile_t> htiles; 
			std::list<light_tile_t> ltiles;
			std::vector<tile_t*> tiles; // сетка нулевого уровня 

			iterator find(Ind<2> pos, AdaptiveMeshView *msh);  // произвольный доступ по срезу
		
			bool load(aiw::IOstream&& S, bool use_mmap, bool raise_on_error);
			Vec<2> min_max();
		}; // end of struct core_t
		//----------------------------------------------------------------------
		std::shared_ptr<core_t> core;
		bool swap;
		int axes[2];             // оси 
		Ind<2> off, box_, fbox;  // смещение и размер области в ячейках мелкой сетки (для данного изображения и полный)
		Ind<Dmax> slice;         // параметры среза (-1 для отображения, 0 или больше позиция) на самой мелкой сетке
		void set_axes(int ax, int ay);
	public:
#ifndef SWIG
		iterator find(aiw::Ind<2> pos){ iterator I = core->find(off+pos, this); I.imin -= off; I.imax -= off; return I; }  // произвольный доступ по срезу
		iterator begin() { iterator I = core->find(ind(0, 0), this); I.imin -= off; I.imax -= off; while(I.tile && !I.check_bbox()) I.next(); return I; }
	    iterator end() { return iterator(); }
#endif //SWIG
		
		std::string head; 
		int dim; // для uplt
		aiw::Vec<2> bmin, bmax, step; 
		aiw::Ind<2> bbox() const { return box_; }

		aiw::Ind<2> coord2pos(aiw::Vec<2> coord){ return (coord-bmin)/step; }
		
	    AdaptiveMeshView transpose(int, int); 
	    AdaptiveMeshView slice2(aiw::Ind<3> spos); 
		AdaptiveMeshView crop(aiw::Ind<2> a, aiw::Ind<2> b, aiw::Ind<2> d);
		aiw::Vec<2> min_max();

		int offset_in_cell=0;  // смещение отображаемого поля внутри ячейки в байтах

		// float operator [] (const aiw::Ind<2> &pos); // непонятно нужен ли произвольный доступ ???	   
	    float operator()(aiw::Vec<2> r){ return *find(coord2pos(r)); }

		bool load(aiw::IOstream& S, bool use_mmap=false, bool raise_on_error=true);
		static const int sizeof_cell_type = 4; // размер ячейки
		static const int logscale = 0;         // пока невозможен
	};
	//--------------------------------------------------------------------------
};
#endif //AIW_AMRVIEW_HPP
