// -*- C++ -*-
#ifndef AIW_AMR_MEMORY_HPP
#define AIW_AMR_MEMORY_HPP

/**
 * Copyright (C) 2019 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

namespace aiw{
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> AdaptiveMesh<T, D, R> AdaptiveMesh<T, D, R>::copy() const {
		AdaptiveMesh res = *this; res.tiles = tiles.copy();
		for(Ind<D> pos; pos^=tiles.bbox(); ++pos) res.tiles[pos].msh = &res;
		return res;
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> void AdaptiveMesh<T, D, R>::root_t::operator = (const AdaptiveMesh<T, D, R>::root_t &r){
		pos = r.pos;  htiles = r.htiles;  ltiles = r.ltiles; // patches = r.patches;
		// WOUT(pos, htiles.size(), ltiles.size());
		std::map<const void*, int> tbl; tbl[0] = 0;  // таблица для восстановления дерева тайлов
		for(const heavy_tile_t &t: r.htiles){ int ID = tbl.size(); tbl[&t] = ID; } int h_sz = tbl.size();
		for(const light_tile_t &t: r.ltiles){ int ID = tbl.size(); tbl[&t] = ID; }
		std::vector<heavy_tile_t*> htbl(h_sz-1); std::vector<tile_t*> ftbl(tbl.size()), rtbl(tbl.size()-1);
		ftbl[0] = 0; int i = 1;
		for(heavy_tile_t &t: htiles){ ftbl[i] = htbl[i-1] = &t; i++; }
		for(light_tile_t &t: ltiles)  ftbl[i++] = &t;
		i = 0;
		for(const heavy_tile_t &t: r.htiles) rtbl[i++] = (tile_t*)&t;
		for(const light_tile_t &t: r.ltiles) rtbl[i++] = (tile_t*)&t;
		
		root = ftbl[tbl[r.root]];
		for(i=0; i<int(rtbl.size()); i++){
			ftbl[i+1]->parent = ftbl[tbl[rtbl[i]->parent]];
			for(int k=0; k<(1<<D); k++) ftbl[i+1]->childs[k] = ftbl[tbl[rtbl[i]->childs[k]]];
		}
		
		auto I = r.ltiles.begin(); auto J = ltiles.begin();
		while(I!=r.ltiles.end()){ J->page = htbl[tbl[I->page]-1]; ++I; ++J; }
	}
	//--------------------------------------------------------------------------
	// возвращает наиболее подходящую по размеру страницу. Это можно оптимизировать через бинарный поиск?
	template <typename T, int D, int R> typename AdaptiveMesh<T, D, R>::heavy_tile_t* AdaptiveMesh<T, D, R>::root_t::search_page(int sz){ 
		heavy_tile_t* page = nullptr; int gap = chunks_sz;
		for(heavy_tile_t &p: htiles){
			// int d = chunks_sz - (int(p.ch_use+p.ch_alloc)+p.far_ch_sz+sz);
			// if(d>=0 && d+p.ch_free<gap){ page = &p; gap = d+p.ch_free; }
			int d = chunks_sz - int(p.free_chunks_sz())-sz;
			if(d>=0 && d<gap){ page = &p; gap = d; }
		}
		if(!page){ htiles.emplace_back(); page = &(htiles.back()); }
		return page;
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> uint16_t AdaptiveMesh<T, D, R>::heavy_tile_t::alloc_far_chunk(){ // возвращает ID+1 аллоцированного чанка либо 0 в случае неудачи
		// for(uint32_t i=first_free_chunk; i<chunks_sz; i++) if(!get_chunk_info(i)){ set_chunk_info(i, 2); far_ch_sz++; return first_free_chunk = i+1; }
		for(uint32_t i=0; i<chunks_sz; i++)	if(!get_chunk_info(i)){ set_chunk_info(i, 2); far_ch_sz++; return i+1; }
		return 0;
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> void AdaptiveMesh<T, D, R>::heavy_tile_t::free_far_chunk(uint16_t chID){
		// chID -= 1;
		if(patches[chID] && get_chunk_usage(1, chID)){ copy_chunk(patches[chID]->data, data+(int(chID)<<D)); set_chunk_info(chID, 1); }
		else { set_chunk_info(chID, 0);	/*if(first_free_chunk>chID) first_free_chunk = chID;*/ }
		patches[chID] = nullptr; far_ch_sz--; 
	}			
	//--------------------------------------------------------------------------
	// гарантированно аллоцирует чанк, если чанк уже аллоцирован ничего не происходит
	template <typename T, int D, int R> void AdaptiveMesh<T, D, R>::heavy_tile_t::alloc_chunk(int chID){ 
		int s = get_chunk_info(chID);
		if(s==0) set_chunk_info(chID, 1);
		else if(s==2 && !patches[chID]){ root->patches.emplace_back(); patches[chID] = &(root->patches.back()); }
	}
	// гарантированно аллоцирует чанк, если чанк уже аллоцирован ничего не происходит
	template <typename T, int D, int R> void AdaptiveMesh<T, D, R>::light_tile_t::alloc_chunk(int chID){ 
		if(!chunks[chID] && !patches[chID]){
			// if(!page) ...; // где выделяем страницу ??? делаем это сразу при аллоцировании легкого тайла ???
			if(page) chunks[chID] = page->alloc_far_chunk(); // пытаемся выделить чанк в уже существующей странице
			if(!chunks[chID]){ root->patches.emplace_back(); patches[chID] = &(root->patches.back()); }
		}
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> uint16_t AdaptiveMesh<T, D, R>::heavy_tile_t::free_chunks_sz() const {
		int res = 0; for(int i=0; i<chunks_sz; i++) res += bool(get_chunk_info(i));
		if(patches) for(int i=0; i<chunks_sz; i++) res += bool(patches[i]);
		return res;
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R> uint16_t AdaptiveMesh<T, D, R>::light_tile_t::free_chunks_sz() const {
		int res = 0; for(int i=0; i<chunks_sz; i++) res += bool(chunks[i]);
		if(patches) for(int i=0; i<chunks_sz; i++) res += bool(patches[i]);
		return res;
	}
	//--------------------------------------------------------------------------
};
#endif //AIW_AMR_MEMORY_HPP
