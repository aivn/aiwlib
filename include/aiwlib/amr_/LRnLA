// -*- C++ -*-
#ifndef AIW_AMR_LRnLA_HPP
#define AIW_AMR_LRnLA_HPP

/**
 * Copyright (C) 2020 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#include "../conefold"

namespace aiw{
	//--------------------------------------------------------------------------
	template <typename T, int D, int R>  template <typename dT, typename F> void AdaptiveMesh<T, D, R>::tile_t::conefold(int offset, F &&f, dT dt){
		//WASSERT(0<=offset && offset<(1<<(R*D)), "", offset);
		if(get_cell_usage(0, offset)){ AdaptiveMesh<T, D, R>::Cell C; C.offset = offset; C.tile = this; C.ptr = cell(offset); f(C, dt); return; } // замыкание рекурсии
		ConeFoldIter<D, 1> I;  Ind<2> pos0 = zoff2pos<D>(offset<<D, R+1); dt /= 2;
		do {
			int off = pos2zoff(pos0+zoff2pos<D>(I.offset, 2), R+3); // off0 + I.offset;
			int t_off = off>>(R*D), c_off = off&RDbits;
			
			if(t_off<(1<<D)){ if(childs[t_off]) childs[t_off]->conefold(c_off, f, dt); }
			else {
				tile_t *chld = childs[t_off&Dbits], *nbt = nullptr;
				if(chld) nbt = chld->find_nb_tile(zoff2pos<D>(t_off, 3)-zoff2pos<D>(t_off&Dbits, 1));
				if(nbt) nbt->conefold(c_off, f, dt);
			}
		} while(I.next());
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R>  template <typename dT, typename F> void AdaptiveMesh<T, D, R>::conefold(Ind<D> pos, F &&f, dT dt){
		tile_t *ground[1<<D] = {nullptr};
		for(Ind<D> dpos; dpos^=ind(2); ++dpos) if(ind(0)<=pos+dpos && pos+dpos<tiles.bbox()) ground[pos2zoff(dpos, 1)] = tiles[pos+dpos].root;
		
		ConeFoldIter<D, R> I; do {
			// if(I.t>1) continue;
			// WASSERT((I.offset>>(R*D))<(1<<D), "", I.offset, I.t);
			tile_t *t = ground[I.offset>>(R*D)]; if(t) t->conefold(I.offset&RDbits, f, dt);
		} while(I.next());
	}
	template <typename T, int D, int R>  template <typename dT, typename F1, typename F2> void AdaptiveMesh<T, D, R>::conefold(Ind<D> pos, F1 &&f1, F2 &&f2, dT dt){
		std::vector<Cell> cells;
		for(Ind<D> dpos; dpos^=ind(2); ++dpos)
			if(ind(0)<=pos+dpos && pos+dpos<tiles.bbox())
				for(auto C: get_tile(pos+dpos)) cells.push_back(C);
		
		dT dt_arr[max_rank+1] = {dt}; for(int i=1; i<=max_rank; i++) dt_arr[i] = dt_arr[i-1]/2;
		Vec<D> a = bmin+(pos&tiles.step)-step/2, b = a+tiles.step;

		for(int i=0; i<(1<<(R+max_rank)); i++){ // это пока что пошаговый конефолд
			for(int k=cells.size()-1; k>=0; k--){
				Cell &C = cells[k];
				if(!(i%(1<<(max_rank-C.rank())))){ Vec<D> c = C.bmin(); if(a<c && c<b) f1(C, dt_arr[C.rank()]); }
			}
			a += step; b += step;
			for(int k=cells.size()-1; k>=0; k--){
				Cell &C = cells[k];
				if(!((i+1)%(1<<(max_rank-C.rank())))){ Vec<D> c = C.bmin(); if(a<c && c<b) f2(C, dt_arr[C.rank()]); }
			}
		}
	}
	//--------------------------------------------------------------------------
	template <typename T, int D, int R>  template <typename dT, typename F> void AdaptiveMesh<T, D, R>::conefold(F &&f, dT dt){
		for(Ind<D> pos; pos^=tiles.bbox()+ind(1); ++pos) conefold(tiles.bbox()-pos-ind(1), f, dt);  // это наивный построчный обход
	} 
	template <typename T, int D, int R>  template <typename dT, typename F1, typename F2> void AdaptiveMesh<T, D, R>::conefold(F1 &&f1, F2 &&f2, dT dt){
		for(Ind<D> pos; pos^=tiles.bbox()+ind(1); ++pos) conefold(tiles.bbox()-pos-ind(1), f1, f2, dt);  // это наивный построчный обход
	} 
	//--------------------------------------------------------------------------
	template <typename T, int D, int R>	double AdaptiveMesh<T, D, R>::conefold_complexity(Ind<D> pos) const {   // в ячейках на шаг
		double res = 0;  Vec<D> a0 = tiles.bmin+(pos&tiles.step), b0 = a0+tiles.step, places[D];
		for(int i=0; i<D; i++) places[i][i] = 1./tiles.step[i];
		for(Ind<D> dpos; dpos^=ind(2); ++dpos)
			if(ind(0)<=pos+dpos && pos+dpos<tiles.bbox())
				for(Cell C: get_tile(pos+dpos)){
					Vec<D> c = C.bmin()+C.step()*.5; 
					double a = 0., b = 1.;
					for(int i=0; i<D; i++){ a = std::max(a, (c-b0)*places[i]); b = std::min(b, (c-a0)*places[i]); }
					if(a<b) res += (b-a)*(1<<(R+C.rank())); 
				}			
		return res;
	}
	//--------------------------------------------------------------------------
};
#endif //AIW_AMR_LRnLA_HPP
