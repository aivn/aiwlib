// -*- C++ -*-
#ifndef AIW_SPHERE_HPP
#define AIW_SPHERE_HPP

/**
 * Copyright (C) 2016 Antov V. Ivanov and Sergey Khilkov, KIAM RAS, Moscow.
 * This code is released under the GPL2 (GNU GENERAL PUBLIC LICENSE Version 2, June 1991)
 **/

#ifndef SWIG		
#include <utility>
#endif //SWIG		
#include "vec"
#include "iostream"
#include "binaryio"

namespace aiw{
	//--------------------------------------------------------------------------
	//   инициализация
	//--------------------------------------------------------------------------
	void sph_init_table(int rank); // инициализирует таблицы вплоть до ранга rank
	void sph_free_table(int rank=-1); // освобождает таблицы старше ранга rank (включительно)
	int sph_max_rank();  // максимальный инициализированный ранг
	//--------------------------------------------------------------------------
	//   доступ к произвольному рангу, C-style
	//--------------------------------------------------------------------------
	uint64_t sph_cellInd(const aiw::Vec<3> &r, int rank); // индекс ячейки
	const aiw::Vec<3>& sph_cell(uint64_t ID, int rank); // центр ячейки
	double sph_cell_area(uint64_t ID, int rank); // площадь ячейки
	const aiw::Vec<3, uint64_t>& sph_cell_vert(uint64_t ID, int rank); // индексы вершин ячейки
	const aiw::Vec<3, uint64_t>& sph_cell_cell(uint64_t ID, int rank); // близжайшие соседи ячейки
	uint64_t sph_cells_num(int rank);
	uint64_t sph_vertex_num(int rank);
	// const aiw::Vec<3, uint64_t>& sph_cell_edge(uint64_t ID, int rank); // близжайшие ребра ячейки

	const aiw::Vec<3>& sph_vert(uint64_t ID, int rank); // вершина (узел) сетки
	const aiw::Vec<3, uint64_t>& sph_vert_vert(uint64_t ID, int rank); // индексы вершин вершины
	const aiw::Vec<6, uint64_t>& sph_vert_cell(uint64_t ID, int rank); // ячейки, к которым относится вершина
	// const aiw::Vec<6, uint64_t>& sph_vert_edge(uint64_t ID, int rank); // близжайшие ребра вершины

	// const aiw::Vec<2, uint64_t>& sph_edge_cell(uint64_t ID, int rank); // близжайшие ячейки ребра
	// const aiw::Vec<2, uint64_t>& sph_edge_vert(uint64_t ID, int rank); // близжайшие вершины ребра
	//--------------------------------------------------------------------------
	/*
	class SphInd{
		uint64_t I; // 5 СТАРШИХ бит на ранг, остальное на индекс
	public:
		inline void set(uint64_t index, int rank){ I = index|(rank<<5); }
		inline SphInd(uint64_t index, int rank){ set(index, rank); }
		inline SphInd():I(~((uint64_t)0)){} // по умолчанию индекс невалидный

		inline uint64_t index() const { return I&0x07ffffffffffffff; }
		int rank() const { return I>>59; }
		inline operator bool() const { return index()!=0x07ffffffffffffff; }
#ifndef SWIG
		inline bool operator !() const { return index()==0x07ffffffffffffff; }

		inline SphInd operator ++ (){ SphInd res; res.I = I--; return res; }
		inline SphInd operator ++ (int){ ++I; return *this; }
		inline SphInd operator -- (){ SphInd res; res.I = I--; return res; }
		inline SphInd operator -- (int){ --I; return *this; }
#endif //SWIG
		uint64_t __long__(){ return index(); }
	};
	//--------------------------------------------------------------------------
	struct SphCellInd;
	struct SphVertInd;
	struct SphEdgeInd;
	//--------------------------------------------------------------------------
	struct SphCellInd: public SphInd{
		SphCellInd up() const;
		SphCellInd down() const;
#ifndef SWIG
		inline operator uint64_t() const { return index(); }
#endif //SWIG

		SphCellInd(const aiw::Vec<3> &r, int rank);
		double area() const;
		const aiw::Vec<3>& center() const;
		const aiw::Vec<3>& vert(int i) const;   // 0<=i<3
		SphVertInd vertInd(int i) const;        // 0<=i<3
		SphCellInd cellInd(int i) const;        // 0<=i<3
		SphEdgeInd edgeInd(int i) const;        // 0<=i<3
	};
	//--------------------------------------------------------------------------
	struct SphVertInd: public SphInd{
		SphVertInd up() const;
		SphVertInd down() const;
#ifndef SWIG
		inline operator uint64_t() const { return index(); }
#endif //SWIG

		const aiw::Vec<3>& center() const;
		SphCellInd cellInd(int i) const;  // 0<=i<6
		SphEdgeInd edgeInd(int i) const;  // 0<=i<6
		SphVertInd vertInd(int i) const;  // 0<=i<6
	};
	//--------------------------------------------------------------------------
	struct SphEdgeInd: public SphInd{
		SphEdgeInd up() const;
		SphEdgeInd down() const;
#ifndef SWIG
		inline operator uint64_t() const { return index(); }
#endif //SWIG

		const aiw::Vec<3>& vert(int i) const;   // 0<=i<2
		SphVertInd vertInd(int i) const;        // 0<=i<2
		SphCellInd cellInd(int i) const;        // 0<=i<2
	};
	*/
	//--------------------------------------------------------------------------
	// контейнер
	//--------------------------------------------------------------------------
	template <typename T> class Sphere{
		std::shared_ptr<BaseAlloc> mem;
		T *ptr;           
		int R; size_t sz;
	public:
		std::string head;

		size_t size() const { return sz; }
		size_t __len__(){ return sz; } 
		int rank() const { return R; }

		void init(int R_){		 
			R = R_; 
			if(R>=0){
				sz = sph_cells_num(R);
				sph_init_table(R_);
				mem.reset(new MemAlloc<T>(sz)); ptr = (T*)(mem->get_addr());	
			} else { ptr = nullptr; sz = 0; mem.reset(); }
		}
		Sphere(int R_=-1): ptr(nullptr), R(-1), sz(0){ init(R_); }
		Sphere copy() const { Sphere res(R); for(size_t i=0; i<sz; ++i) res.ptr[i] = ptr[i]; return res; }

#ifndef SWIG
		inline const T& operator [] (const aiw::Vec<3> &r) const { return ptr[sph_cellInd(r, R)]; }
		inline       T& operator [] (const aiw::Vec<3> &r)       { return ptr[sph_cellInd(r, R)]; }
		inline const T& operator [] (size_t i) const { WASSERT(i<sz, "illegal index", i, sz); return ptr[i]; }
		inline       T& operator [] (size_t i)       { WASSERT(i<sz, "illegal index", i, sz); return ptr[i]; }
#endif //SWIG

		T&   __getitem__(const aiw::Vec<3> &r){ return (*this)[r]; }
		void __setitem__(const aiw::Vec<3> &r, const T &val ){ (*this)[r] = val; }
		T&   __getitem__(size_t I){ return (*this)[I]; }
		void __setitem__(size_t I, const T &val){ (*this)[I] = val; }

		std::string __getstate__() const { 
			std::stringstream buf;
			uint32_t h_sz = head.size(); buf.write((const char*)&h_sz, sizeof(h_sz)); buf<<head;
			buf.write((const char*)&R, sizeof(R)); if(sz) buf.write((char*)ptr, sizeof(T)*sz);         
			return buf.str();
		}
		void __C_setstate__(const std::string &state){
			std::stringstream buf(state);
			uint32_t h_sz = head.size(); buf.read((char*)&h_sz, sizeof(h_sz)); 
			head.resize(h_sz); buf.read(&(head[0]), h_sz); // ???
			int R_; buf.read((char*)&R_, sizeof(R)); init(R_);
			if(sz) buf.read((char*)ptr, sizeof(T)*sz);         
		}
#ifndef SWIG
		void dump(aiw::IOstream &&S) const { 
			S<head<int(0)<int(sizeof(T))<R;
			S.write(this->ptr, sizeof(T)*sz);
		}
		void load(aiw::IOstream &&S, int use_mmap=0){ // 0 - not use, 1 - readonly, 2 - rw
			std::string h; int D, szT; size_t s = S.tell(); S>h>D>szT;
			if(D!=0 || szT!=sizeof(T)){ 
				S.seek(s); 
				WRAISE("incorrect Sphere::load() ", D, sizeof(T), szT, S.name, S.tell(), h); 
			}
			head = h; S>R; sz = sph_cells_num(R);
			if(use_mmap){ mem = S.mmap(sz*sizeof(T), use_mmap-1); ptr = (T*)(mem->get_addr()); }
			else{ mem.reset(new MemAlloc<T>(sz)); ptr = (T*)(mem->get_addr());  S.read(ptr, sizeof(T)*sz); }
		}
#endif //SWIG
		void dump(aiw::IOstream &S) const { dump(std::move(S)); }
		void load(aiw::IOstream &S, int use_mmap=0){ load(std::move(S), use_mmap); } // 0 - not use, 1 - readonly, 2 - rw

		void min_max(T &a, T &b, size_t &pos_a, size_t &pos_b) const {
			if(sz){ pos_a = pos_b = 0; a = b = ptr[0]; } else pos_a = pos_b = -1;
			for(size_t i=1; i<sz; ++i){
				if(a>ptr[i]){ a = ptr[i]; pos_a = i; }
				if(b<ptr[i]){ b = ptr[i]; pos_b = i; }
			}
		}
		void fill(const T &x){ for(size_t i=0; i<sz; ++i) ptr[i] = x; }
		// template <typename T2> void fill(const Sphere<T2> &sph);
		// void fill(const Sphere &sph);
		// void fill(IOstream &&S);

		static const bool _racs_pull_lock = true;		
		size_t __sizeof__() const { return sizeof(Sphere) + head.size() + (mem?mem->get_size()*mem->get_sizeof():0); }
	};
	//--------------------------------------------------------------------------
};
#endif //AIW_SPHERE_HPP
