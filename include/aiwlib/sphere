// -*- C++ -*-
#ifndef AIW_SPHERE_HPP
#define AIW_SPHERE_HPP

/**
 * Copyright (C) 2016, 2017 Antov V. Ivanov <aiv.racs@gmail.com> and Sergey Khilkov <ezz666@gmail.com> 
 * Licensed under the Apache License, Version 2.0
 **/

#ifndef SWIG		
#include <utility>
#endif //SWIG		
#include "vec"
#include "iostream"
#include "binaryio"
#include "gauss"

namespace aiw{
	//--------------------------------------------------------------------------
	Vec<3> barecentr(const Vec<3> &n, const Vec<3> tr[3]);
	//--------------------------------------------------------------------------
	//   инициализация
	//--------------------------------------------------------------------------
	void sph_init_table(int rank); // инициализирует таблицы вплоть до ранга rank
	void sph_free_table(int rank=-1); // освобождает таблицы старше ранга rank (включительно)
	int sph_max_rank();  // максимальный инициализированный ранг
	//--------------------------------------------------------------------------
	//   доступ к произвольному рангу, C-style
	//--------------------------------------------------------------------------
	size_t sph_cellInd(const aiw::Vec<3> &r, int rank); // индекс ячейки
	size_t sph_vertInd(const aiw::Vec<3> &r, int rank); // индекс вершины
	size_t sph_edgeInd(const aiw::Vec<3> &r, int rank); // индекс грани
	const aiw::Vec<3>& sph_cell(size_t ID, int rank); // центр ячейки
	double sph_cell_area(size_t ID, int rank); // площадь ячейки
	const aiw::Vec<3, uint64_t>& sph_cell_vert(size_t ID, int rank); // индексы вершин ячейки
	const aiw::Vec<3, uint64_t>& sph_cell_cell(size_t ID, int rank); // близжайшие соседи ячейки
	size_t sph_cells_num(int rank);
	size_t sph_vertex_num(int rank);
	size_t sph_edges_num(int rank);
	// const aiw::Vec<3, uint64_t>& sph_cell_edge(uint64_t ID, int rank); // близжайшие ребра ячейки

	const aiw::Vec<3>& sph_vert(size_t ID, int rank); // вершина (узел) сетки
	const aiw::Vec<6, uint64_t>& sph_vert_cell(size_t ID, int rank); // ячейки, к которым относится вершина
	const aiw::Vec<3, uint64_t>& sph_cell_edge(size_t ID, int rank); // индексы ребер ячейки (в оппозит вершинам)
	const aiw::Vec<2, uint64_t>& sph_edge_cell(size_t ID, int rank); // индексы ячеeк ребра
	const aiw::Vec<2, uint64_t>& sph_edge_vert(size_t ID, int rank);  // индексы вершин ребра
	const aiw::Vec<6, uint64_t>& sph_vert_vert(size_t ID, int rank); // индексы соседних вершин (для вершины)
	const aiw::Vec<6, uint64_t>& sph_vert_edge(size_t ID, int rank);  // индексы соседних ребер (для вершины)
	double sph_vert_area(size_t ID, int rank);  // площади ячеек при разбиении по вершинам
	double sph_edge_area(size_t ID, int rank);  // площади ячеек при разбиении по ребрам
	const aiw::Vec<3>& sph_edge(size_t ID, int rank); // координаты центров ребер
	//--------------------------------------------------------------------------
	/*
	class SphInd{
		uint64_t I; // 5 СТАРШИХ бит на ранг, остальное на индекс
	public:
		inline void set(uint64_t index, int rank){ I = index|(rank<<5); }
		inline SphInd(uint64_t index, int rank){ set(index, rank); }
		inline SphInd():I(~((uint64_t)0)){} // по умолчанию индекс невалидный

		inline uint64_t index() const { return I&0x07ffffffffffffff; }
		int rank() const { return I>>59; }
		inline operator bool() const { return index()!=0x07ffffffffffffff; }
#ifndef SWIG
		inline bool operator !() const { return index()==0x07ffffffffffffff; }

		inline SphInd operator ++ (){ SphInd res; res.I = I--; return res; }
		inline SphInd operator ++ (int){ ++I; return *this; }
		inline SphInd operator -- (){ SphInd res; res.I = I--; return res; }
		inline SphInd operator -- (int){ --I; return *this; }
#endif //SWIG
		uint64_t __long__(){ return index(); }
	};
	//--------------------------------------------------------------------------
	struct SphCellInd;
	struct SphVertInd;
	struct SphEdgeInd;
	//--------------------------------------------------------------------------
	struct SphCellInd: public SphInd{
		SphCellInd up() const;
		SphCellInd down() const;
#ifndef SWIG
		inline operator uint64_t() const { return index(); }
#endif //SWIG

		SphCellInd(const aiw::Vec<3> &r, int rank);
		double area() const;
		const aiw::Vec<3>& center() const;
		const aiw::Vec<3>& vert(int i) const;   // 0<=i<3
		SphVertInd vertInd(int i) const;        // 0<=i<3
		SphCellInd cellInd(int i) const;        // 0<=i<3
		SphEdgeInd edgeInd(int i) const;        // 0<=i<3
	};
	//--------------------------------------------------------------------------
	struct SphVertInd: public SphInd{
		SphVertInd up() const;
		SphVertInd down() const;
#ifndef SWIG
		inline operator uint64_t() const { return index(); }
#endif //SWIG

		const aiw::Vec<3>& center() const;
		SphCellInd cellInd(int i) const;  // 0<=i<6
		SphEdgeInd edgeInd(int i) const;  // 0<=i<6
		SphVertInd vertInd(int i) const;  // 0<=i<6
	};
	//--------------------------------------------------------------------------
	struct SphEdgeInd: public SphInd{
		SphEdgeInd up() const;
		SphEdgeInd down() const;
#ifndef SWIG
		inline operator uint64_t() const { return index(); }
#endif //SWIG

		const aiw::Vec<3>& vert(int i) const;   // 0<=i<2
		SphVertInd vertInd(int i) const;        // 0<=i<2
		SphCellInd cellInd(int i) const;        // 0<=i<2
	};
	*/
	//--------------------------------------------------------------------------
	// контейнер
	//--------------------------------------------------------------------------
	template <typename T> class Sphere{
		std::shared_ptr<BaseAlloc> mem;
		T *ptr;           
		int R, mode; // 0 - ячейки, 1 - узлы, 2 - грани
		size_t sz;
	public:
		static const int sizeof_cell_type = sizeof(T);
		std::string head;

		inline int get_mode() const { return mode; }
		inline size_t size() const { return sz; }
		inline size_t csize() const { return sph_cells_num(R); }
		inline size_t vsize() const { return sph_vertex_num(R); }
		// inline size_t esize() const { return sph_edge_num(R); }
		inline size_t __len__(){ return sz; } 
		inline int rank() const { return R; }

		void init(int R_, int align=0, int mode_=0){		 
			R = R_; mode = mode_;
			if(R>=0){
				sz = mode==0? sph_cells_num(R): (mode==1? sph_vertex_num(R): sph_edges_num(R));
				sph_init_table(R_); // ???
				ptr = init_mem_ptr<T>(mem, sz, align);
			} else { ptr = nullptr; sz = 0; mem.reset(); }
		}
		Sphere(int R_=-1, int align=0, int mode_=0): ptr(nullptr), R(-1), sz(0){ init(R_, align, mode_); }
		Sphere copy(int align=0) const { Sphere res(R, align, mode); for(size_t i=0; i<sz; ++i) res.ptr[i] = ptr[i]; return res; }

		typedef T* iterator;
		T* begin(){ return ptr; }
		T* end(){ return ptr+sz; }

		//----------------------------------------------------------------------
		//  cells info
		//----------------------------------------------------------------------		
		inline size_t cellInd(const aiw::Vec<3> &r) const { return sph_cellInd(r, R); }                  // индекс ячейки
		inline size_t vertInd(const aiw::Vec<3> &r) const { return sph_vertInd(r, R); }                  // индекс вершины
		inline size_t edgeInd(const aiw::Vec<3> &r) const { return sph_edgeInd(r, R); }                  // индекс грани
		inline const aiw::Vec<3>& cell(size_t ID) const { return sph_cell(ID, R); }                      // центр ячейки
		inline double cell_area(size_t ID) const { return sph_cell_area(ID, R); }                        // площадь ячейки
		inline const aiw::Vec<3, uint64_t>& cell_vert(size_t ID) const { return sph_cell_vert(ID, R); }  // индексы вершин ячейки
		inline const aiw::Vec<3, uint64_t>& cell_cell(size_t ID) const { return sph_cell_cell(ID, R); }  // близжайшие соседи ячейки
		inline const aiw::Vec<3>& vert(size_t ID) const { return sph_vert(ID, R); }                      // вершина (узел) сетки
		inline const aiw::Vec<6, uint64_t>& vert_cell(size_t ID) const { return sph_vert_cell(ID, R); }  // ячейки, к которым относится вершина
		inline const aiw::Vec<3, uint64_t>& cell_edge(size_t ID) const { return sph_cell_edge(ID, R); }  // индексы ребер ячейки (в оппозит вершинам)
		inline const aiw::Vec<2, uint64_t>& edge_cell(size_t ID) const { return sph_edge_cell(ID, R); }  // индексы ячеeк ребра
		inline const aiw::Vec<2, uint64_t>& edge_vert(size_t ID) const { return sph_edge_vert(ID, R); }  // индексы вершин ребра
		inline const aiw::Vec<6, uint64_t>& vert_vert(size_t ID) const { return sph_vert_vert(ID, R); }  // индексы соседних вершин (для вершины)
		inline const aiw::Vec<6, uint64_t>& vert_edge(size_t ID) const { return sph_vert_edge(ID, R); }  // индексы соседних ребер (для вершины)
		inline double vert_area(size_t ID) const { return sph_vert_area(ID, R); }                        // площади ячеек при разбиении по вершинам
		inline double edge_area(size_t ID) const { return sph_edge_area(ID, R); }                        // площади ячеек при разбиении по ребрам
		inline const aiw::Vec<3>& edge(size_t ID) const { return sph_edge(ID, R); }                      // координаты центров ребер

		//----------------------------------------------------------------------
		//  universal access
		//----------------------------------------------------------------------		
		inline size_t find(const aiw::Vec<3> &r) const { return mode==0? vertInd(r): (mode==1? cellInd(r): edgeInd(r)); } // индекс ячейки
		inline const aiw::Vec<3>& center(size_t ID) const { return mode==0? cell(ID): (mode==1? vert(ID): edge(ID)); }    // центр ячейки
		inline double area(size_t ID) const { return mode==0? cell_area(ID): (mode==1? vert_area(ID): edge_area(ID)); }   // площадь ячейки

		
#ifndef SWIG
		inline const T& operator [] (const aiw::Vec<3> &r) const { return ptr[find(r)]; }
		inline       T& operator [] (const aiw::Vec<3> &r)       { return ptr[find(r)]; }
		inline const T& operator [] (size_t i) const { WASSERT((i<=0 && i<sz), "illegal index", i, sz); return ptr[i]; }
		inline       T& operator [] (size_t i)       { WASSERT((i<=0 && i<sz), "illegal index", i, sz); return ptr[i]; }
		inline const T& operator [] (const aiw::Vec<2> &r) const { return (*this)[polar(r[1], r[0])]; } // phi, theta
		inline       T& operator [] (const aiw::Vec<2> &r)       { return (*this)[polar(r[1], r[0])]; } // phi, theta
#endif //SWIG

		T&   __getitem__(const aiw::Vec<3> &r){ return (*this)[r]; }
		void __setitem__(const aiw::Vec<3> &r, const T &val ){ (*this)[r] = val; }
		T&   __getitem__(size_t I){ return (*this)[I]; }
		void __setitem__(size_t I, const T &val){ (*this)[I] = val; }
		T&   __getitem__(const aiw::Vec<2> &r){ return (*this)[r]; }
		void __setitem__(const aiw::Vec<2> &r, const T &val ){ (*this)[r] = val; }

		bool interp=false;
		T operator()(const aiw::Vec<3> &r) const {
			if(!interp || mode>1) return (*this)[r];
			size_t cid = sph_cellInd(r, R); Vec<3, T> v;
			const aiw::Vec<3, uint64_t>& vid = sph_cell_vert(cid, R);
			Vec<3> n[3]; for(int i=0; i<3; i++) n[i] = sph_vert(vid[i], R);
			if(mode) for(int i=0; i<3; i++) v[i] = ptr[vid[i]];
			else {
				Vec<3> cXn[3], c = sph_cell(cid, R);
				for(int i=0; i<3; i++) cXn[i] = c%n[i]; 
				int tr; for(tr=0; tr<3; tr++) if((cXn[(tr+1)%3]*r)*(cXn[(tr+1)%3]*n[(tr+2)%3])>=0 && (cXn[(tr+2)%3]*r)*(cXn[(tr+2)%3]*n[(tr+1)%3])>=0) break;
				if(tr==3) WRAISE("oops...", r, cid, vid, n, cXn, c);
				for(int i=0; i<3; i++){
					if(i==tr) continue;
					const aiw::Vec<6, uint64_t>& nbid = sph_vert_cell(vid[i], R); // ячейки, к которым относится вершина
					v[i] = ptr[nbid[0]]; int m; for(m=1; m<6 && m!=-1; ++m){ v[i] += ptr[nbid[m]]; } v[i] /= m;				
				}
				v[tr] = ptr[cid]; n[tr] = c;
			} 
			return v*barecentr(r, n);
		}
		T operator()(const aiw::Vec<2> &r) const { return (*this)(polar(r[1], r[0])); }
		
		std::string __getstate__() const { 
			std::stringstream buf;
			uint32_t h_sz = head.size(); buf.write((const char*)&h_sz, sizeof(h_sz)); buf<<head;
			int RM = R|(mode<<30); buf.write((const char*)&RM, sizeof(RM)); if(sz) buf.write((char*)ptr, sizeof(T)*sz);         
			return buf.str();
		}
		void __C_setstate__(const std::string &state){
			std::stringstream buf(state);
			uint32_t h_sz = head.size(); buf.read((char*)&h_sz, sizeof(h_sz)); 
			head.resize(h_sz); buf.read(&(head[0]), h_sz); // ???
			int RM; buf.read((char*)&RM, sizeof(RM)); init(RM&~(3<<30), 0, RM>>30);
			if(sz) buf.read((char*)ptr, sizeof(T)*sz);         
		}
#ifndef SWIG
		void dump(aiw::IOstream &&S) const { 
			S<head<int(0)<int(sizeof(T))<((mode<<30)|R);
			S.write(this->ptr, sizeof(T)*sz);
		}
		bool load(aiw::IOstream &&S, int use_mmap=0, bool raise_on_error=true, int align=0){ // 0 - not use, 1 - readonly, 2 - rw
			std::string h; int D=-1, szT=-1; size_t s = S.tell(); S>h>D>szT;
			if(D!=0 || szT!=sizeof(T)){ 
				S.seek(s); 
				if(raise_on_error) WRAISE("incorrect Sphere::load() ", D, sizeof(T), szT, S.name, S.tell(), h);
				return false;
			}
			head = h; S>R; mode = R>>30; R &= ~(3<<30); sz = mode? sph_vertex_num(R): sph_cells_num(R);
			if(use_mmap){ mem = S.mmap(sz*sizeof(T), use_mmap-1); ptr = (T*)(mem->get_addr()); }
			else{ ptr = init_mem_ptr<T>(mem, sz, align); S.read(ptr, sizeof(T)*sz); }
			return true;
		}
#endif //SWIG
		void dump(aiw::IOstream &S) const { dump(std::move(S)); }
		bool load(aiw::IOstream &S, int use_mmap=0, bool raise_on_error=true, int align=0){
			return load(std::move(S), use_mmap, raise_on_error, align);
		} // mmap=0 - not use, 1 - readonly, 2 - rw

		bool min_max(T &a, T &b, size_t &pos_a, size_t &pos_b) const {
			bool is_ok = false;
			for(size_t i=0; i<sz; ++i){
				if(is_bad_value(ptr[i])) continue;
				if(!is_ok || a>ptr[i]){ a = ptr[i]; pos_a = i; }
				if(!is_ok || b<ptr[i]){ b = ptr[i]; pos_b = i; }
				is_ok = true;
			}
			return is_ok;
		}
		aiw::Vec<2, T> min_max() const { aiw::Vec<2, T> res; size_t pos_a, pos_b; this->min_max(res[0], res[1], pos_a, pos_b); return res; }

		void fill(const T &x){ for(size_t i=0; i<sz; ++i) ptr[i] = x; }
		// template <typename T2> void fill(const Sphere<T2> &sph);
		// void fill(const Sphere &sph);
		// void fill(IOstream &&S);

		static const bool _racs_pull_lock = true;		
		size_t __sizeof__() const { return sizeof(Sphere) + head.size() + (mem?mem->get_size()*mem->get_sizeof():0); }
	};
	//--------------------------------------------------------------------------
};
#endif //AIW_SPHERE_HPP
