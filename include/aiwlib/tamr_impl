// -*- C++ -*-
/**
 * Copyright (C) 2024, 2026 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 *
 * TiledAdaptiveMesh methods implementation.
 * !!! DO NOT INCLUDE THIS FILE MANUALLY !!!
 **/

//------------------------------------------------------------------------------
template <typename T, int D, int R> typename TiledAdaptiveMesh<T, D, R>::tile_t&
TiledAdaptiveMesh<T, D, R>::add_tile(const Ind<D> &tpos, const int rank){  ///< при необходимости добавляет тайл и встраивает его в струкутуру данных
	uint64_t toff = tpos2toff(tpos, rank);  auto I = forest.find(toff); if(I!=forest.end()) return I->second;
	tile_t &tile = forest[toff]; tile.toff = toff; tiles.push_back(&tile);  tile.tID = tiles.size()-1;
	while(toff&31){  // поиск вверх
		toff = up_toff(toff); I = forest.find(toff);
		if(I!=forest.end()){ tile.parent = &(I->second); break; }
	}
	return tile;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R> void TiledAdaptiveMesh<T, D, R>::del_tile(int tID){
	tile_t *t = tiles[tID];  uint64_t ntoff = next_toff(t->toff);
	for(auto I=forest.upper_bound(t->toff); I!=forest.end() && I->second.toff<ntoff; ++I) I->second.parent = t->parent;
	forest.erase(t->toff); if(tID<int(tiles.size()-1)){ tiles[tID] = tiles.back(); tiles[tID]->tID = tID; } tiles.pop_back();
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	int
TiledAdaptiveMesh<T, D, R>::add_stencil(const std::vector<Ind<D> > &stencil){  ///< добавляет шаблон в таблицу stencil-ов, возвращает stencilID>0
	stencils.emplace_back(); std::vector<stencil_node_t>& nodes = stencils.back();  nodes.reserve(stencil.size()<<R*D);
	for(const Ind<D>& pos: stencil) if(!(pos<=Ind<D>())) WRAISE("incorect positive pos ", pos);
	for(int cID=0; cID<(1<<R*D); cID++) for(int nID=0, sz=stencil.size(); nID<sz; nID++){
			Ind<D> pos = coords[cID]+stencil[nID]; stencil_node_t n; n.tID = 0;
			for(int i=0; i<D; i++) if(pos[i]<0){ pos[i] += 1<<R; n.tID += 1<<i; }
			n.off = ZCurve32<D>(pos, R).off;
			nodes.push_back(n);
			// WMSG(cID, stencil[nID],  nID, coords[cID], pos, n.tID, n.off);
		}
	return stencils.size()-1;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	void TiledAdaptiveMesh<T, D, R>::init(const Ind<D> &tbox_){
	tbox = tbox_;  tmul[0] = 1; for(int i=1; i<D; i++) tmul[i] = tmul[i-1]*tbox[i-1];
	zbound = 64; for(int sz=tbox.prod(); sz; sz>>=1) zbound--;  // log2(sz)
	zmask = (uint64_t(1)<<zbound)-1;  rank_lim = (zbound-5)/D;
	forest.clear();  stencils.clear();  tiles.clear();
	for(Ind<D> tpos: irange<D>(tbox)){ add_tile(tpos, 0).usage.fill(1); }
	for(ZCurve64<D> z(0, R); z; z.off++) coords[z.off] = *z;  // заполнение таблицы координат
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	void TiledAdaptiveMesh<T, D, R>::tiles2dat(std::string fname) const {
	if(D!=2) return;
	std::ofstream fout(fname);
	for(auto I=forest.begin(); I!=forest.end(); ++I){
		int rank = I->second.rank();  float d = 1.f/(1<<rank); Vecf<D> pos = toff2tpos(I->first)*d;
		fout<<pos             <<' '<<rank<<'\n'
			<<pos+vecf(0.f, d)<<' '<<rank<<'\n'
			<<pos+vecf(d, d)  <<' '<<rank<<'\n'
			<<pos+vecf(d, 0.f)<<' '<<rank<<'\n'
			<<pos             <<' '<<rank<<"\n\n\n";
	}
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	 void TiledAdaptiveMesh<T, D, R>::items2dat(std::string fname) const {
	std::ofstream fout(fname);
	for(auto I=forest.begin(); I!=forest.end(); ++I){
		int rank = I->second.rank();  float d = 1.f/(1<<rank); Vecf<D> pos = toff2tpos(I->first)*d*(1<<R);
		for(int p: I->second.usage) fout<<pos+coords[p]*d<<' '<<rank<<'\n';
	}
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	 const T*
TiledAdaptiveMesh<T, D, R>::Stencil::operator [] (int cID) noexcept {  ///< доступ к элементу шаблона номер cID, если такого узла нет возвращает nullptr
	stencil_node_t sn = snodes[cID];  const tile_t* tile = cube[sn.tID];
	if(tile && tile->usage[sn.off]){ rank = tile->rank();  return tile->data+sn.off; }  // штатное поведение, целевой узел есть
	int off = sn.off;
	while(tile && tile->parent && !(off&((1<<D)-1))){  // пытаемся подняться не попадая между узлами более крупной сетки
		tile = tile->parent; off = storage->up_off(off, tile->toff);
		if(tile->usage[off]){ rank = tile->rank(); return tile->data+off; }
	}
	uint64_t toff = cube[0]->toff; off = sn.off;
	for(int r=cube[0]->rank(); !(off&((1<<D)-1)) && r>0; r--){  // соседнего тайла на том же ранге не нашлось но подняться все равно пытаемся
		off = storage->up_off(off, toff); toff = storage->up_toff(toff); auto I = storage->forest.find(toff);
		if(I!=storage->forest.end() && I->second.usage[off]) return I->second.data+off;
	}
	toff = cube[0]->toff; rank = cube[0]->rank()-1;  off = sn.off; uint64_t ntoff = storage->next_toff(toff);  // делать нечего, идем вниз
	while(1){
		toff = storage->down_toff(toff, down_chID(off));  off = down_off(off);
		auto I = storage->forest.lower_bound(toff);  if(I==storage->forest.end() || I->second.toff>=ntoff) break;
		if(I->second.toff==toff && I->second.rank()==rank && I->second.usage[off]) return I->second.data+off;
	}
	rank = -1; return nullptr;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	const T*
TiledAdaptiveMesh<T, D, R>::Item::get_up_item() const noexcept {  ///< возвращает узел с рангом на единицу больше (если есть, иначе nullptr)
	const tile_t *p = tile->parent;  int r = tile->rank();
	while(p){
		int dr = tile->rank()-p->rank();
		if(off&(1<<D*dr-1)) return nullptr;  // попали между узлами
		int f = (((tile->toff>>zbound-r*D)&((1<<dr*D)-1))<<(R-dr)*D)&((1<<R*D)-1)+(off>>dr*D);   // ???
		if(p->usage[f]) return p->data+f;
		p = p->parent;
	}
	return nullptr;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R>	const T*
TiledAdaptiveMesh<T, D, R>::Item::get_down_item() const noexcept {  ///< возвращает узел с рангом на единицу меньше (если есть, иначе nullptr)
	// выделить в отдельную функцию - в Stencil[] есть такой же код???
	uint64_t tf = tile->toff; int r = tile->rank()-1, f = off; uint64_t ntoff = next_toff(tf);  
	while(1){
		tf = down_toff(tf, down_chID(f));  f = down_off(f);
		auto I = storage->forest.lower_bound(tf);  if(I==storage->forest.end() || I->second.toff>=ntoff) break;
		if(I->second.toff==tf && I->second.rank()==rank && I->second.usage[f]) return I->second.data+f;
	}
	return nullptr;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R> void
TiledAdaptiveMesh<T, D, R>::Item::add_item(const Ind<D> &dpos, int drank){ ///< создает узел с рангом rank+drank и смещенной на dpos на ранге rank+drank
	if(storage->fix_mode) return;
	Ind<D> p, tp;  int r = tile->rank()+drank;
	if(r<0 || r>storage->rank_lim){ WMSG("incorrect target rank ", r, tile->rank(), drank); abort(); } 
	for(int i=0; i<D; i++){
		int sz = storage->tbox[i]<<(R+r);
		p[i] = ((R+drank>=0? tpos[i]<<(R+drank): tpos[i]>>-(R+drank)) + (drank>0? storage->coords[off][i]<<drank: storage->coords[off][i]>>-drank) + dpos[i] + sz)%sz;  // ПГУ
		tp[i] = p[i]>>R;
	}
	add_tiles[storage->tpos2toff(tp, r)].insert(ZCurve32<D>(p, R).off);
}
//------------------------------------------------------------------------------
template <typename T, int D, int R> void TiledAdaptiveMesh<T, D, R>::config_item(typename TiledAdaptiveMesh<T, D, R>::Item& item,
																				 typename TiledAdaptiveMesh<T, D, R>::tile_t* tile){			
	item.cube[0] = item.tile = tile;  item.tpos = toff2tpos(tile->toff);
	for(int i=1; i<(1<<D); i++){
		Ind<D> tpos = item.tpos; for(int j=0; j<D; j++){ tpos[j] -= bool(i&(1<<j)); if(tpos[j]<0) tpos[j] += tbox[j]<<tile->rank(); } // ПГУ
		auto I = forest.find(tpos2toff(tpos, tile->rank())); item.cube[i] = I==forest.end()? nullptr: &(I->second);
	}			
}
//------------------------------------------------------------------------------
template <typename T, int D, int R> template <typename Func> void
TiledAdaptiveMesh<T, D, R>::for_each(Func func, uint32_t rmask, uint64_t groups){
	fix_mode = false;
	Item item; item.storage = this;
	// for(int tID=0, tsz=tiles.size(); tID<tsz; tID++){
	for(auto &I: forest){
		tile_t *tile = &I.second; if(!((1<<tile->rank())&rmask) || !(tile->groups&groups)) continue;
		config_item(item, tile);  uint64_t new_groups = 0;
		for(int f: tile->usage){ item.off = f; item.groups = tile->groups; func(tile->data[f], item); new_groups |= item.groups;  }
		tile->groups = new_groups;
		// if(!tile->groups) item.del_tiles[tile->toff];
	}
	fix_mode = true;
	for(auto I: item.add_tiles){
		tile_t* tile = &add_tile(toff2tpos(I.first), I.first&31);  config_item(item, tile);
		for(int f: I.second){
			item.off = f; item.groups = 0; func(tile->data[f], item);
			if(item.groups){ tile->usage.set(f);  tile->groups |= item.groups; }
		}
	}
	for(auto I: item.del_tiles){
		auto J = forest.find(I.first);  if(J==forest.end()) continue;
		for(int f: I.second) J->second.usage.set(f, false);
		if(!J->second.groups || !J->second.usage) del_tile(J->second.tID);
	}
}
//------------------------------------------------------------------------------
