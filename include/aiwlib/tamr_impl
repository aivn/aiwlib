// -*- C++ -*-
/**
 * Copyright (C) 2024, 2026 Antov V. Ivanov  <aiv.racs@gmail.com>
 * Licensed under the Apache License, Version 2.0
 *
 * TiledAdaptiveMesh methods implementation.
 * !!! DO NOT INCLUDE THIS FILE MANUALLY !!!
 **/

//------------------------------------------------------------------------------
//  инициализация
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based>
void TiledAdaptiveMesh<T, D, R, cell_based>::init(const Ind<D> &tbox_){
	static_assert(2<=D && D<=6 && 0<R && R*D<=22, "illegal TAMR template parameters");
	tbox = tbox_;  tmul[0] = 1; for(int i=1; i<D; i++) tmul[i] = tmul[i-1]*tbox[i-1];
	zbound = 64; for(int sz=tbox.prod(); sz; sz>>=1) zbound--;  // log2(sz)
	zmask = (uint64_t(1)<<zbound)-1;  rank_lim = (zbound-5)/D;
	if(rank_lim<0 || zbound<5){ WMSG("TAMR too large ", D, R, tbox, zbound, rank_lim);  abort(); }
	forest.clear();  stencils.clear();  tiles.clear();  rtiles.clear(); rtiles.resize(rank_lim+1);
	for(Ind<D> tpos: irange<D>(tbox)){ add_tile(tpos, 0).usage.fill(1); }
	for(ZCurve64<D> z(0, R); z; z.off++) coords[z.off] = *z;  // заполнение таблицы координат
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> typename TiledAdaptiveMesh<T, D, R, cell_based>::tile_t&
TiledAdaptiveMesh<T, D, R, cell_based>::add_tile(const Ind<D> &tpos, const int rank){  ///< при необходимости добавляет тайл и встраивает его в струкутуру данных
	if(rank<0 || rank>rank_lim){ WMSG("incorrect rank ", rank, rank_lim); abort(); }  // ???
	uint64_t toff = tpos2toff(tpos, rank);  auto I = forest.find(toff); if(I!=forest.end()) return I->second;
	tile_t &tile = forest[toff]; tile.toff = toff; tiles.push_back(&tile);  tile.tID = tiles.size()-1;
	rtiles[rank].push_back(&tile);  tile.rtID = rtiles[rank].size()-1;
	while(toff&31){  // поиск вверх
		toff = up_toff(toff); I = forest.find(toff);
		if(I!=forest.end()){ tile.parent = &(I->second); break; }
	}
	return tile;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> void
TiledAdaptiveMesh<T, D, R, cell_based>::del_tile(int tID){
	tile_t *t = tiles[tID];  uint64_t ntoff = next_toff(t->toff);
	for(auto I=forest.upper_bound(t->toff); I!=forest.end() && I->second.toff<ntoff; ++I) if(I->second.parent==t) I->second.parent = t->parent;
	if(tID<int(tiles.size()-1)){ tiles[tID] = tiles.back(); tiles[tID]->tID = tID; } tiles.pop_back();
	auto &rtls = rtiles[t->rank()]; int rtID = t->rtID;
	if(rtID<int(rtls.size()-1)){ rtls[rtID] = rtls.back(); rtls[rtID]->rtID = rtID; } rtls.pop_back();
	forest.erase(t->toff); 
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> int
TiledAdaptiveMesh<T, D, R, cell_based>::add_stencil(const std::vector<Ind<D> > &stencil){  ///< добавляет шаблон в таблицу stencil-ов, возвращает stencilID>0
	stencils.emplace_back(); std::vector<stencil_node_t>& nodes = stencils.back();  nodes.reserve(stencil.size()<<R*D);
	for(const Ind<D>& pos: stencil) if(!(-ind(1<<R)<=pos) || !(pos<=ind(1<<R))){ WMSG("incorrect stencil pos ", pos, 1<<R); abort(); }
	for(int itID=0; itID<(1<<R*D); itID++) for(int nID=0, sz=stencil.size(); nID<sz; nID++){						
			Ind<D> pos = coords[itID]+stencil[nID]; stencil_node_t n; n.tID = 0;  int tmul = 1;
			for(int i=0; i<D; i++){
				if(pos[i]<0) pos[i] += 1<<R;               // попали в тайл слева
				else if(pos[i]<(1<<R)) n.tID += tmul;      // попали центральный тайл 
				else{ pos[i] -= 1<<R;  n.tID += 2*tmul; }  // попали в тайл справа
				tmul *= 3;  // формируем смещение в кубике 3х3х3... тайлов
			}
			n.off = ZCurve32<D>(pos, R).off;
			nodes.push_back(n);
			// WMSG(cID, stencil[nID],  nID, coords[cID], pos, n.tID, n.off);
		}
	return stencils.size()-1;
}
//------------------------------------------------------------------------------
//  диагностика
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> void
TiledAdaptiveMesh<T, D, R, cell_based>::tiles2dat(std::string fname) const {
	if(D!=2) return;
	std::ofstream fout(fname);
	for(auto I=forest.begin(); I!=forest.end(); ++I){
		int rank = I->second.rank();  float d = 1.f/(1<<rank); Vecf<D> pos = toff2tpos(I->first)*d;
		fout<<pos             <<' '<<rank<<'\n'
			<<pos+vecf(0.f, d)<<' '<<rank<<'\n'
			<<pos+vecf(d, d)  <<' '<<rank<<'\n'
			<<pos+vecf(d, 0.f)<<' '<<rank<<'\n'
			<<pos             <<' '<<rank<<"\n\n\n";
	}
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> void
TiledAdaptiveMesh<T, D, R, cell_based>::items2dat(std::string fname) const {
	std::ofstream fout(fname);
	for(auto I=forest.begin(); I!=forest.end(); ++I){
		int rank = I->second.rank();  float d = 1.f/(1<<rank); Vecf<D> pos = toff2tpos(I->first)*d*(1<<R);
		if(cell_based) for(int p: I->second.usage) fout<<pos+(coords[p]+vecf(.5f))*d<<' '<<rank<<'\n';
		else for(int p: I->second.usage) fout<<pos+coords[p]*d<<' '<<rank<<'\n';
	}
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> Indl<2>
TiledAdaptiveMesh<T, D, R, cell_based>::size(uint32_t rmask, uint64_t gmask) const {
	Indl<2> res;
	for(const tile_t *t: tiles) if((t->groups&gmask) && ((1<<t->rank())&rmask)){ res[0] += t->usage.size(); res[1]++; }
	return res;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> Ind<2>
TiledAdaptiveMesh<T, D, R, cell_based>::ranks_range() const {
	Ind<2> res(rank_lim, 0);
	for(int i=0; i<rank_lim; i++) if(rtiles[i].size()){
			if(res[0]>i) res[0] = i;
			if(res[1]<i) res[1] = i;
		}
	return res;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> template <int V, typename Func, typename Fout> void
TiledAdaptiveMesh<T, D, R, cell_based>::dump2balls(Func func, Fout &&fout, std::string head) const {  ///< func(const T&, int rank, const Ind<D> &pos) ==> Vecf<V>
	// как то по уровням выводить при многослойном покрытии?
	// double t_start = omp_get_wtime();
	Vecf<D> bmin, bmax(tbox*(1<<R));
	BinaryHead bh;  bh.dim = 3; bh.szT = 16+V*4; bh.head = head; bh.count = size()[0]; bh.type = BinaryHead::balls;
	// for(int i=0; i<D; i++){ bh.bmin[i] = bmin[i];  bh.bmax[i] = bmax[i]; }
	for(int i=0; i<D; i++){ bh.bmin[i] = 0;  bh.bmax[i] = tbox[i]<<R; }
	Vecf<D> tstep = (bmax-bmin)/tbox;  if(D<3){ bh.bmin[2] = -tstep[0]/(2<<R); bh.bmax[2] = tstep[0]/(2<<R); }
	bh.dump(fout); 
	for(const tile_t *tile: tiles){		
		Vecf<D> step = tstep/(1<<tile->rank()+R), tbmin = bmin + (toff2tpos(tile->toff)&step)*(1<<R); float radius = step[0]/2, zero = 0;
		for(int off: tile->usage){
			Vecf<D> coord = tbmin + (coords[off]&step);  if(cell_based) coord += step*.5f;
			fout.write((const char*)&coord, (D<=3?D:3)*4); for(int i=D; i<3; i++){ fout.write((const char*)&zero, 4); }
			fout.write((const char*)&radius, 4);  Vecf<V> v = func(tile->data[off]);  fout.write((const char*)&v, sizeof(v));
			//size_t fpos = fout.tell();  tile->data[i].*dump(fout);
			//if(fout.tell()-fpos!=szT){  std::cerr<<"incorrect dump size "<<fout.tell()-fpos<<"!="<<szT<<std::endl; abort();  }
		}
	}
	// return omp_get_wtime()-t_start;	
}
//------------------------------------------------------------------------------
//  произвольный доступ
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> Ind<2>
TiledAdaptiveMesh<T, D, R, cell_based>::get_addr(const Ind<D+1> &pos_rank) const {
	Ind<D> tpos, p;  int r = pos_rank[D];
	for(int i=0; i<D; i++){
		p[i] = (pos_rank[i]<0? pos_rank[i]+(tbox[i]<<(R+r)): pos_rank[i])%(tbox[i]<<(R+r)); // ПГУ  
		tpos[i] = p[i]>>R;  p[i] &= (1<<R)-1; 
	}
	uint64_t toff0 = tpos2toff(tpos, r), toff = toff0;  int off0 = ZCurve32<D>(p, R).off, off = off0;  
	do {  // поиск вверх по дереву, оптимизировать через t->parent?
		auto I = forest.find(toff);
		if(I!=forest.end() && I->second.usage[off]) return ind(I->second.tID, off);
	} while(dec_rank(off, toff));
	off = off0; toff = toff0;
	while(inc_rank(off0, toff0)){  // поиск вниз по дереву, м.б. лучше  сделать через std::map::lower_bound? Вынести в отд. функцию? насколько для ячейки такой поиcк имеет смысл?
		auto I = forest.find(toff);
		if(I!=forest.end() && I->second.usage[off]) return ind(I->second.tID, off);		
	}
	return ind(-1, -1);;
}
//------------------------------------------------------------------------------
//  обход и перестроение сетки
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> const T*
TiledAdaptiveMesh<T, D, R, cell_based>::BItem::operator [] (int cID) noexcept {  ///< доступ к элементу шаблона номер cID, если такого узла нет возвращает nullptr
	stencil_node_t sn = snodes[cID];  const tile_t* t = cube[sn.tID];
	if(t && t->usage[sn.off]){ srank = t->rank();  return t->data+sn.off; }  // штатное поведение, целевой элемент есть
	if(cell_based || (sn.off&((1<<D)-1))==0){  // смотрим только на один ранг вверх --- для cell_based всегда, для node_based только если попадаем в узел крупной сетки
		if(t && t->parent){  // есть соседний тайл и тайл над ним
			int f = storage->up_off(sn.off, t->toff);
			if(t->parent->usage[f]){ srank = t->rank()-1; return t->parent->data+f; }
		}
		if(!t){  // соседнего тайла нет, но все же может быть тайл сверху
			auto I = storage->forest.find(storage->up_toff(toff_cube[sn.tID]));  // вот это дорогая операция, создать в item битовую маску с указанием есть ли кто то сверху?
			if(I!=storage->forest.end()){
				int f = storage->up_off(sn.off, toff_cube[sn.tID]);
				if(I->second.usage[f]){ srank = tile->rank()-1; return I->second.data+f; }
			}
		}
	}
	// смотрим только на один ранг вниз
	int f = sn.off;  uint64_t tf = toff_cube[sn.tID];
	if(storage->inc_rank(f, tf)){
		auto I = storage->forest.find(tf);
		if(I!=storage->forest.end() && I->second.usage[f]){ srank = tile->rank()+1; return I->second.data+f; }
	}
	srank = -1; return nullptr;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> const T*
TiledAdaptiveMesh<T, D, R, cell_based>::Item::get_up_item() const noexcept {  ///< возвращает узел с рангом на единицу больше (если есть, иначе nullptr)
	const tile_t *p = tile->parent;  int r = tile->rank();
	while(p){
		int dr = tile->rank()-p->rank();
		if(off&(1<<D*dr-1)) return nullptr;  // попали между узлами
		int f = (((tile->toff>>zbound-r*D)&((1<<dr*D)-1))<<(R-dr)*D)&((1<<R*D)-1)+(off>>dr*D);   // ???
		if(p->usage[f]) return p->data+f;
		p = p->parent;
	}
	return nullptr;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> const T*
TiledAdaptiveMesh<T, D, R, cell_based>::Item::get_down_item() const noexcept {  ///< возвращает узел с рангом на единицу меньше (если есть, иначе nullptr)
	// выделить в отдельную функцию - в Stencil[] есть такой же код???
	uint64_t tf = tile->toff; int r = tile->rank()-1, f = off; uint64_t ntoff = next_toff(tf);  
	while(inc_rank(f, tf)){  // вот тут скорее всего ошибка;-(
		auto I = storage->forest.lower_bound(tf);  if(I==storage->forest.end() || I->second.toff>=ntoff) break;
		if(I->second.toff==tf && I->second.rank()==rank && I->second.usage[f]) return I->second.data+f;
	}
	return nullptr;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> void
TiledAdaptiveMesh<T, D, R, cell_based>::Item::add_item(const Ind<D> &dpos, int drank){ ///< создает узел с рангом rank+drank и смещенной на dpos на ранге rank+drank
	if(storage->fix_mode) return;
	Ind<D> p, tp;  int r = tile->rank()+drank;
	if(r<0 || r>storage->rank_lim){ WMSG("incorrect target rank ", r, tile->rank(), drank); abort(); } 
	for(int i=0; i<D; i++){
		int sz = storage->tbox[i]<<(R+r);
		p[i] = ((R+drank>=0? tpos[i]<<(R+drank): tpos[i]>>-(R+drank)) + (drank>0? storage->coords[off][i]<<drank: storage->coords[off][i]>>-drank) + dpos[i] + sz)%sz;  // ПГУ
		tp[i] = p[i]>>R;
	}
	add_tiles[storage->tpos2toff(tp, r)].insert(ZCurve32<D>(p, R).off);
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> bool
TiledAdaptiveMesh<T, D, R, cell_based>::config_item(typename TiledAdaptiveMesh<T, D, R, cell_based>::BItem& item,
													typename TiledAdaptiveMesh<T, D, R, cell_based>::tile_t* tile){			
	item.cube[calc_3pow<D>::x/2] = item.tile = tile;  item.toff_cube[calc_3pow<D>::x/2] = tile->toff;
	item.tpos = toff2tpos(tile->toff);  int rank = tile->rank();  bool easy = tile->usage.all();
	for(int cid=0; cid<calc_3pow<D>::x; cid++){  // это можно оптимизировать?
		if(cid==calc_3pow<D>::x/2) continue;
		Ind<D> tpos = item.tpos;  int ii = cid;
		for(int i=0; i<D; i++){ int sz = tbox[i]<<rank; tpos[i] = (tpos[i]+ii%3-1+sz)%sz; ii /= 3; }  // ПГУ
		item.toff_cube[cid] = tpos2toff(tpos, tile->rank()); 
		auto I = forest.find(item.toff_cube[cid]); item.cube[cid] = I==forest.end()? nullptr: &(I->second);
		if(easy && (!item.cube[cid] || !item.cube[cid]->usage.all())) easy = false;
	}
	return !easy;
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> template <typename Func> void
TiledAdaptiveMesh<T, D, R, cell_based>::for_each(Func func, uint32_t rmask, uint64_t groups){
	fix_mode = false;
	BItem item; item.storage = this;
	// for(int tID=0, tsz=tiles.size(); tID<tsz; tID++){
	for(auto &I: forest){
		tile_t *tile = &I.second; if(!((1<<tile->rank())&rmask) || !(tile->groups&groups)) continue;
		bool is_bound = config_item(item, tile);  uint64_t new_groups = 0;
		if(is_bound) for(int f: tile->usage){ item.off = f; item.groups = tile->groups; func(tile->data[f], item); new_groups |= item.groups;  }
		else for(int f=0; f<(1<<R*D); f++){ item.off = f; item.groups = tile->groups; func(tile->data[f], (Item&)item); new_groups |= item.groups;  }
		tile->groups = new_groups;
		// if(!tile->groups) item.del_tiles[tile->toff];
	}
	fix_mode = true;
	for(auto I: item.add_tiles){
		tile_t* tile = &add_tile(toff2tpos(I.first), I.first&31);  config_item(item, tile);
		for(int f: I.second){
			item.off = f; item.groups = ~uint64_t(0); func(tile->data[f], item); 
			if(item.groups){ tile->usage.set(f);  tile->groups |= item.groups; }
		}
		if(!tile->usage.any()) del_tile(tile->tID);
	}
	for(auto I: item.del_tiles){
		auto J = forest.find(I.first);  if(J==forest.end()) continue;
		for(int f: I.second) J->second.usage.set(f, false);
		if(!J->second.groups || !J->second.usage) del_tile(J->second.tID); 
	}
}
//------------------------------------------------------------------------------
template <typename T, int D, int R, bool cell_based> uint64_t
TiledAdaptiveMesh<T, D, R, cell_based>::tpos2toff(Ind<D> tpos, int rank) const {  ///< пересчитывает позицию и ранг тайла в ключ forest, в т.ч. реализует ПГУ
	Ind<D> tpos0; int mask = (1<<rank)-1;   // позиция дерева в лесу
	for(int i=0; i<D; i++){
		if(tpos[i]<0) tpos[i] += tbox[i]<<rank;  // ПГУ
		tpos0[i] = tpos[i]>>rank;
		if(tpos0[i]>tbox[i]) tpos0[i] -= tbox[i]; // ПГУ
		tpos[i] &= mask;  // позиция на Z-кривой в дереве
	}
	return (uint64_t(tpos0*tmul)<<zbound)|(ZCurve64<D>(tpos, rank).off<<(zbound-rank*D))|rank;
}
//------------------------------------------------------------------------------
