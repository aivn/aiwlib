// -*- C++ -*-
#ifndef AIW_PLOT2D_HPP
#define AIW_PLOT2D_HPP

/**
 * Copyright (C) 2015, 2017 Antov V. Ivanov  <aiv.racs@gmail.com> and Sergey Khilkov <ezz666@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#ifndef AIW_NO_PIL
#   include <Python.h>
#   include <Imaging.h>
#endif // AIW_NO_PIL

#ifndef AIW_NO_PNG
#   define PNG_SKIP_SETJMP_CHECK 1
#   include <png.h>
#endif // AIW_NO_PNG

#include "mesh"
#include "sphere"

namespace aiw{
    //--------------------------------------------------------------------------
    //  calc color
	//--------------------------------------------------------------------------
    const float grey_pal[7] = {0,0,0, 1,1,1, -1}, 
		inv_grey_pal[7]     = {1,1,1, 0,0,0, -1}, 
		black_red_pal[10]   = {0,0,0, 1,1,1, 1,0,0, -1}, 
		green_blue_pal[10]  = {0,1,0, 1,1,1, 0,0,1, -1}, 
		neg_pos1_pal[28]    = {0,0,0, 1,0,0, 1,.5,0, 1,1,0, 1,1,1, 1,0,1, 0,0,1, 0,1,1, 0,1,0, -1},
    	neg_pos2_pal[28]    = {0,0,0, 1,1,0, 1,.5,0, 1,0,0, 1,1,1, 0,1,0, 0,1,1, 0,0,1, 1,0,1, -1},
    	positive_pal[28]    = {1,1,1, 1,0,0, 1,.5,0, 1,1,0, 0,1,0, 0,1,1, 0,0,1, 1,0,1, 0,0,0, -1},
    	rainbow_pal[28]     = {0,0,0, 1,0,0, 1,.5,0, 1,1,0, 0,1,0, 0,1,1, 0,0,1, 1,0,1, 1,1,1, -1},
    	color_pal[22]       = {       1,0,0, 1,.5,0, 1,1,0, 0,1,0, 0,1,1, 0,0,1, 1,0,1,        -1},
    	inv_rainbow_pal[28] = {1,1,1, 1,0,1, 0,0,1,  0,1,1, 0,1,0, 1,1,0, 1,.5,0, 1,0,0, 0,0,0, -1},
    	cyclic_pal[31]      = {0,0,0, 1,0,0, 1,.5,0, 1,1,0, 0,1,0, 0,1,1, 0,0,1, 1,0,1, 1,1,1, 0,0,0, -1};
	//--------------------------------------------------------------------------
	struct CalcColor{
		int max_rgb = 255;
		float const *pal = nullptr;
		int len_pal = 0;
		float min = 0, mul = 1.;
		aiw::Ind<3> nan_color = ind(127, 127, 127); // grey
		bool cyclic_pal = false;
		// logscale ???
		
		void init(float const *pal_, float min_, float max_);
		// void init(const char *pal_, float min_, float max_); for Python?
		inline aiw::Ind<3> operator ()(float f) const {
			f = (f-min)*mul;
			if(std::isnan(f)) return nan_color;
			if(!cyclic_pal){
				if(f<0.) f = 0.;
				else if(f>1.) f = 1.;
			}
			if(f){
				if(f==::floor(f)) f = 1.;
				else f -= ::floor(f);
			}			
			float w = f*len_pal; int i = ::floor(w); w -= i;
			return Ind<3>((pal[3*i]  *(1-w) + pal[3*i+3]*w)*max_rgb, 
						  (pal[3*i+1]*(1-w) + pal[3*i+4]*w)*max_rgb, 
						  (pal[3*i+2]*(1-w) + pal[3*i+5]*w)*max_rgb);
		}
	};
	//--------------------------------------------------------------------------
#ifndef AIW_NO_PIL
	struct ImagePIL {
		ImagingMemoryInstance* im;
		PyObject* pil_ptr;

		void construct(PyObject*);
		ImagePIL(PyObject* p);
		ImagePIL(aiw::Ind<2> size_);

		aiw::Ind<2> size;
		inline void set(const aiw::Ind<2>& pos, const aiw::Ind<3>& color){
			char* ptr = im->image[pos[1]] + pos[0]*im->pixelsize;
			ptr[0] = color[0]; ptr[1] = color[1]; ptr[2] = color[2];
		}
   };	
#endif // AIW_NO_PIL
	//--------------------------------------------------------------------------
#ifndef AIW_NO_PNG
	class ImagePNG{
		FILE * fp; 	png_structp png_ptr; png_infop info_ptr; png_bytep* rows;
		void init(const char* fname, aiw::Ind<2> size_);
	public:
		ImagePNG(const char* fname, aiw::Ind<2> size_){ init(fname, size_); }
#ifndef SWIG
		template <typename ... Args> ImagePNG(const char *format, aiw::Ind<2> size_, Args ... args){
			std::stringstream buf; format2stream(buf, format, args...);
			init(buf.str().c_str(), size_);
		}
#endif //SWIG
		~ImagePNG();

		aiw::Ind<2> size;
		void set(const aiw::Ind<2>& pos, const aiw::Ind<3>& color){
			png_byte *ptr = rows[pos[1]] + 3*pos[0];
			ptr[0] = color[0]; ptr[1] = color[1]; ptr[2] = color[2];
		}
    };
#endif // AIW_NO_PNG
	//--------------------------------------------------------------------------
	template <typename T, typename P> void plot2D(const aiw::Mesh<T, 2> &f, const CalcColor &color, P& image){
		Vec<2> step = (f.bmax-f.bmin)/image.size; Vec<2> bmin = f.min + .5*step;
		if(f.bbox()==image.size) for(Ind<2> pos; pos^=image.size; ++pos) image.set(pos, color(f[pos])); 
		else for(Ind<2> pos; pos^=image.size; ++pos) image.set(pos, color(f(bmin+(pos&step))));
	}
	//--------------------------------------------------------------------------
	template <typename T, typename P> void plot2D(const aiw::Sphere<T>  &f, const CalcColor &color, P& image, double phi0=0.){ //, bool interp=false){
		int x_max = image.size[0]/2, y_max = image.size[1]/2, x; 
		double h = 1./y_max, hx = 2./x_max; double alpha = x_max*h;

		for(int y=-y_max; y<y_max; y++){
            for(x=-x_max; x<=-sqrt(y_max*y_max-y*y)*alpha; x++) image.set_pixel(ind(x_max+x, y_max+y), ind(255)); // empty fill
			double Y = y*h, a1 = sqrt(1.-Y*Y), b1 = M_PI/(2.*a1), z1 = 2*(asin(Y)+Y*a1)/M_PI, c1 = sqrt(1-z1*z1);  
			for(; x<sqrt(y_max*y_max-y*y)*alpha; x++){
				double sbv, cbv; sincos(b1*x*hx+phi0, &sbv, &cbv);
				Vec<3> coord = vec(c1*cbv, c1*sbv, z1);
				// image.set(ind(x_max+x, y_max+y), interp? f(coord): f[coord]);
				image.set(ind(x_max+x, y_max+y), f[coord]);
			}
            for(; x<x_max; x++) image.set_pixel(ind(x_max+x, y_max+y), ind(255)); // empty fill
		}	
	}
	//--------------------------------------------------------------------------
};
#endif //AIW_PLOT2PIL_HPP
