// -*- C++ -*-
#ifndef AIW_PLOT2D_HPP
#define AIW_PLOT2D_HPP

/**
 * Copyright (C) 2015, 2017 Antov V. Ivanov  <aiv.racs@gmail.com> and Sergey Khilkov <ezz666@gmail.com>
 * Licensed under the Apache License, Version 2.0
 **/

#include "mesh"
#include "sphere"
#include "amrview"
#include "view/color"
#include "view/images"

namespace aiw{
	//--------------------------------------------------------------------------
	template <typename T, typename P> void plot2D(const aiw::Mesh<T, 2> &f, const CalcColor &color, P& image, int bounds=0){
		Vec<2> step = (f.bmax-f.bmin)/image.size; Vec<2> bmin = f.bmin + .5*step;
		if(f.bbox()==image.size) for(Ind<2> pos; pos^=image.size; ++pos) image.set_pixel(pos, color(f[pos])); 
		else for(Ind<2> pos; pos^=image.size; ++pos) image.set_pixel(pos, color(f(bmin+(pos&step))));
	}
	//--------------------------------------------------------------------------
	template <typename T, typename P> void plot2D(const aiw::Sphere<T>  &f, const CalcColor &color, P& image, bool mollweide=true, double phi0=0.){ 
		if(mollweide){
			int x_max = image.size[0]/2, y_max = image.size[1]/2, x; 
			double h = 1./y_max, hx = 2./x_max; double alpha = x_max*h;
			
			for(int y=-y_max; y<y_max; y++){
				for(x=-x_max; x<=-sqrt(y_max*y_max-y*y)*alpha; x++) image.set_pixel(ind(x_max+x, y_max+y), ind(255)); // empty fill
				double Y = y*h, a1 = sqrt(1.-Y*Y), b1 = M_PI/(2.*a1), z1 = 2*(asin(Y)+Y*a1)/M_PI, c1 = sqrt(1-z1*z1);  
				for(; x<sqrt(y_max*y_max-y*y)*alpha; x++){
					double sbv, cbv; sincos(b1*x*hx+phi0, &sbv, &cbv);
					Vec<3> coord = vec(c1*cbv, c1*sbv, z1);
					// image.set_pixel(ind(x_max+x, y_max+y), color(interp? f(coord): f[coord]));
					image.set_pixel(ind(x_max+x, y_max+y), color(f(coord)));
				}
				for(; x<x_max; x++) image.set_pixel(ind(x_max+x, y_max+y), ind(255)); // empty fill
			}
		} else {
			Vec<2> step = vec(2*M_PI, -M_PI)/image.size; Vec<2> bmin = vec(phi0-M_PI, M_PI) + .5*step;
			for(Ind<2> pos; pos^=image.size; ++pos) image.set_pixel(pos, color(f(bmin+(pos&step))));
		}
	}
	//--------------------------------------------------------------------------
	template <typename P> void plot2D(AdaptiveMeshView &f, const CalcColor &color, P& image, int bounds=0){
		Vec<2> step = Vec<2>(image.size)/f.bbox();
		// for(Ind<2> pos; pos^=image.size; ++pos) image.set_pixel(pos, ind(255,255,255));
		for(auto I=f.begin(); I!=f.end(); ++I){
			Ind<2> imin = ((I.imin&step)+vec(.5))<<(image.size-ind(1))>>ind(0), sz = (((I.imax&step)+vec(.5))<<image.size)-imin; Ind<3> c = color(*I);
			// Ind<2> imin = ((I.imin&step)+vec(1.5))<<(image.size-ind(1))>>ind(0), sz = (((I.imax&step)-vec(.5))<<image.size)-imin; Ind<3> c = color(*I);
			for(Ind<2> pos; pos^=sz; ++pos) image.set_pixel(imin+pos, c);
			if(bounds&1){
				for(int i=0; i<sz[0]; i++) image.set_pixel(imin+ind(i,0), ind(255,0,0));
				for(int i=1; i<sz[1]; i++) image.set_pixel(imin+ind(0,i), ind(255,0,0));
			} 
			if(bounds&2){
				if(I.tile_bound(-2)) for(int i=0; i<sz[0]; i++) image.set_pixel(imin+ind(i,0), ind(0,0,255));
				if(I.tile_bound(-1)) for(int i=0; i<sz[1]; i++) image.set_pixel(imin+ind(0,i), ind(0,0,255));
				if(I.tile_bound(2)) for(int i=0; i<sz[0]; i++) image.set_pixel(imin+ind(i,sz[1]-1), ind(0,0,255));
				if(I.tile_bound(1)) for(int i=0; i<sz[1]; i++) image.set_pixel(imin+ind(sz[0]-1,i), ind(0,0,255));
			} 
		}
	}
	//--------------------------------------------------------------------------
};
#endif //AIW_PLOT2PIL_HPP
